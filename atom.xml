<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Acptek</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://acptek.github.io/"/>
  <updated>2020-08-06T13:24:59.143Z</updated>
  <id>https://acptek.github.io/</id>
  
  <author>
    <name>acptek</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TCP/IP 自治系统内部路由</title>
    <link href="https://acptek.github.io/2020/08/06/TCP-IP-%E8%87%AA%E6%B2%BB%E7%B3%BB%E7%BB%9F%E5%86%85%E9%83%A8%E8%B7%AF%E7%94%B1/"/>
    <id>https://acptek.github.io/2020/08/06/TCP-IP-自治系统内部路由/</id>
    <published>2020-08-06T13:14:10.000Z</published>
    <updated>2020-08-06T13:24:59.143Z</updated>
    
    <content type="html"><![CDATA[        <h1 id="Ch-14-自治系统内部路由"   >          <a href="#Ch-14-自治系统内部路由" class="heading-link"><i class="fas fa-link"></i></a>Ch 14 自治系统内部路由</h1>      <p>典型的内部路由协议</p><ul><li>RIP，RIPng(IPv6)，OSPF，IS-IS</li></ul><a id="more"></a>        <h2 id="1-内部路由器"   >          <a href="#1-内部路由器" class="heading-link"><i class="fas fa-link"></i></a>1 内部路由器</h2>      <p>相对于属于不同自治系统的路由器而言，称为内部路由</p>        <h3 id="1-1-内部路由如何学习到自己的路由信息"   >          <a href="#1-1-内部路由如何学习到自己的路由信息" class="heading-link"><i class="fas fa-link"></i></a>1.1 内部路由如何学习到自己的路由信息</h3>      <ul><li>（静态路由）对于小型系统，可以采取手工办法：人工完成路由表的创建和更新和删除</li><li>（动态路由）自动配置方案，</li></ul><p>对于稍微大一点的自治系统会选择几个内部网关协议</p>        <h3 id="1-2-在简单性与功能性方面做折中"   >          <a href="#1-2-在简单性与功能性方面做折中" class="heading-link"><i class="fas fa-link"></i></a>1.2 在简单性与功能性方面做折中</h3>      <p>在实践中，AS中通常采用多个内部协议。</p><ul><li>对于小的AS，可能采用单一的独有内部协议</li><li>对于大的AS，通常会选取几个内部网关协议（选取一个IGP的一个小的集合来支持AS内部的需求）</li></ul>        <h3 id="1-2-IGP-内部网关协议"   >          <a href="#1-2-IGP-内部网关协议" class="heading-link"><i class="fas fa-link"></i></a>1.2 IGP 内部网关协议</h3>      <p>是指一类内部网关协议，与EGP是一个相对的概念。IGP是一个路由协议的类别。</p>        <h2 id="2-RIP-路由信息协议"   >          <a href="#2-RIP-路由信息协议" class="heading-link"><i class="fas fa-link"></i></a>2  RIP 路由信息协议</h2>              <h3 id="RIP的一些基本信息"   >          <a href="#RIP的一些基本信息" class="heading-link"><i class="fas fa-link"></i></a>RIP的一些基本信息</h3>      <p>在unix中的实现是 <strong>routed</strong></p><p>RIP中的路由信息交换，最初通过广播方式，后来改为多播方式</p><p>RIP适用于局域网环境（不大的网络范围）</p>        <h3 id="RIP使用距离向量算法"   >          <a href="#RIP使用距离向量算法" class="heading-link"><i class="fas fa-link"></i></a>RIP使用距离向量算法</h3>      <ul><li>RIP属于：距离向量协议</li><li>RIP将协议的参与者（路由器，主机）分为两类，<br>一类为<strong>主动的设备</strong>，若为主动设备则一定是路由器，并负责向外通告路由表<br>一类为<strong>被动的设备</strong>，处理主动设备发送过来的向量表，但是不能向外传自己的向量表</li><li>RIP中，本地的fib向外通告的默认周期是30s，通过update报文 采用广播/多播方式向外发信息，将本地的fib路由信息抽取出来装配到update报文中发送</li><li>RIP距离向量算法，<br>距离的单位：跳数。直接相连为1跳（即起始值就为一跳，一般起始值为零跳），经过一个路由增加一跳。（其中：可以人为配置一些已知网络的跳数：例如给卫星网增加跳数）</li></ul>        <h3 id="RIP的特点"   >          <a href="#RIP的特点" class="heading-link"><i class="fas fa-link"></i></a>RIP的特点</h3>      <ul><li>主动端与被动端都监听广播信息，根据DV算法更新路由表信息。在一定时间后向外传播通告</li><li>路由表采用<strong>滞后</strong>技术：防止路径的<u>振荡（例如在路径费用相同的路径上来回切换，此时应该不进行更新）</u></li><li>需要定时器来设定路径的有效期：针对一个目标设定到达路径的有效期，RIP中默认180s，超时后目标对应的表项无效</li></ul>        <h3 id="RIP需要解决的三类差错"   >          <a href="#RIP需要解决的三类差错" class="heading-link"><i class="fas fa-link"></i></a>RIP需要解决的三类差错</h3>      <ul><li><p>路由回路问题</p></li><li><p>不稳定性问题</p><p>RIP中跳数的最大的距离为15，16指的是无穷大</p><p>如果网络过大，需要对网络进行划分</p></li><li><p>慢收敛问题</p></li></ul>        <h2 id="3-解决路由回路"   >          <a href="#3-解决路由回路" class="heading-link"><i class="fas fa-link"></i></a>3 解决路由回路</h2>      <p>慢收敛问题是路由回路造成的</p><p><strong>路由回路形成的原因</strong>：假设R2通过R1连接到一个网络N中，那么到达网络N的费用在R1路由表中保存的是1跳，在R2路由表中保存的是2跳。如果在某一时刻直接与网络N相连的R1和网络N出错断开，此时对R1而言到达网络N不可达，在RIP中跳数对应为16。但是在一个周期后R2向R1发送update消息，那么R1收到R2的路由向量表后更新自己本地转发表，将到达网络N标记为经过R2到达，同时费用改为3跳。此时形成了<u>路由回路</u>，R1，R2二者变为互相经过然后才能到达网络N的情况，所以会轮流增加表项中到达网络N的跳数，知道跳数增加到16是，才意识到网络N现在不可达。这个过程是一个<u>慢收敛</u>的过程。</p>        <h3 id="解决路由回路的方法"   >          <a href="#解决路由回路的方法" class="heading-link"><i class="fas fa-link"></i></a>解决路由回路的方法</h3>      <ul><li><p>水平分割：从一个目标获取的路由信息不能在将这个信息传回这个目标</p><p>所以，针对上述（路由回路形成的原因）的情况经过几轮的更新后，所有目标都能得知网络N不可达</p></li><li><p>保持（hold down）</p><p>设置间隔时间，RIP中是60s</p><p>如果接收到网络不可达消息，则先忽略此消息，等待hold down时间：这样所有节点都能获得网络不可达的消息 </p><p>缺点：在hold down期间若存在路由回路，该路由回路会一直被保留；同样，也会保留错误路由</p></li><li><p>逆向毒害 （poison reverse）</p><p>在连接断开时，向外通告的路由器保留表项的一些更新周期，但是向外通告的时候将费用改为无穷大</p><p>与<strong>触发式更新</strong>技术相结合：减少等待时间（当某个路径断开，则不等待向外通告更新周期的时间30s，立即向外通告）</p></li></ul>        <h3 id="解决方法中的缺点"   >          <a href="#解决方法中的缺点" class="heading-link"><i class="fas fa-link"></i></a>解决方法中的缺点</h3>      <ul><li>触发式更新的缺点：可能产生广播崩溃（短时间内update的广播消息过多耗尽链路带宽）</li><li>采用广播方式消耗额外带宽</li><li>如果存在回路，使得回路中拆除连接的报文信息无法传播出去</li><li>在广域网（更大的网络环境中），由于hold down等待的时间过长，使得上层协议判断连接已断开然后进行出错处理</li></ul>        <h2 id="4-RIP2-报文格式"   >          <a href="#4-RIP2-报文格式" class="heading-link"><i class="fas fa-link"></i></a>4 RIP2 报文格式</h2>              <h3 id="RIP1-报文格式-IPv4"   >          <a href="#RIP1-报文格式-IPv4" class="heading-link"><i class="fas fa-link"></i></a>RIP1 报文格式 (IPv4)</h3>              <h4 id="报文类型"   >          <a href="#报文类型" class="heading-link"><i class="fas fa-link"></i></a>报文类型</h4>      <ul><li>路由信息报文</li><li>信息请求报文</li></ul>        <h4 id="格式"   >          <a href="#格式" class="heading-link"><i class="fas fa-link"></i></a>格式</h4>      <p>采用相同的格式</p>        <h3 id="RIP2-报文格式"   >          <a href="#RIP2-报文格式" class="heading-link"><i class="fas fa-link"></i></a>RIP2 报文格式</h3>      <p><img src="http://acptek.gitee.io/blogpictures/TCPIP/ch14_rip2_messageformat.png" alt="rip2报文格式"></p><ul><li><p>COMMAND字段</p><p>总共5中类型</p><p><img src="http://acptek.gitee.io/blogpictures/TCPIP/ch14_rip2_messageformat_command.png" alt="command"></p></li><li><p>VERSION：版本号为2，RIP2</p></li><li><p>接下来是每一个目标：</p><p>FAMILY OF NET_k：网络的家族，对应IPv4的取值为2</p><p>ROUTE TAG FOR NET_k：标记这条路由的源</p><p>IP地址 （0.0.0.0 ：表示默认路由）</p><p>IP地址对应的子网掩码</p><p>到达目标网络NET_k的下一跳</p></li></ul>        <h3 id="RIP2-对比-RIP1"   >          <a href="#RIP2-对比-RIP1" class="heading-link"><i class="fas fa-link"></i></a>RIP2 对比 RIP1</h3>      <ul><li>RIP2 支持可变长子网掩码</li><li>支持CIDR：无类别地址寻址</li><li>采用多播替代广播</li></ul>        <h3 id="说明"   >          <a href="#说明" class="heading-link"><i class="fas fa-link"></i></a>说明</h3>      <p>rip报文的计算（报文长度等信息）依靠传输层服务，封装在udp，使用520端口</p>        <h2 id="5-RIPng"   >          <a href="#5-RIPng" class="heading-link"><i class="fas fa-link"></i></a>5 RIPng</h2>      <p>对于IPv6的RIP（RIP next generation）</p><p>使用的端口号：521</p>        <h3 id="报文格式"   >          <a href="#报文格式" class="heading-link"><i class="fas fa-link"></i></a>报文格式</h3>      <p><img src="http://acptek.gitee.io/blogpictures/TCPIP/ch14_ripng_messageformat.png" alt="ripng"></p><ul><li><p>ROUTE TABLE ENTRY K</p><p>每个占20字节，格式：</p><p><img src="http://acptek.gitee.io/blogpictures/TCPIP/ch14_ripng_messageformat_entry.png" alt="route table entry"></p><ul><li>IPv6 PRIFIX：占128位</li><li>ROUTE TAG：路由标签</li><li>PREFIX LENGTH：前缀长度，IPv6不分类通过前缀长度区分</li><li>METRIC：费用</li></ul></li></ul>        <h3 id="RIPng的特点"   >          <a href="#RIPng的特点" class="heading-link"><i class="fas fa-link"></i></a>RIPng的特点</h3>      <p>1 但是在ROUTE TABLE ENTRY中没有设置下一跳地址，由于IPv6地址过长，所以如果包含了下一跳在一个表项中会导致报文长度过长。</p><p>解决方案：</p><ul><li>若费用字段（METRIC）值为全1（0xFF）时，则当前表项代表Next Hop</li></ul><p>2 RIPng的更新周期是30s，表项超时间隔为180s</p><p>3 采用水平分割、逆向毒害和触发式更新来解决路由回路问题</p>        <h2 id="6-采用跳数作为单位的缺点"   >          <a href="#6-采用跳数作为单位的缺点" class="heading-link"><i class="fas fa-link"></i></a>6 采用跳数作为单位的缺点</h2>      <p>限制了网路的规模，导致RIP只能适用于小型互联网</p><p>使用跳数会造成一些不准确的情况（例如卫星网和以太网间）</p>        <h2 id="7-hello协议"   >          <a href="#7-hello协议" class="heading-link"><i class="fas fa-link"></i></a>7 hello协议</h2>      <p>（属于距离向量协议）</p><ul><li>采用时间延迟作为度量单位的协议</li><li>提供的功能：1 在所有运行hello协议的节点之间进行时钟的同步  2 计算基于时延的最短路径</li></ul>        <h3 id="特点："   >          <a href="#特点：" class="heading-link"><i class="fas fa-link"></i></a>特点：</h3>      <p>报文传输除了路由信息同时还带上时间戳：计算两个节点之间的时钟差异和进行同步<br>可以对到达目标的费用基于延迟进行计算，收到向量表后，按照延迟时间短的进行更新</p>        <h3 id="缺点："   >          <a href="#缺点：" class="heading-link"><i class="fas fa-link"></i></a>缺点：</h3>      <p>不稳定性：延迟时间是变化的（网络流量变化大，对延迟影响也较大等原因）</p><p>如果采用快速响应的策略，会造成二阶段震荡问题（反复在两条路径之间切换）</p>        <h3 id="避免震荡："   >          <a href="#避免震荡：" class="heading-link"><i class="fas fa-link"></i></a>避免震荡：</h3>      <ul><li>hold down：等一定的时间再去改变延时</li><li>round off measurements or  use threshold：设定一个阈值，当延时变化超过阈值才改变路由</li><li>use average measurement：使用平均度量方法，每一次延迟测量作为一个样本，N个样本中若出现超过k个比当前平均延迟小，此时才对路由进行改变</li></ul><p>不稳定性仍然存在，无法消除振荡</p>        <h2 id="8-OSPF协议"   >          <a href="#8-OSPF协议" class="heading-link"><i class="fas fa-link"></i></a>8 OSPF协议</h2>              <h3 id="Open-SPF-Protocol-特点"   >          <a href="#Open-SPF-Protocol-特点" class="heading-link"><i class="fas fa-link"></i></a>Open SPF Protocol 特点</h3>      <ul><li>属于IGP</li><li>开放标准</li><li>支持大型互联网，采用多区域管理</li><li>路由使用ToS</li><li>支持负载均衡（支持多条路径）</li><li>支持大型互联网（网络规模大）</li><li>支持认证</li><li>路由的粒度可以分为多个子网</li><li>支持CIDR</li><li>适应于多路访问（链路是共享链路，逻辑上是一条公共总线）</li><li>支持多播传递</li><li>支持虚拟连接</li><li>可以相互交换从外面学习到的路由信息（通过EGP学习获得和IGP学习获得）</li><li>OSPF报文传输的时候直接封装在IP内</li></ul>        <h3 id="OSPFv2报文格式"   >          <a href="#OSPFv2报文格式" class="heading-link"><i class="fas fa-link"></i></a>OSPFv2报文格式</h3>      <p><img src="http://acptek.gitee.io/blogpictures/TCPIP/ch14_ospfv2_messageformat.png" alt="ospfv2"></p><ul><li><p>version：版本号，=2</p></li><li><p>type：五种报文类型</p><p><img src="http://acptek.gitee.io/blogpictures/TCPIP/ch14_ospfv2_messageformat_type.png" alt="type"></p></li><li><p>source ip：报文发送者ip</p></li><li><p>area id：区域号，是一个区域的标识。</p><p>OSPF将网络区域分为主干区域和非主干区域两种类型。是一个二层的结构（构成了一个星形拓扑）</p></li><li><p>authentication type：认证类型，定义了认证方案</p><p>0：表示没有认证， 1：表示口令密码认证</p></li></ul>        <h3 id="OSPFv2-hello-报文"   >          <a href="#OSPFv2-hello-报文" class="heading-link"><i class="fas fa-link"></i></a>OSPFv2 hello 报文</h3>      <p><img src="http://acptek.gitee.io/blogpictures/TCPIP/ch14_ospfv2_messageformat_hello.png" alt="hello"></p><ul><li>公共头部TYPE=1</li><li>NETWORK MASK：网络地址的掩码，（发送报文的目标网络的掩码）</li><li>HELLO INTERVAL：两个邻居间发送hello的时间间隔</li><li>DEAD INTERVAL：两个路由通过hello建立了邻居关系，如果经过了DEAD INTERVAL时间后再没有hello报文的交换，则可以认为邻居已经不存在（一般是HELLO INTERVAL的4倍）</li><li>GWAY PRIO：指定自身路由器的优先级，用于选取备份指定路由器（BDR）</li><li>DR，BDR：多路访问的链路上，为了减少路由间信息量交换，则在链路上选取一个指定路由器DR和一个备份指定路由器BDR</li><li>NEOGHBOR_i IP ADDR：邻居IP地址</li></ul>        <h3 id="OSPFv2-数据库描述报文"   >          <a href="#OSPFv2-数据库描述报文" class="heading-link"><i class="fas fa-link"></i></a>OSPFv2 数据库描述报文</h3>      <p><img src="http://acptek.gitee.io/blogpictures/TCPIP/ch14_ospfv2_messageformat_dbd.png" alt="dbd"></p>        <h4 id="描述"   >          <a href="#描述" class="heading-link"><i class="fas fa-link"></i></a>描述</h4>      <p>用于初始化数据库</p><p>在报文交换时：一个作为主节点，另一个作为从节点，主节点发送一个数据库描述报文，从节点返回一个确认</p><p>如果子网拓扑数据库较大，则需要有多个数据库描述报文，才能将这些拓扑信息全部传输出去，需要用到报文中的一些特殊比特位：</p><ul><li>I = 1：表示初始报文</li><li>M = 1：本报文后还有报文</li><li>S： 1：主节点，0：从节点</li><li>SEQUENCE NUMBER：用于保证传输是否正确（初始报文选定一个初始值，之后没法送一个报文在序号上加1）</li></ul>        <h4 id="报文格式-1"   >          <a href="#报文格式-1" class="heading-link"><i class="fas fa-link"></i></a>报文格式</h4>      <ul><li>LS Type：链路状态类型</li></ul><p><img src="http://acptek.gitee.io/blogpictures/TCPIP/ch14_ospfv2_messageformat_dbd_LStype.png" alt="LStype"></p><p>路由器、网络、总结链路、外部链路</p><ul><li>INTERFACE MTU：按此长度传输IP报文，可以避免产生分片</li><li>每个链路都有 LS AGE ~ LS LENGTH来描述：<ul><li>LS AGE：链路建立好后所经过的时间</li><li>LS Type：链路类型</li><li>LINK ID：链路的标识号，一般可以设置为路由器上的某个接口的IP地址</li><li>ADVERTISING ROUTE：指发送此链路的路由器的地址</li><li>LINK SEQUENCE NUMBER：链路序号，防止报文乱序和丢失</li><li>CHECKSUM</li></ul></li></ul>        <h3 id="OSPFv2-链路状态request报文"   >          <a href="#OSPFv2-链路状态request报文" class="heading-link"><i class="fas fa-link"></i></a>OSPFv2 链路状态request报文</h3>      <p>路由器收到数据库描述报文后，发现自己本地链路有一些链路状态已经过时，此时需要通过request报文要求邻居发送自己指定的链路状态（提出链路状态请求报文，则通过update报文来响应）</p><p><img src="http://acptek.gitee.io/blogpictures/TCPIP/ch14_ospfv2_messageformat_LSrequest.png" alt="LS request"></p><p>对于每一条链路都需要这三个字段：</p><ul><li>LS Type</li><li>LINK ID</li><li>ADVERTISING ROUTER</li></ul>        <h3 id="OSPFv2-链路状态更新报文"   >          <a href="#OSPFv2-链路状态更新报文" class="heading-link"><i class="fas fa-link"></i></a>OSPFv2 链路状态更新报文</h3>      <p><img src="http://acptek.gitee.io/blogpictures/TCPIP/ch14_ospfv2_messageformat_update.png" alt="update"></p><p>分别对应的每个 LINK STATUS ADVERTIEMENT（链路状态通告） </p><p><img src="http://acptek.gitee.io/blogpictures/TCPIP/ch14_ospfv2_messageformat_update_lsa.png" alt="lsa"></p><p>在这个通告头部之后，才跟上实际的信息，这个信息取决于LS TYPE字段</p><p>LS LENGTH：LS长度包括通告首部长度（20字节）和后面的信息的长度</p>        <h2 id="9-OSPFv3"   >          <a href="#9-OSPFv3" class="heading-link"><i class="fas fa-link"></i></a>9 OSPFv3</h2>      <p>在OSPFv2基础上做了一些改动，使得可以支持IPv6。但是由于IPv6的地址较长，所以：</p><ul><li>OSPFv2 用32位IP地址来标识一个路由器，OSPFv3使用一个32位的路由ID来标识一个路由器</li></ul>        <h3 id="特点"   >          <a href="#特点" class="heading-link"><i class="fas fa-link"></i></a>特点</h3>      <ul><li>支持IPv6的路由范围：本地链路、按区域划分、按自治系统划分</li><li>可以同时运行多个OSPF进程的实例</li><li>OSPFv3移除了对报文公共首部的所有认证（交给了IPv6首部处理认证）</li><li>OSPFv3报文可以容纳IPv6地址</li><li>使用32位的ID来标识一个路由器</li></ul>        <h3 id="OSPFv3-报文格式"   >          <a href="#OSPFv3-报文格式" class="heading-link"><i class="fas fa-link"></i></a>OSPFv3 报文格式</h3>              <h4 id="固定长度的公共首部"   >          <a href="#固定长度的公共首部" class="heading-link"><i class="fas fa-link"></i></a>固定长度的公共首部</h4>      <p><img src="http://acptek.gitee.io/blogpictures/TCPIP/ch14_ospfv3_messageformat_header.png" alt="header"></p><ul><li>…… （与OSPFv2类似）</li></ul>        <h4 id="Hello-报文格式"   >          <a href="#Hello-报文格式" class="heading-link"><i class="fas fa-link"></i></a>Hello 报文格式</h4>      <p><img src="http://acptek.gitee.io/blogpictures/TCPIP/ch14_ospfv3_messageformat_hello.png" alt="hello"></p><ul><li>INTERFACE ID：接口ID，使用32位空间来标识</li><li>ROUTER PRIO：优先级</li><li>…… // 各个地址都是使用标识号而非IP地址</li></ul>        <h3 id="OSPFv3与OSPFv2比较"   >          <a href="#OSPFv3与OSPFv2比较" class="heading-link"><i class="fas fa-link"></i></a>OSPFv3与OSPFv2比较</h3>      <p>OSPFv3结合并扩展了OSPFv2的很多特性</p><p>OSPFv3根据需要定义了一些LSA（链路状态通告）的类型</p><p>OSPFv3的每个链路状态报文的首部与OSPFv2是一样的</p>        <h2 id="10-IS-IS-中间系统到中间系统路由协议"   >          <a href="#10-IS-IS-中间系统到中间系统路由协议" class="heading-link"><i class="fas fa-link"></i></a>10 IS-IS 中间系统到中间系统路由协议</h2>      <p>IS-IS属于链路状态协议</p>        <h2 id="11-Gated"   >          <a href="#11-Gated" class="heading-link"><i class="fas fa-link"></i></a>11 Gated</h2>      <p>是一个路由网关的守护进程</p><p>实现了包括RIP在内的IGP和包括BGP在内的EGP</p><ul><li>理解多种不同的路由协议，可以用于不同AS之间的信息交换</li></ul>        <h2 id="12-人工费用-Artificial-Metrics"   >          <a href="#12-人工费用-Artificial-Metrics" class="heading-link"><i class="fas fa-link"></i></a>12 人工费用 (Artificial Metrics)</h2>      <p>Metric ： 路由费用度量值</p><p>可以将原来的Metric值用人工的值进行替换，以便于控制和反映实际情况</p><p>优点：</p><ul><li>一旦网络出现故障可以自动选择另外一条路径</li><li>管理员在配制路由时只需要更改路由值Metric而非修改转发表（工作量小，便于管理）</li></ul>        <h2 id="13-采用部分信息路由"   >          <a href="#13-采用部分信息路由" class="heading-link"><i class="fas fa-link"></i></a>13 采用部分信息路由</h2>      <ul><li><p>主机节点：采用部分信息路由（可以依赖路由器进行转发）</p></li><li><p>路由器节点：并非所有路由器都使用所有信息。一些路由器可能采用部分路由信息进行路由。</p><p>核心路由器：必须包含所有信息（必须了解所有目标，不能使用默认路由）</p><p>非核心路由器：可以采用默认路由方式</p></li></ul>        <h3 id="使用默认路由的结果："   >          <a href="#使用默认路由的结果：" class="heading-link"><i class="fas fa-link"></i></a>使用默认路由的结果：</h3>      <ul><li>1 如果本地路由发生错误则无法发现（转交后有送回，路由路径仍然存在，造成很长的延迟）</li><li>2 对于一个AS内部的路由器而言，只要将内部所有已知的所有目标在路由表中列出，其余都可以通过默认路由解决，大大减少了需要传输更新的路由信息量。</li></ul><hr><p>参考资料：</p><ul><li>INTERNETWORKING WITH TCP/IP PRINCIPLES, PROTOCOLS, AND ARCHITECTURE Vol1 (6th Edition).  DOUGLASE E. COMER</li><li>Routing with TCP/IP 2nd VOL I / II , Cisco Press. (VOL I : IGP , VOL II : EGP)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Ch-14-自治系统内部路由&quot;   &gt;
          &lt;a href=&quot;#Ch-14-自治系统内部路由&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;Ch 14 自治系统内部路由&lt;/h1&gt;
      &lt;p&gt;典型的内部路由协议&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RIP，RIPng(IPv6)，OSPF，IS-IS&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="TCP/IP" scheme="https://acptek.github.io/categories/TCP-IP/"/>
    
    
      <category term="TCP/IP" scheme="https://acptek.github.io/tags/TCP-IP/"/>
    
      <category term="IGP" scheme="https://acptek.github.io/tags/IGP/"/>
    
      <category term="RIP" scheme="https://acptek.github.io/tags/RIP/"/>
    
      <category term="OSPF" scheme="https://acptek.github.io/tags/OSPF/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP 边界网关协议</title>
    <link href="https://acptek.github.io/2020/07/24/TCP-IP-%E8%BE%B9%E7%95%8C%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE/"/>
    <id>https://acptek.github.io/2020/07/24/TCP-IP-边界网关协议/</id>
    <published>2020-07-24T14:14:21.000Z</published>
    <updated>2020-07-24T14:29:12.491Z</updated>
    
    <content type="html"><![CDATA[        <h1 id="BGP-协议"   >          <a href="#BGP-协议" class="heading-link"><i class="fas fa-link"></i></a>BGP 协议</h1>      <p>在自治系统之间进行路由的协议</p><p>任何一个单一的路由协议都无法解决因特网这么大规模包含这么多路由器的这种环境下进行路由交换的路由需求。</p><p>所以需要对其进行划分成一些独立的组，称为AS。它们相互独立，由不同的管理机构来管理。</p><a id="more"></a>        <h2 id="1-路由协议"   >          <a href="#1-路由协议" class="heading-link"><i class="fas fa-link"></i></a>1  路由协议</h2>              <h3 id="路由更新协议"   >          <a href="#路由更新协议" class="heading-link"><i class="fas fa-link"></i></a>路由更新协议</h3>      <ul><li><p>在单一的主干（单一的网络）上工作</p></li><li><p>在主干核心网中工作，但是不能进行扩展</p><p>原因：随着网络站点的增加，影响路由更新协议正常工作</p><ul><li>每个路由器处理接收转发的流量会增加</li><li>同时因特网上的网络数量也会增加</li><li>这些网络由不同的机构管理，是相对独立的</li></ul></li></ul><p>在巨大的网络中使用一个单一的路由更新协议是不实际的</p>        <h3 id="将路由器分成一些独立的组"   >          <a href="#将路由器分成一些独立的组" class="heading-link"><i class="fas fa-link"></i></a>将路由器分成一些独立的组</h3>      <p>原因：</p><ul><li>考虑到流量增加问题</li><li>路由器间是间接通信的</li><li>网络和路由器非单一机构管理</li></ul>        <h3 id="组的大小限制"   >          <a href="#组的大小限制" class="heading-link"><i class="fas fa-link"></i></a>组的大小限制</h3>      <p>需要考虑的因素：</p><ul><li>交换路由信息的算法</li><li>网络容量、带宽等</li><li>路由协议的细节</li></ul><p>涉及到的两个问题：1 延迟  2 额外开销</p>        <h3 id="额外跳"   >          <a href="#额外跳" class="heading-link"><i class="fas fa-link"></i></a>额外跳</h3>      <p>访问一个网络时使用默认路由导致额外的跳数</p>        <h3 id="自治系统-AS"   >          <a href="#自治系统-AS" class="heading-link"><i class="fas fa-link"></i></a>自治系统 AS</h3>      <p>定义：由一个单一的管理机构管辖的一组网络和路由器。</p><p>内部路由器使用的路由协议：由管理机构决定</p><p>内部：路由协议由管理机构决定</p><p>区分不同AS：属于两个不同的AS的路由器间交换路由信息时，应该包含对方AS的编号</p>        <h2 id="2-外部网关协议及其可达性问题"   >          <a href="#2-外部网关协议及其可达性问题" class="heading-link"><i class="fas fa-link"></i></a>2 外部网关协议及其可达性问题</h2>              <h3 id="EGP-外部网关协议"   >          <a href="#EGP-外部网关协议" class="heading-link"><i class="fas fa-link"></i></a>EGP 外部网关协议</h3>      <p>指的是一类协议，能够在不同的自治系统中传递可达性信息的协议，使用较多的是BGP协议。</p>        <h4 id="BGP：边界网关协议"   >          <a href="#BGP：边界网关协议" class="heading-link"><i class="fas fa-link"></i></a>BGP：边界网关协议</h4>      <ul><li>目前流行使用的版本是第四版，称为BGP4</li><li>在自治系统内部包含很多路由器，从中选出一个作为边界路由器。两个自治系统的边界路由器之间交换路由信息时，使用BGP</li></ul>        <h3 id="BGP-边界网关协议"   >          <a href="#BGP-边界网关协议" class="heading-link"><i class="fas fa-link"></i></a>BGP 边界网关协议</h3>      <p>只是用于传递网络可达性，而非作为路由信息来进行传递</p>        <h4 id="特性"   >          <a href="#特性" class="heading-link"><i class="fas fa-link"></i></a>特性</h4>      <ul><li>用于AS与AS之间的通信</li><li>IBGP：内部BGP，对于特定的AS有多个边界路由器，IBGP保证通过不同的边界路由器传播出去的本地AS路由信息一致（协调内部信息）</li><li>能向外传播可达性的消息（包括中间AS作为转发等）</li><li>下一跳方式进行每个目标通告</li><li><strong>BGP支持策略路由</strong></li><li>使用可靠传输服务</li><li>以增量方式更新（只发送新的路由信息，节约带宽）</li><li>支持无类别的寻址方案</li><li>路由汇聚（多条路由压缩成一条）</li><li>认证身份</li></ul>        <h4 id="功能："   >          <a href="#功能：" class="heading-link"><i class="fas fa-link"></i></a>功能：</h4>      <ul><li>能够进行邻居（对等方 peer）发现与邻居之间连接创建</li><li>任何一方可以向另一方发送正向（可达的合法目标）或负向（先前公布的目标已失效）的可达性信息（使用UPDATE）</li><li>在维持的过程中不断进行验证，确保连接 （使用KEEPALIVE）</li></ul>        <h4 id="报文类型"   >          <a href="#报文类型" class="heading-link"><i class="fas fa-link"></i></a>报文类型</h4>      <p><img src="http://acptek.gitee.io/blogpictures/TCPIP/Ch13_BGP_Message_Type.png" alt="BGP报文格式"></p><ul><li>OPEN：双方建立连接</li><li>UPDATE：路由信息更新报文</li><li>NOTIFICATION：进行差错处理（例如拆除连接）</li><li>KEEPALIVE：不断验证保证连接</li><li>REFRESH：动态向对方申请相应路由信息</li></ul>        <h4 id="BGP报文首部"   >          <a href="#BGP报文首部" class="heading-link"><i class="fas fa-link"></i></a>BGP报文首部</h4>      <p><img src="http://acptek.gitee.io/blogpictures/TCPIP/Ch13_BGP_Message_Header.png" alt="BGP报文首部"></p><ul><li>3个固定长度字段，19个字节</li></ul><p>字段：</p><ul><li>MARKER：用于定界，表示报文的开始与结束的位置</li><li>LENGTH：表示整个报文的长度，最大长度为4096字节</li><li>TYPE：报文类型</li></ul>        <h4 id="BGP-OPEN报文"   >          <a href="#BGP-OPEN报文" class="heading-link"><i class="fas fa-link"></i></a>BGP OPEN报文</h4>      <p>用于创建BGP对等体之间的连接</p><p><img src="http://acptek.gitee.io/blogpictures/TCPIP/Ch13_BGP_OPEN_Message.png" alt="BGP OPEN报文"></p><ul><li><p>HOLD TIME</p><p>一对BGP peers之间连接的有效期，时钟超时间隔，超时终止（接收方两个连续的报文的最大时间间隔）</p><p>将HOLD TIME的值设为0，表示双方不进程保持连接的交换，则不需要KEEPALIVE报文</p><p>KEEPALIVE的时间间隔是hold timer的1/3，KEEPALIVE是以秒为单位的，所以hold timer的值不少于3</p><p>s</p></li><li><p>BGP IDENTIFIER</p><p>用于唯一区分一个AS的编号：一般使用IP地址进行标识（多接口路由器从则中选取一个作为ID）</p></li><li><p>Optional Parameter</p><p>可选参数</p></li><li><p>收到OPEN报文，则以KEEPALIVE报文进行响应</p></li></ul>        <h4 id="BGP-UPDATE报文"   >          <a href="#BGP-UPDATE报文" class="heading-link"><i class="fas fa-link"></i></a>BGP UPDATE报文</h4>      <p>由于连接建立后的数据交换</p><p>传递的信息：</p><ul><li>可达的新的目标</li><li>需要撤销的原来的现在不可用的目标</li></ul><p><img src="http://acptek.gitee.io/blogpictures/TCPIP/Ch13_BGP_UPDATE.png" alt="BGP UPDATE报文"></p><ul><li><p>WITHDRAWN：需要撤销的现在非法的老的目标</p></li><li><p>PATH ATTR：路径属性</p><p>新的目标前都带有<strong>公共的</strong>路径属性。所以路径属性不一样时需要发多个UPDATE报文。</p></li></ul>        <h4 id="BGP-KEEPALIVE报文"   >          <a href="#BGP-KEEPALIVE报文" class="heading-link"><i class="fas fa-link"></i></a>BGP KEEPALIVE报文</h4>      <ul><li><p>作为连接创建的确认，作为连接维持的报文</p></li><li><p>报文后不带数据，只包含报文首部：19字节</p></li><li><p>使用的理由：</p><p>1 BGP使用TCP传输服务</p><p>2 考虑节约带宽：报文中不带有数据，报文长度最短，有利于保持连接的传输</p></li><li><p>KEEPALIVE的时间间隔是hold timer的1/3</p></li></ul>        <h4 id="BGP-Notification报文"   >          <a href="#BGP-Notification报文" class="heading-link"><i class="fas fa-link"></i></a>BGP Notification报文</h4>      <p>主要是用于差错处理</p><p>一旦发生错误，发送Notification报文关闭TCP连接</p><p><strong>报文格式：</strong></p><p><img src="http://acptek.gitee.io/blogpictures/TCPIP/Ch13_BGP_Notification_Message.png" alt="Notification报文格式"></p><p><strong>错误码：</strong></p><p><img src="http://acptek.gitee.io/blogpictures/TCPIP/Ch13_BGP_Notification_Message_Code.png" alt="Notification报文错误码"></p><ul><li>1：报文首部出错</li><li>2：OPEN报文出错</li><li>3：UPDATE报文出错</li><li>4：Hold timer超时</li><li>5：有限状态机出错</li><li>6：拆除连接</li></ul><p><strong>子类型错误码：</strong></p><p><img src="http://acptek.gitee.io/blogpictures/TCPIP/Ch13_BGP_Notification_Message_Subcode.png" alt="子类型错误码"></p>        <h4 id="BGP-Refresh报文"   >          <a href="#BGP-Refresh报文" class="heading-link"><i class="fas fa-link"></i></a>BGP Refresh报文</h4>      <ul><li>Marker，Length，Type</li><li>Address family identifier</li><li>Reserved</li><li>Subsequent address family identifier</li></ul>        <h3 id="BGP-压缩形式掩码地址对"   >          <a href="#BGP-压缩形式掩码地址对" class="heading-link"><i class="fas fa-link"></i></a>BGP 压缩形式掩码地址对</h3>      <p>适应于无类别的寻址方案</p><p>传输方式：采用LENGTH-PREFIX方法：</p><p><img src="http://acptek.gitee.io/blogpictures/TCPIP/Ch13_BGP_LENGTH-PREFIX.png" alt="BFP压缩定时掩码"></p><ul><li>LEN：掩码长度</li><li>PREFIX：长度可变，根据LEN的值来确定长度</li></ul><p>当LEN为零时，表示默认路由</p>        <h2 id="3-BGP-路径属性"   >          <a href="#3-BGP-路径属性" class="heading-link"><i class="fas fa-link"></i></a>3 BGP 路径属性</h2>              <h3 id="路径属性信息"   >          <a href="#路径属性信息" class="heading-link"><i class="fas fa-link"></i></a>路径属性信息</h3>      <p>通过路径属性可以提供额外的属性，比简单的DV包含更多信息，包括</p><ul><li>Next hop</li><li>从本地到达目标的某个路径（路径上每个自治系统的编号）</li><li>可以得知路径的来源（来源于EGP还是IGP）</li></ul><p>BGP路径属性在UPDATE报文格式出现，在attributes后面跟了多个目标（一对多的关系）。这些attributes是后面这些目标公用的，目标的attributes不一样那么必须要分多个UPDATE报文进行通告。</p>        <h3 id="使用路径属性的理由"   >          <a href="#使用路径属性的理由" class="heading-link"><i class="fas fa-link"></i></a>使用路径属性的理由</h3>      <ul><li>可以检测到路径中是否包含回路：列出了路径上所有的AS号，若其中有两个号码相同则存在回路</li><li>可以帮助接收方实现策略上的约束</li><li>可以使得接收方了解到所有路由信息中每一条路由的源（路径是EGP还是IGP获取的）</li></ul>        <h3 id="路径属性包含的内容"   >          <a href="#路径属性包含的内容" class="heading-link"><i class="fas fa-link"></i></a>路径属性包含的内容</h3>      <p>包含了如下结构的列表</p><p><code>(type, length, value)</code></p><ul><li>type：2字节</li><li>length：1~2字节（取决于type中的一个标志）</li><li>value：总的表项的值由value来确定</li></ul>        <h4 id="type字段"   >          <a href="#type字段" class="heading-link"><i class="fas fa-link"></i></a>type字段</h4>      <p><strong>标志位</strong></p><p><img src="http://acptek.gitee.io/blogpictures/TCPIP/Ch13_Path_Attribute_type.png" alt="type标志位"></p><ul><li>0：属性是否必须</li><li>1：属性是否可以转发</li><li>2：属性是否完整</li><li>3：属性长度length字段的字节数</li><li>5-7：未使用，置零</li></ul><p><strong>type值</strong></p><p><img src="http://acptek.gitee.io/blogpictures/TCPIP/Ch13_Path_Attribute_type_value.png" alt="type值"></p><ul><li>1：指出路径信息的源</li><li>2：到达目标路径上的AS列表</li><li>3：到达目标的下一跳</li><li>4：MED：自治系统包含多个边界路由器，告知其中较优的</li><li>5：本地AS有多个出口，告知其中较优的</li><li>6：表示路由汇聚</li><li>7：路由汇聚的自治系统的ID</li><li>8：通告目标的共有ID</li></ul>        <h3 id="6-BGP-多协议扩展（MBGP）"   >          <a href="#6-BGP-多协议扩展（MBGP）" class="heading-link"><i class="fas fa-link"></i></a>6 BGP 多协议扩展（MBGP）</h3>              <h4 id="扩展中的属性"   >          <a href="#扩展中的属性" class="heading-link"><i class="fas fa-link"></i></a>扩展中的属性</h4>      <ul><li>可选属性</li><li>不能转发</li></ul>        <h4 id="两种扩展属性的Type"   >          <a href="#两种扩展属性的Type" class="heading-link"><i class="fas fa-link"></i></a>两种扩展属性的Type</h4>      <p>（放在BGP Path Attributes中传输）</p><p>NLRI（type14）可达 - 网络层可达信息</p><p><img src="http://acptek.gitee.io/blogpictures/TCPIP/Ch13_NLRI-type14.png" alt="可达性额扩展属性"></p><ul><li>SNPA：子网协议地址（具体的每一个目标，到达这些目标都是通过Next Hop到达）</li></ul><p>NLRI（type15）不可达</p>        <h2 id="4-BGP存在的问题"   >          <a href="#4-BGP存在的问题" class="heading-link"><i class="fas fa-link"></i></a>4 BGP存在的问题</h2>      <ul><li>BGP不能同时使用到达一个目标的多条路径，对于某个可达的目标网络路径中只能选择一个</li><li>BGP不支持自治系统间的负载均衡（这只能将一个AS拆成多个）</li><li>针对广域网环境很难做出最优的路由（需要通过管理人工设置）</li><li>在通告可达性的时候所有自治系统需要一致同意这个方案，BGP很难保证全球一致性</li></ul>        <h2 id="5-因特网路由的体系结构与注册的数据库"   >          <a href="#5-因特网路由的体系结构与注册的数据库" class="heading-link"><i class="fas fa-link"></i></a>5 因特网路由的体系结构与注册的数据库</h2>      <p>目标：保证路由信息的全球一致性</p>        <h3 id="当前因特网路由的体系结构"   >          <a href="#当前因特网路由的体系结构" class="heading-link"><i class="fas fa-link"></i></a>当前因特网路由的体系结构</h3>      <ul><li><p>大的服务商连到NAP（网络访问点）上，通过NAP来接入到因特网。</p><p>NAP也成为IXP（因特网交换节点）。</p></li><li><p>通过NAP相连，不同的因特网服务商通过相互之间建立的对等关系来交换路由信息。</p><p>不同的服务商之间的关系：上下游关系，中间转发关系</p></li><li><p><strong>采用路由注册数据库服务</strong></p><p>（使用局部数据库）</p><p>但是会出现“黑洞”现象：通告了不可达的地址</p></li></ul><hr><p>参考资料：</p><ul><li>INTERNETWORKING WITH TCP/IP PRINCIPLES, PROTOCOLS, AND ARCHITECTURE Vol1 (6th Edition).  DOUGLASE E. COMER </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;BGP-协议&quot;   &gt;
          &lt;a href=&quot;#BGP-协议&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;BGP 协议&lt;/h1&gt;
      &lt;p&gt;在自治系统之间进行路由的协议&lt;/p&gt;
&lt;p&gt;任何一个单一的路由协议都无法解决因特网这么大规模包含这么多路由器的这种环境下进行路由交换的路由需求。&lt;/p&gt;
&lt;p&gt;所以需要对其进行划分成一些独立的组，称为AS。它们相互独立，由不同的管理机构来管理。&lt;/p&gt;
    
    </summary>
    
      <category term="TCP/IP" scheme="https://acptek.github.io/categories/TCP-IP/"/>
    
    
      <category term="TCP/IP" scheme="https://acptek.github.io/tags/TCP-IP/"/>
    
      <category term="BGP" scheme="https://acptek.github.io/tags/BGP/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP 路由选择，核心网，对等网和相关路由算法</title>
    <link href="https://acptek.github.io/2020/07/20/TCP-IP-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%EF%BC%8C%E6%A0%B8%E5%BF%83%E7%BD%91%EF%BC%8C%E5%AF%B9%E7%AD%89%E7%BD%91%E5%92%8C%E7%9B%B8%E5%85%B3%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95/"/>
    <id>https://acptek.github.io/2020/07/20/TCP-IP-路由选择，核心网，对等网和相关路由算法/</id>
    <published>2020-07-20T11:08:10.000Z</published>
    <updated>2020-07-24T14:32:17.388Z</updated>
    
    <content type="html"><![CDATA[        <h1 id="路由选择，核心网，对等网和相关路由算法"   >          <a href="#路由选择，核心网，对等网和相关路由算法" class="heading-link"><i class="fas fa-link"></i></a>路由选择，核心网，对等网和相关路由算法</h1>      <ul><li>路由表（转发表）包含的内容</li><li>路由表中内容的获取</li></ul><a id="more"></a>        <h2 id="转发表的来源"   >          <a href="#转发表的来源" class="heading-link"><i class="fas fa-link"></i></a>转发表的来源</h2>      <p>在OS启动过程中，获取初始化表项</p><p>更新过程：<br>    第一个表项：目标在本地网络直接转发<br>    第二个表项：默认路由<br>    路由器也可以使用默认路由</p>        <h2 id="使用部分信息进行转发"   >          <a href="#使用部分信息进行转发" class="heading-link"><i class="fas fa-link"></i></a>使用部分信息进行转发</h2>      <ul><li><p>主机：可以使用（相比路由器对网络的了解要少很多，可以依赖路由器）</p><p>极限情况下只有两个表项（两条路径）：一条路由对应接口所连接的网络（本地网络），另一个是默认路由</p></li><li><p>路由器：也可以使用默认路由。一般包含对网络完整的了解</p></li></ul><p>1 全局星型拓扑：适用于小型网络，不适用于类似因特网的大型网络</p><p>2 所有交汇点列出全部网络信息：路由器间信息交换量过大</p><p>3 分半：方案可行</p>        <h2 id="原始的因特网路由架构"   >          <a href="#原始的因特网路由架构" class="heading-link"><i class="fas fa-link"></i></a>原始的因特网路由架构</h2>      <p>因特网最早建立在ARPANET的主干上，随着网络规模增加，手工配制方式不可行</p><p>ARPANET到达一定规模后的路由架构：（核心与非核心路由器）</p><p>​    核心是一些中心路由器，剩余大部分属于外围路由器。中心主干网的路由器较少，所以他们将主干网上的所有路由信息列进路由表。外围路由器连到核心网中，向核心网路由器提供一些部分路由信息（默认路由）</p><ul><li>优点：外围网络变化不影响其他网络</li><li>缺点：会造成不一致性</li></ul><p>核心路由器不能采取部分信息进行路由：会出现低效的情况（甚至形成环路）。所以要求核心路由器之间必须相互交换完整的路由信息。</p>        <h2 id="核心路由结构发展为对等网路由结构"   >          <a href="#核心路由结构发展为对等网路由结构" class="heading-link"><i class="fas fa-link"></i></a>核心路由结构发展为对等网路由结构</h2>      <p>NSFNET作为主干加到原来ARPANET的主干上<br>    加入的方法：开始网络规模不大，通过一个核心路由器的方式加入，要求核心的路由器有明确的表项明确指向NSFNET中的所有目标，对于非NSFNET的目标通过默认路由到达。随着NSFNET规模增加后，变成了多个路由相连，发展成了对等网路由的结构。</p><ul><li>出现问题：存在多条路由路径。</li><li>需要对全局网络达成一致的协议，避免路由回路问题</li></ul>        <h2 id="路径（路由信息）传播"   >          <a href="#路径（路由信息）传播" class="heading-link"><i class="fas fa-link"></i></a>路径（路由信息）传播</h2>      <p>路由协议算法</p>        <h3 id="路由协议两个功能"   >          <a href="#路由协议两个功能" class="heading-link"><i class="fas fa-link"></i></a>路由协议两个功能</h3>      <ul><li>1 计算最短路径：是一个路径的集合（不止一条，有多条</li><li>2 若网络中发生路由节点变化，需要对网络拓扑进行更新（动态的方式</li></ul><p>路由协议独立于路由器的转发机制：路由器转发时依据转发表进行转发<br>路由协议：目的是 产生/更新 转发表</p>        <h3 id="区分-转发表-与-FIB（转发信息库）"   >          <a href="#区分-转发表-与-FIB（转发信息库）" class="heading-link"><i class="fas fa-link"></i></a>区分 转发表 与 FIB（转发信息库）</h3>      <p>FIB，FIB是转发信息库。转发表从FIB获取信息，路由算法会从FIB中选取合适的内容添加到转发表当中去<br>路由策略：人为设置一些添加的条件</p>        <h2 id="路由算法"   >          <a href="#路由算法" class="heading-link"><i class="fas fa-link"></i></a>路由算法</h2>              <h3 id="DV：距离矢量路由-BellmanFord"   >          <a href="#DV：距离矢量路由-BellmanFord" class="heading-link"><i class="fas fa-link"></i></a>DV：距离矢量路由(BellmanFord)</h3>      <ul><li>本地路由器在本地FIB列出一些一致的路径（到达某些目标一致的表项）</li><li>表项在初始化的时候包含直接相邻的网</li><li>更新消息：邻居路由节点之间周期性交换路由表（将FIB发送给邻居节点）</li><li>更新本地路由表：1 选择到达目标的路径更短 ，2 新表项加入 ， 3 路径变化</li></ul><p><strong>不适用于网络规模扩大：更新消息内容与网络规模有关</strong></p>        <h3 id="LS：SPF路由（最短路优先）"   >          <a href="#LS：SPF路由（最短路优先）" class="heading-link"><i class="fas fa-link"></i></a>LS：SPF路由（最短路优先）</h3>      <p>需要网络中的路由需要对整个网络拓扑有一个完整的了解</p><p>任务：</p><ul><li>1 检测邻居的活动 </li><li>2 将了解到的路由状态信息告诉其他路由器：采用洪泛（只告知状态信息而非路径信息）</li></ul><p>若链路状态发生变化，更新消息</p>        <h2 id="路由协议的可靠性"   >          <a href="#路由协议的可靠性" class="heading-link"><i class="fas fa-link"></i></a>路由协议的可靠性</h2>      <p>封装在IP层协议 -&gt; 封装在传输层协议进行传输</p><p>如果采用不可靠传输协议出现差错，需要路由协议本身解决：</p><p>​    解决方法：1 对传输的报文进行校验  2 软状态方法（带有重传的肯定确认方法） 3 序号编号</p><hr><p>参考资料：</p><ul><li>INTERNETWORKING WITH TCP/IP PRINCIPLES, PROTOCOLS, AND ARCHITECTURE Vol1 (6th Edition).  DOUGLASE E. COMER </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;路由选择，核心网，对等网和相关路由算法&quot;   &gt;
          &lt;a href=&quot;#路由选择，核心网，对等网和相关路由算法&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;路由选择，核心网，对等网和相关路由算法&lt;/h1&gt;
      &lt;ul&gt;
&lt;li&gt;路由表（转发表）包含的内容&lt;/li&gt;
&lt;li&gt;路由表中内容的获取&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="TCP/IP" scheme="https://acptek.github.io/categories/TCP-IP/"/>
    
    
      <category term="TCP/IP" scheme="https://acptek.github.io/tags/TCP-IP/"/>
    
      <category term="路由算法" scheme="https://acptek.github.io/tags/%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP 传输控制报文协议</title>
    <link href="https://acptek.github.io/2020/07/10/TCP-IP-%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E6%8A%A5%E6%96%87%E5%8D%8F%E8%AE%AE/"/>
    <id>https://acptek.github.io/2020/07/10/TCP-IP-传输控制报文协议/</id>
    <published>2020-07-10T08:05:56.000Z</published>
    <updated>2020-07-20T11:06:19.494Z</updated>
    
    <content type="html"><![CDATA[        <h2 id="TCP-可靠的流传输服务"   >          <a href="#TCP-可靠的流传输服务" class="heading-link"><i class="fas fa-link"></i></a>TCP 可靠的流传输服务</h2>              <h2 id="概述"   >          <a href="#概述" class="heading-link"><i class="fas fa-link"></i></a>概述</h2>      <p>传输控制协议，字节流服务<br>适用于其他不同类型的网络传递服务</p><a id="more"></a>        <h2 id="可靠传输的特性"   >          <a href="#可靠传输的特性" class="heading-link"><i class="fas fa-link"></i></a>可靠传输的特性</h2>      <p>1 面向流的服务（比特流、字节流）<br>2 采用虚电路方式（逻辑连接，面向连接的传输服务）<br>3 通过缓存技术传输（考虑到传输的效率）<br>    Push机制：设置后不会放在缓存中，数据立即发出（不放到发送缓冲区），直接向应用递交（不放到接收缓冲区）<br>4 非结构的流（不是以记录为单位的流服务）<br>5 提供全双工的通信方式，每个方向相对独立（首部有两个序号：发送序号和接收序号）<br>    确认：采用 捎带（piggybacked）技术，把确认放在发给对方的数据报文当中，进行确认。目的是提高传输效率。</p>        <h2 id="提高可靠性的方法"   >          <a href="#提高可靠性的方法" class="heading-link"><i class="fas fa-link"></i></a>提高可靠性的方法</h2>      <ul><li>带有重传的肯定确认<br>接收方收到数据时给出肯定确认，发送方对于每一个发送出去的数据报文都启动一个定时器（时钟）来跟踪发送的报文（跟踪对其的确认），一旦超时则重传</li></ul>        <h2 id="超时和重传"   >          <a href="#超时和重传" class="heading-link"><i class="fas fa-link"></i></a>超时和重传</h2>      <p>接收方收到的报文可能重复，涉及设置超时的间隔的问题。如果超时间隔设置的过小，会产生过早超时问题，带来重复接收的问题。<br>判定重复方法：在报文首部增加序号字段，每个报文给一个不同的序号，向发送方返回的确认也可以带上序号。</p>        <h2 id="滑动窗口"   >          <a href="#滑动窗口" class="heading-link"><i class="fas fa-link"></i></a>滑动窗口</h2>      <p>对比停等：提高带宽的利用率，发送方可以连续发送多个数据报（窗口取值大于1<br>窗口（未确认的包数）的最大值不能超过序号空间（序号空间的大小，取决于包首部序号值的位数）<br>    如果超过序号空间，则未确认的包中至少有两个包的序号是相同的，接收方无法做区分</p><blockquote><p>分组首部包含kbit的序列号，序号空间为2^k<br>针对 回退N协议：窗口大小不能超过序号空间<br>针对 选择重传协议：窗口大小不能超过序号空间大小的一半</p></blockquote><p>接收方也存在一个窗口，与发送方相对应也是一个滑动窗口</p>        <h2 id="TCP协议"   >          <a href="#TCP协议" class="heading-link"><i class="fas fa-link"></i></a>TCP协议</h2>      <p>TCP标准包含：</p><ul><li>数据报和确认格式</li><li>过程可靠</li><li>区分主机上的多个不同目标</li><li>差错恢复</li><li>进行连接的管理（连接的初始化，关闭等）</li></ul><p>TCP不包括：</p><ul><li>没有定义与应用之间的细节</li><li>对于底层网络没有特殊要求</li></ul>        <h2 id="分层"   >          <a href="#分层" class="heading-link"><i class="fas fa-link"></i></a>分层</h2>      <p>属于传输层<br>TCP提供面向连接的虚电路服务（字节流服务<br>使用TCP服务，多个应用可以进行同时的通信。此处多路复用与解多路复用的依据是端口号</p>        <h2 id="段，流和序列号"   >          <a href="#段，流和序列号" class="heading-link"><i class="fas fa-link"></i></a>段，流和序列号</h2>      <ul><li>TCP的传输单位：段</li><li>TCP提供一种流的服务，数据流包含在段内进行传输</li><li>TCP段 封装在 IP分组的数据区</li></ul><p>需要考虑的问题：<br>1 如何提高传输效率？<br>2 如何流量控制？（因特网中不同主机的收发速度、主机间的通信路径负荷等因素）</p><p>解决方案：滑动窗口协议</p><p>TCP滑动窗口中，窗口的大小在不断变化，接收方需要告诉发送方<br>通过窗口通告方式：接收方发送确认来告诉发送方（确认包中有一个窗口通告值，表示当前窗口剩余大小）<br>从而实现流量控制。</p><p>在TCP的改进方案中有显示拥塞控制机制。</p>        <h2 id="TCP-段格式"   >          <a href="#TCP-段格式" class="heading-link"><i class="fas fa-link"></i></a>TCP 段格式</h2>      <ul><li>传输的数据单位是 段</li><li>作用：创建连接、传输数据段、进行确认、通告本地窗口大小等<br>（很多不同类型的段来完成不容类型的功能）</li></ul>        <h3 id="段格式："   >          <a href="#段格式：" class="heading-link"><i class="fas fa-link"></i></a>段格式：</h3>      <p><img src="http://acptek.gitee.io/blogpictures/TCPIP/Ch11_TCP_SegmentFormat.png" alt="TCP段格式"></p><ul><li>源端口</li><li>目的端口</li><li>(seq)序号 32bit：发送序号</li><li>(ack)确认号 32bit：接收序号</li><li>HLEN 4bit：TCP段的首部长度，是以字节为单位</li><li>保留 6bit</li><li>Code Bits：TCP标志 6bit，表示TCP段的类型</li><li>WINDOW：16bit，向发送方通告本地接收缓冲区的大小</li><li>报文校验和 16bit</li><li>紧急指针 16bit -&gt; 联合code bits中urgent标志使用</li><li>选项 20bit   Padding填充</li><li>数据</li></ul>        <h4 id="Code-Bits字段"   >          <a href="#Code-Bits字段" class="heading-link"><i class="fas fa-link"></i></a>Code Bits字段</h4>      <p>URG：紧急指针<br>ACK：确认<br>PSH：带有PUSH标志的段要求不能进行缓存处理<br>RST：立即拆除原来建立的一条连接<br>SYN：创建连接并进行序号的同步（发送方接收方之间建立连接时，选择自己的初始序号并告诉对方<br>FIN：指双方在传输完毕数据后双方切断连接</p>        <h4 id="Out-of-Band-Data（带外数据）"   >          <a href="#Out-of-Band-Data（带外数据）" class="heading-link"><i class="fas fa-link"></i></a>Out of Band Data（带外数据）</h4>      <p>普通数据的传输占用了一条连接，控制数据优先级高于普通数据，这些控制数据不收流量约束机制的限制<br>（实际上是TCP中带内数据：可以在普通数据中加入一些控制数据，夹杂在普通数据流里，但是会优先处理）</p>        <h4 id="选项字段"   >          <a href="#选项字段" class="heading-link"><i class="fas fa-link"></i></a>选项字段</h4>      <ul><li><p>格式：kind（1字节）+ length（1字节）+info（可变字节），长度可变</p></li><li><p>MSS：最大报文段长度。TCP中最初规定的一种选项，kind=2</p><p>MSS告诉对方TCP：本方能接收的报文段的数据字段的最大长度是MSS个字节</p><p>MSS与链路层MTU相关</p></li><li><p>一些其他选项：</p><ul><li>Windows Scale：kind=3，对TCP首部的Window的扩充（针对于网络延迟长但是带宽高的网络，需要提高窗口值）</li><li>TimeStamp：kind=8，时间戳，计算RTT等、当序号到达最大值时翻转为0时提供时间戳可以序号进行大小的判断</li><li>SACK：kind=5，可以进行选择性的确认，通过SACK支出接收块中缺少了哪些</li><li>……</li></ul></li></ul>        <h4 id="TCP-Checksum字段"   >          <a href="#TCP-Checksum字段" class="heading-link"><i class="fas fa-link"></i></a>TCP Checksum字段</h4>      <ul><li><p>算法：将被校验的序列看成16位的整数序列，求这个序列反码和的反码</p></li><li><p>计算的时候需要使用伪头（与UDP相同）</p><p>IPv4的TCP伪首部格式：</p><p><img src="http://acptek.gitee.io/blogpictures/TCPIP/Ch11_IPv4TCP_PseudoHeaderFormat.png" alt="IPv4 TCP伪首部格式"></p><p>与UDP的伪首部的区别在于协议号，TCP报文长度字段不同。</p><p>同样，IPv6的TCP伪首部格式：</p><p><img src="http://acptek.gitee.io/blogpictures/TCPIP/Ch11_IPv6TCP_PseudoHeaderFormat.png" alt="IPv6 TCP伪首部格式"></p></li></ul>        <h2 id="ACK"   >          <a href="#ACK" class="heading-link"><i class="fas fa-link"></i></a>ACK</h2>      <ul><li>TCP中不以段为单位进行编号，以字节为单位进行编号<br>1 因为每个段所带的数据长度不一样；在重传时，所带数据比原来的段还要多一些。若以段为单位进行编号，此时就很难去区分数据长度的不同。<br>2 所以针对字节流，TCP设定字节流起始位置。所以，TCP中的序号是对于数据流中的每个字节编号。</li><li>确认的序号：所收到段的最后数据字节的序号。在实际给确认值时，还需要在其基础上加一，表示下一次期待的段的号码。</li><li>积累方式的确认：当前号接收正确，当前号之前的也都接收正确</li><li>接收对于接收到的段还需要进行重新排序后，再递交给上层的应用</li><li>接收方给的确认：收到连续字节流中最后那个字节的序号</li></ul><p>(如果发送方发送五个段，接收方只接收到了后面四个，那么接收方还是返回第一个段的起始位置。发送方接下来重新发送全部五个段，或者停止发送等待接收方返回的确认。这会造成效率低下的问题。)</p>        <h2 id="超时和重传-1"   >          <a href="#超时和重传-1" class="heading-link"><i class="fas fa-link"></i></a>超时和重传</h2>      <p>TCP每发送一个段就启用一个时钟跟踪，如果超时前时钟确认未收到则重新发送<br>由于因特网中有很多异构的网络，在这些网络上的网络延迟不相同，所以对超时时间的设置算法需要有自适应的能力</p><p>设定超时重传依据RTT<br>    RTT样本采用样本估算方法<br>采用加权平均方法：<br>    RTT = (a<em>RTT原来的数值)+((1-a) </em> 新的RTT样本)<br>设置超时时间<br>    Timeout = B * RTT （其中B为大于1的常数）</p>        <h3 id="样本估算"   >          <a href="#样本估算" class="heading-link"><i class="fas fa-link"></i></a>样本估算</h3>      <p>Karn算法</p><ul><li><p>对重传的样本不做统计</p><p>但是在初始时都是重传样本，此时RTT就一直得不到调整，那么时钟就可能一直超时产生持续的重传，所以此时采用时钟退避。</p></li><li><p>时钟的退避<br>若样本是重传样本，则对Timeout做调整（例如，乘以2）</p></li></ul>        <h2 id="网络延迟的方差问题"   >          <a href="#网络延迟的方差问题" class="heading-link"><i class="fas fa-link"></i></a>网络延迟的方差问题</h2>      <p>网络延迟的方差指的是网络延迟的变化率。<br>方差大则出现抖动，使用方差替代常量调整RTT</p><ul><li>RTT的变化<br>往返延迟的方差与 1/(1-L) 成比例，L是当前网络负载</li><li>最初TCP标准估算平均RTT的方法<br>设置 B 为2，此时网络负载最多到达30%</li><li>之后标准采用一个方差来替代 原来的常量B</li></ul><p>对超时时钟间隔的设置：</p><p>DIFF= SAMPLE- Old RTT<br>Smoothed RTT= Old RTT + δ <em> DIFF<br>DEV= Old_DEV +ρ (|DIFF| - Old_DEV)<br>Timeout = Smoothed RTT + η </em> DEV</p><p>DIFF：样本和旧的RTT间的差异<br>DEV：平均偏差<br>δ：在0-1之间，对加权平均值Smooth RTT进行控制<br>ρ：在0-1之间，对偏差DEV进行控制<br>η：控制平均方差DEV对Timeout的影响</p>        <h2 id="拥塞处理"   >          <a href="#拥塞处理" class="heading-link"><i class="fas fa-link"></i></a>拥塞处理</h2>      <p>造成重传，增加延迟，甚至出现拥塞崩溃</p>        <h3 id="解决方案"   >          <a href="#解决方案" class="heading-link"><i class="fas fa-link"></i></a>解决方案</h3>      <p>降低传输速率</p><p>(过时）ICMP中source quench报文通知主机出现网络拥塞，让源站减缓发送过程</p>        <h3 id="TCP处理方法-AIMD"   >          <a href="#TCP处理方法-AIMD" class="heading-link"><i class="fas fa-link"></i></a>TCP处理方法 (AIMD)</h3>      <ul><li>乘法减（muldec）：以乘上一个系数的方式来减少，一般情况下减半<br>接收方窗口大小：在收到报文后返回的确认中通告给发送方<br>拥塞窗口：在发生拥塞状况的时候引入的窗口值，此时发送方发送的数据要有接收窗口大小和拥塞窗口大小来决定。发送方一般做法是取这两个窗口值的小的。<br>TCP判断拥塞的方式：检测到丢包情况。<br>（可能会出现震荡现象）</li><li>慢启动<br>发送拥塞，将窗口降为1，之后不断增加2的倍数段<br>如果窗口值到达最初设定的窗口值的一半，此时进入<strong>拥塞避免</strong>阶段（在所有段的确认都收回时，窗口值加一）</li></ul>        <h3 id="TCP-快速恢复"   >          <a href="#TCP-快速恢复" class="heading-link"><i class="fas fa-link"></i></a>TCP 快速恢复</h3>              <h4 id="Fast-recovery：快速恢复"   >          <a href="#Fast-recovery：快速恢复" class="heading-link"><i class="fas fa-link"></i></a>Fast recovery：快速恢复</h4>      <p>如果丢包现象不是经常发生，则可以采用启发式的测略</p><p>如果接收方收到三次重复的确认，则启动快速恢复。（此时往往比超时重传快）</p><p>快重传不同版本：</p><ul><li><p>Tahoe：</p><p>传统的处理，AIMD</p></li><li><p>Reno：</p><p>窗口中丢失了一个报文段的情况</p></li><li><p>NewReno：</p><p>相比Reno处理一个报文的丢失，NewReno可以处理两个报文的丢失。</p><p>两个段丢失时，确认返回有两种情况：</p><p>​    1 如果确认在窗口尾部的号码时，表示只丢失了一个段</p><p>​    2 如果确认的序号比丢失的号码大但是比窗口尾部的号码小，表示丢失了第二个段    </p></li><li><p>Vegas：用平均估算RTT的值来替代丢包的情况</p></li></ul>        <h3 id="TCP显示反馈机制"   >          <a href="#TCP显示反馈机制" class="heading-link"><i class="fas fa-link"></i></a>TCP显示反馈机制</h3>      <p>标准TCP协议中没有显示的拥塞反馈机制</p>        <h4 id="TCP中两个相关的技术："   >          <a href="#TCP中两个相关的技术：" class="heading-link"><i class="fas fa-link"></i></a>TCP中两个相关的技术：</h4>      <ul><li><p>SACK选项：选择确认<br>​接收方收到发送方发来的不连续的段，SACK选项说明从一个序号到另一个序号的段已经收到了，发送方只重传空缺的数据。</p></li><li><p>ECN：显示拥塞通告，直接显示反馈</p><p>采用ECN测略需要修改TCP协议和IP协议</p><p>（利用协议首部未定义的字段）</p><p>在IP协议首部的TOS字段中，最低的两位被定义成ECN</p><p>在TCP协议首部的保留字段中，使用其中的两个bit，一个bit是CWR位：表示发送方的拥塞窗口减少了，另一个bit是ECE位：显示拥塞通告</p></li></ul><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ECN扩展功能表述</span><br><span class="line">主机A向主机B发送报文。在中间路径的路由器上发生拥塞。IP分组达路由器后，路由器将分组首部的TOS字段中的ECN两位都置为1，然后转发出去。在主机B收到这个报文后，发现链路上发生拥塞，此时向主机A返回的确认报文中首部的ECE位置为1，通知主机A发生网络拥塞。主机A在收到主机B发来的确认包后，将自己的拥塞窗口减半。将接下来要发出去给B的TCP数据段首部中的CWR置为1表示要将拥塞窗口减半。</span><br></pre></td></tr></table></div></figure>        <h3 id="拥塞处理策略"   >          <a href="#拥塞处理策略" class="heading-link"><i class="fas fa-link"></i></a>拥塞处理策略</h3>              <h4 id="中间路由器拥塞的状况"   >          <a href="#中间路由器拥塞的状况" class="heading-link"><i class="fas fa-link"></i></a>中间路由器拥塞的状况</h4>      <ul><li><p>tail-drop：后来的全部丢弃</p><p>如果被丢弃的报文段属于一个相同的TCP连接，则发送方进入慢启动状态</p><p>如果被丢弃的报文段属于多个不同的TCP连接，则这些连接都进入了慢启动状态，称为：全局同步（此时网络性能大幅降低）</p></li><li><p>random Early Detection：用于取代tail-drop的策略<br>系统内设置两个阈值：最小值Tmin和最大值Tmax</p><p>RED的处理原则：（关键时Tmin，Tmax和概率p的设置）</p><p>1 队列长度小于Tmin，则报文加入<br>2 队列长度超过Tmax，则报文丢弃<br>3 选择随机以概率p丢弃</p></li></ul>        <h2 id="TCP连接管理"   >          <a href="#TCP连接管理" class="heading-link"><i class="fas fa-link"></i></a>TCP连接管理</h2>      <p>连接建立和拆除</p>        <h3 id="建立连接"   >          <a href="#建立连接" class="heading-link"><i class="fas fa-link"></i></a>建立连接</h3>              <h4 id="两次握手存在的问题"   >          <a href="#两次握手存在的问题" class="heading-link"><i class="fas fa-link"></i></a>两次握手存在的问题</h4>      <ul><li>发送方的连接请求可能是重传的，这会进行重复的建立连接</li></ul>        <h4 id="三次握手"   >          <a href="#三次握手" class="heading-link"><i class="fas fa-link"></i></a>三次握手</h4>      <p><img src="http://acptek.gitee.io/blogpictures/TCPIP/Ch11_TCP_handshakes3.png" alt="三次握手"></p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 1  Send: SYN seq &#x3D; x（x的选择只与site1有关，这是一个初始的序号）</span><br><span class="line">- 2  Recv: SYN  Send: SYN seq &#x3D; y, ACK x+1  (y的选择只与site2有关，假设将SYN标志看成1个字节的数据)</span><br><span class="line">- 3  Recv: SYN, ACK  Send: ACK y+1</span><br><span class="line">- 4  ACK</span><br></pre></td></tr></table></div></figure><p>TCB (传输控制块：一个数据结构)</p>        <h4 id="说明"   >          <a href="#说明" class="heading-link"><i class="fas fa-link"></i></a>说明</h4>      <ul><li>序号的选取问题<br>双方选取的初始序号，是各自根据本地情况来选取的。<br>初始号的选取具有一定的随机性，只有在连接的时候会涉及到初始序号的选择问题。<br>涉及到安全问题：<br>若第三方非法用户，需要知道通讯双方的初始序号</li><li>数据的携带问题<br>一般情况下，seq段不带数据。如果携带数据，这些数据会先缓存起来，直到三次握手成功后才进行发送和接收。一般在通讯中，最后的ACK段会携带数据 </li></ul>        <h3 id="关闭连接"   >          <a href="#关闭连接" class="heading-link"><i class="fas fa-link"></i></a>关闭连接</h3>              <h4 id="正常关闭：gracefully"   >          <a href="#正常关闭：gracefully" class="heading-link"><i class="fas fa-link"></i></a>正常关闭：gracefully</h4>      <ul><li>一个方向上的关闭不影响另一个方向的数据流</li><li>原来缓冲区的缓存数据仍需要发完</li><li>将段的首部FIN标志置1，对方收到FIN会回复一个确认，收到确认后，两个方向的数据全部断开，总共4次握手（若是3次的情况，则为修改过的断连握手过程）</li><li>理解成两个方向上的断连</li></ul>        <h4 id="标准的断连过程"   >          <a href="#标准的断连过程" class="heading-link"><i class="fas fa-link"></i></a>标准的断连过程</h4>      <p><img src="http://acptek.gitee.io/blogpictures/TCPIP/Ch11_TCP_waves4.png" alt="4次挥手"></p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- 1  Send: FIN seq &#x3D; x</span><br><span class="line">- 2 Recv: FIN  Send : ACK x+1（FIN标志在协议中也算作一个字节）</span><br><span class="line">- 3  Recv: ACK</span><br><span class="line"></span><br><span class="line">- 3 Send: FIN seq &#x3D; y  ACK x+1</span><br><span class="line">- 4  Recv: FIN, ACK  Send: ACK y+1</span><br><span class="line">- 5  Recv: ACK</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 若3次，则两个3操作合并为一次操作（site1断连的时候恰好site2中没有数据在发送）</span><br></pre></td></tr></table></div></figure>        <h4 id="突发式的关闭："   >          <a href="#突发式的关闭：" class="heading-link"><i class="fas fa-link"></i></a>突发式的关闭：</h4>      <ul><li>RST 粗暴的关闭</li><li>应用：在出口安装一个设备，检测每一个包，检测目标IP是否属于黑名单，是则向用户发送一个RST 断开连接</li></ul>        <h3 id="TCP-State-Machine"   >          <a href="#TCP-State-Machine" class="heading-link"><i class="fas fa-link"></i></a>TCP State Machine</h3>      <p>有限状态机</p><p><img src="http://acptek.gitee.io/blogpictures/TCPIP/Ch11_TCP_State_Machine.png" alt="TCP有限状态机"></p><ul><li>TIMED WAIT ：等待两个段的生命期<br>在子网中存储起来，突然冒出，则会造成错误接收<br>1 一方向另一方发送的数据段<br>2 接收方返回的确认段</li></ul>        <h3 id="强迫数据传输"   >          <a href="#强迫数据传输" class="heading-link"><i class="fas fa-link"></i></a>强迫数据传输</h3>      <ul><li>一般将数据存到缓存中等到缓存满时再发送出去，使用Push标志后立即发送</li><li>实时应用：例如ssh远程连接</li></ul>        <h2 id="TCP性能问题"   >          <a href="#TCP性能问题" class="heading-link"><i class="fas fa-link"></i></a>TCP性能问题</h2>      <ul><li><p>协议的最大吞吐量：</p><p>两个站点在10M的以太网下最大可以到达8M</p></li><li><p>收发双方应用的速度不一样导致一些性能问题。</p></li></ul>        <h3 id="SWS：傻窗口综合征"   >          <a href="#SWS：傻窗口综合征" class="heading-link"><i class="fas fa-link"></i></a>SWS：傻窗口综合征</h3>      <p>信道利用率几乎为零</p>        <h3 id="避免SWS"   >          <a href="#避免SWS" class="heading-link"><i class="fas fa-link"></i></a>避免SWS</h3>      <p>Nagle算法：主要是进行缓存的积累</p><ul><li><p>发送方避免：发送方使用缓冲区积累一定长度的数据量</p><p>针对不同的应用等待不同的时间</p><p>延时时间的处理：</p><p>​    在TCP中通过ACK来触发。在确认到达时缓冲区中积累了一定量的数据。</p></li><li><p>接收方避免：接收方维持一个本地缓冲区空闲空间大小，区域大小放在确认中反馈给发送方，在反馈的时候进行延迟<br>（延迟确认的两个条件）—&gt; 最长等待时间<br>1 缓冲区可用空闲区达到原先缓冲区大小的一半<br>2 接收缓冲区可用空闲区积累到能够放下一个MSS</p></li></ul><p>​    二者任意满足其一，接收方就可以将这块空闲的区域通告给发送方。（在实现中包括采用一种零窗口探测来避免死锁）</p>        <h3 id="缓冲区暴涨现象"   >          <a href="#缓冲区暴涨现象" class="heading-link"><i class="fas fa-link"></i></a>缓冲区暴涨现象</h3>      <p>缓冲区大到一定程度时，缓冲区延迟非常长。无法适用实时应用。</p><hr><p>参考资料：</p><ul><li>INTERNETWORKING WITH TCP/IP PRINCIPLES, PROTOCOLS, AND ARCHITECTURE Vol1 (6th Edition).  DOUGLASE E. COMER </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;TCP-可靠的流传输服务&quot;   &gt;
          &lt;a href=&quot;#TCP-可靠的流传输服务&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;TCP 可靠的流传输服务&lt;/h2&gt;
      
        &lt;h2 id=&quot;概述&quot;   &gt;
          &lt;a href=&quot;#概述&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;概述&lt;/h2&gt;
      &lt;p&gt;传输控制协议，字节流服务&lt;br&gt;适用于其他不同类型的网络传递服务&lt;/p&gt;
    
    </summary>
    
      <category term="TCP/IP" scheme="https://acptek.github.io/categories/TCP-IP/"/>
    
    
      <category term="TCP/IP" scheme="https://acptek.github.io/tags/TCP-IP/"/>
    
      <category term="TCP" scheme="https://acptek.github.io/tags/TCP/"/>
    
      <category term="网络拥塞处理" scheme="https://acptek.github.io/tags/%E7%BD%91%E7%BB%9C%E6%8B%A5%E5%A1%9E%E5%A4%84%E7%90%86/"/>
    
      <category term="TCP连接管理" scheme="https://acptek.github.io/tags/TCP%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/"/>
    
      <category term="TCP性能" scheme="https://acptek.github.io/tags/TCP%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>CentOS8 - PBS Pro 单节点安装</title>
    <link href="https://acptek.github.io/2020/07/03/CentOS8-PBS-Pro-%E5%8D%95%E8%8A%82%E7%82%B9%E5%AE%89%E8%A3%85/"/>
    <id>https://acptek.github.io/2020/07/03/CentOS8-PBS-Pro-单节点安装/</id>
    <published>2020-07-03T12:00:43.000Z</published>
    <updated>2020-07-03T12:54:13.436Z</updated>
    
    <content type="html"><![CDATA[        <h1 id="CentOS8-PBS-Pro-单节点安装"   >          <a href="#CentOS8-PBS-Pro-单节点安装" class="heading-link"><i class="fas fa-link"></i></a>CentOS8 - PBS Pro 单节点安装</h1>      <a id="more"></a>        <h2 id="1-安装依赖"   >          <a href="#1-安装依赖" class="heading-link"><i class="fas fa-link"></i></a>1 安装依赖</h2>      <p>安装编译所需的依赖</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum install -y gcc make rpm-build libtool hwloc-devel \</span><br><span class="line">      libX11-devel libXt-devel libedit-devel libical-devel \</span><br><span class="line">      ncurses-devel perl postgresql-devel postgresql-contrib python3-devel tcl-devel \</span><br><span class="line">      tk-devel swig expat-devel openssl-devel libXext libXft \</span><br><span class="line">      autoconf automake</span><br></pre></td></tr></table></div></figure><p>但是这里<code>libical-devel</code> 安装不上需要手动安装</p><p>在aarch64架构上：</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rpm -ivh https:&#x2F;&#x2F;rpmfind.net&#x2F;linux&#x2F;centos&#x2F;8-stream&#x2F;AppStream&#x2F;aarch64&#x2F;os&#x2F;Packages&#x2F;libical-devel-3.0.3-3.el8.aarch64.rpm</span><br></pre></td></tr></table></div></figure><p>然后，就“依赖递归”了，可以编写脚本递归安装</p><p>安装运行所需的依赖</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ yum install -y expat libedit postgresql-server postgresql-contrib python3 \</span><br><span class="line">      sendmail sudo tcl tk libical</span><br></pre></td></tr></table></div></figure>        <h2 id="2-创建非root用户，下载源码"   >          <a href="#2-创建非root用户，下载源码" class="heading-link"><i class="fas fa-link"></i></a>2 创建非root用户，下载源码</h2>      <p>创建用户</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo addusr -m stu</span><br><span class="line">$ sudo passwd stu</span><br></pre></td></tr></table></div></figure><p>下载源码</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git clone -b release_20_0_branch https:&#x2F;&#x2F;github.com&#x2F;openpbs&#x2F;openpbs.git</span><br><span class="line">$ cd openpbs</span><br></pre></td></tr></table></div></figure>        <h2 id="3-编译和安装"   >          <a href="#3-编译和安装" class="heading-link"><i class="fas fa-link"></i></a>3 编译和安装</h2>      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;autogen.sh</span><br><span class="line">$ .&#x2F;configure --help # 这里查看编译选项</span><br><span class="line">$ .&#x2F;configure --prefix&#x3D;&#x2F;opt&#x2F;pbs</span><br><span class="line"></span><br><span class="line">$ make</span><br><span class="line">$ sudo make install</span><br></pre></td></tr></table></div></figure>        <h2 id="4-配置"   >          <a href="#4-配置" class="heading-link"><i class="fas fa-link"></i></a>4 配置</h2>      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl stop firewalld.service# 关闭防火墙</span><br><span class="line"></span><br><span class="line">$ sudo &#x2F;opt&#x2F;pbs&#x2F;libexec&#x2F;pbs_postinstall# 执行脚本初始化节点</span><br><span class="line">$ sudo vi &#x2F;etc&#x2F;pbs.conf# 单节点：将PBS_START_MOM设置为1，将server作为计算节点</span><br><span class="line">$ sudo chmod 4755 &#x2F;opt&#x2F;pbs&#x2F;sbin&#x2F;pbs_iff &#x2F;opt&#x2F;pbs&#x2F;sbin&#x2F;pbs_rcp</span><br></pre></td></tr></table></div></figure>        <h2 id="5-启动服务"   >          <a href="#5-启动服务" class="heading-link"><i class="fas fa-link"></i></a>5 启动服务</h2>      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo &#x2F;etc&#x2F;init.d&#x2F;pbs start</span><br></pre></td></tr></table></div></figure><p>应用PATH或者MANPATH更新</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ . &#x2F;etc&#x2F;profile.d&#x2F;pbs.sh</span><br></pre></td></tr></table></div></figure>        <h2 id="6-创建节点和工作队列"   >          <a href="#6-创建节点和工作队列" class="heading-link"><i class="fas fa-link"></i></a>6 创建节点和工作队列</h2>      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo &#x2F;opt&#x2F;pbs&#x2F;bin&#x2F;qmgr</span><br><span class="line">qmgr: create node hostname</span><br><span class="line">qmgr: create queue workq queue_type&#x3D;e,enabled&#x3D;t,started&#x3D;t</span><br><span class="line">qmgr: ^D</span><br></pre></td></tr></table></div></figure>        <h2 id="7-测试"   >          <a href="#7-测试" class="heading-link"><i class="fas fa-link"></i></a>7 测试</h2>      <p>测试在非root用户下提交作业</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ su stu</span><br><span class="line">$ qstat -a</span><br><span class="line">$ echo &quot;sleep 60&quot; | qsub</span><br><span class="line">$ qstat -f Job_ID</span><br></pre></td></tr></table></div></figure>        <h2 id="8-一些问题"   >          <a href="#8-一些问题" class="heading-link"><i class="fas fa-link"></i></a>8 一些问题</h2>      <p>8.1 关于 <code>qstat:cannot connect to server</code></p><p>检查hosts文件，将IP地址与主机名添加进去</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ uname -a</span><br><span class="line">$ sudo vi &#x2F;etc&#x2F;hosts</span><br></pre></td></tr></table></div></figure><p>8.2 关于<code>qmgr:cannot connect to server node</code></p><p>检查node节点<code>pbsnodes -a</code></p><p>删除重新创建</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo &#x2F;opt&#x2F;pbs&#x2F;bin&#x2F;qmgr</span><br><span class="line">qmgr: delete node hostname</span><br><span class="line">qmgr: create node hostname</span><br><span class="line">qmgr: ^D</span><br></pre></td></tr></table></div></figure><p>8.3 关于node节点 <code>state != free</code></p><p>同上，删除节点重新创建</p><p>正常情况：</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOM &#x3D; hostname</span><br><span class="line">state &#x3D; free</span><br></pre></td></tr></table></div></figure><p>8.4 其他</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ tail 10 &#x2F;var&#x2F;spool&#x2F;pbs&#x2F;server_logs&#x2F;20200610 # 查看日志</span><br><span class="line"></span><br><span class="line">$ qmgr</span><br><span class="line">set queue workq resources_max.walltime &#x3D; 120:00:00 # 设置单个节点最大运行</span><br><span class="line">set node localhost.localdomain max_user_run&#x3D;1 # 设置最大的任务运行数为1</span><br></pre></td></tr></table></div></figure><hr><p>参考资料：</p><p>1 <span class="exturl"><a class="exturl__link"   href="https://github.com/openpbs/openpbs"  target="_blank" rel="noopener">https://github.com/openpbs/openpbs</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>2 <span class="exturl"><a class="exturl__link"   href="https://github.com/openpbs/openpbs/blob/master/INSTALL"  target="_blank" rel="noopener">https://github.com/openpbs/openpbs/blob/master/INSTALL</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>3 <span class="exturl"><a class="exturl__link"   href="https://pkgs.org/"  target="_blank" rel="noopener">https://pkgs.org/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>4 <span class="exturl"><a class="exturl__link"   href="https://rpmfind.net/linux/RPM/index.html"  target="_blank" rel="noopener">https://rpmfind.net/linux/RPM/index.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>5 <span class="exturl"><a class="exturl__link"   href="http://community.pbspro.org/"  target="_blank" rel="noopener">http://community.pbspro.org/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CentOS8-PBS-Pro-单节点安装&quot;   &gt;
          &lt;a href=&quot;#CentOS8-PBS-Pro-单节点安装&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;CentOS8 - PBS Pro 单节点安装&lt;/h1&gt;
    
    </summary>
    
      <category term="Parallel Computing" scheme="https://acptek.github.io/categories/Parallel-Computing/"/>
    
    
      <category term="Linux" scheme="https://acptek.github.io/tags/Linux/"/>
    
      <category term="Centos8" scheme="https://acptek.github.io/tags/Centos8/"/>
    
      <category term="PBS Pro" scheme="https://acptek.github.io/tags/PBS-Pro/"/>
    
      <category term="Configuration" scheme="https://acptek.github.io/tags/Configuration/"/>
    
      <category term="aarch64" scheme="https://acptek.github.io/tags/aarch64/"/>
    
  </entry>
  
  <entry>
    <title>根据匹配点估计相机运动</title>
    <link href="https://acptek.github.io/2020/07/03/%E6%A0%B9%E6%8D%AE%E5%8C%B9%E9%85%8D%E7%82%B9%E4%BC%B0%E8%AE%A1%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/"/>
    <id>https://acptek.github.io/2020/07/03/根据匹配点估计相机运动/</id>
    <published>2020-07-03T11:58:04.000Z</published>
    <updated>2020-07-03T12:51:03.446Z</updated>
    
    <content type="html"><![CDATA[        <h2 id="根据匹配点对估计相机运动"   >          <a href="#根据匹配点对估计相机运动" class="heading-link"><i class="fas fa-link"></i></a>根据匹配点对估计相机运动</h2>      <ul><li>2D-2D：对极几何</li><li>3D-2D：PnP</li><li>3D-3D：ICP</li></ul><a id="more"></a><p>2D-2D：对极几何</p><p>1 对极约束</p><p>极线：在对极几何约束模型中，若不知道p与p2，那么p1对应所在I2平面的位置就在极点e2出发的一条射线上，具体就是e2(p2)所在的直线上。（其中，p1,p2都是p在对应平面上的投影点）</p><p>实践中已知量：p1,p2 //通过特征匹配确定</p><p>未知量：p, e1, e2</p><p>待求量：相机的运动 T12，p</p><p>约束模型中两个像素点 $p_1,p_2$ 的关系，</p><script type="math/tex; mode=display">s_1p_1 = KP_w\;,\;s_2p_2 = K(RP_w+t)</script><p>其中，s1，s2是世界坐标中的z轴坐标，是一个尺度。前一个等式为P在l1上的直接投影，而后一个等式是在相机内参不变的情况下在前一个等式两边增加一个变换矩阵T，根据P在l1的投影得出相机运动后P在l2的投影。</p><p>对极约束关系式：</p><script type="math/tex; mode=display">x_2^Tt^\wedge Rx_1=0 \tag{1}</script><script type="math/tex; mode=display">p_2^TK^{-T}t^\wedge RK^{-1}p_1=0 \tag{2}</script><p>另 $E=t^\wedge R$（本质矩阵），$F=K^{-T}EK^{-1}$（基础矩阵）</p><script type="math/tex; mode=display">\Rightarrow x_2^TEx_1=p_2^TFp_1=0</script><p>然后通过匹配的特征点对求出E或F，进而求出R，t</p><p>2 本质矩阵</p><p>八点法求解本质矩阵</p><p>通过八对特征点，建立八个方程，将本质矩阵以八个自由度计算，最后再对计算结果优化，使矩阵满足本质矩阵只有五个自由度的性质。</p><p>SVD分解求解相机运动 R，t</p><script type="math/tex; mode=display">\begin{align}& E=U\Sigma V^T\\\Rightarrow\;& t_1^\wedge,t_2^\wedge=UR_Z(\pm\frac{\pi}{2})\Sigma U^T\\& R_1,R_2=UR_Z(\pm\frac{\pi}{2})V^T\end{align}</script><p>其中，V、U为正交矩阵，$\Sigma=diag(\sigma, \sigma,0)$是一个对角矩阵，最后一维为0表示相差一个尺度，若求出的不满足这个形式，则调整前两维相等，最后一维为零。</p><p>3 单应矩阵</p><p>三角测量</p><script type="math/tex; mode=display">s_2x_2=s_1Rx_1+t\; \Rightarrow\;s_2x_2^\wedge x_2=\underline{0=s_1x_2^\wedge Rx_1+x_2^\wedge t}</script><p>得到一个超定方程，用最小二乘求解</p><p>或者</p><script type="math/tex; mode=display">\begin{align}s_2x_2-s_1Rx_1+t \;& \Rightarrow\;\left\{\begin{matrix}s_2x_2^Tx_2-s_1x_2^TRx_1=x_2^Tt\\ s_2(Rx_1)^Tx_2-s_1(Rx_1)^TRx_1=(Rx_1)^Tt\end{matrix}\right.\\&\\& \Rightarrow \begin{bmatrix}x_2^Tx_2 & -x_2^Tx_1\\ (Rx_1)^Tx_2 & -(Rx_1)^TRx_1\end{bmatrix}\begin{bmatrix}s_1\\ s_2\end{bmatrix}=\begin{bmatrix}x_2^Tt\\ (Rx_1)^Tt\end{bmatrix}\end{align} \tag{Cramer's Rule}</script><hr><p>参考资料：</p><ul><li>视觉SLAM十四讲：从理论到实践（第2版）.  高翔.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;根据匹配点对估计相机运动&quot;   &gt;
          &lt;a href=&quot;#根据匹配点对估计相机运动&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;根据匹配点对估计相机运动&lt;/h2&gt;
      &lt;ul&gt;
&lt;li&gt;2D-2D：对极几何&lt;/li&gt;
&lt;li&gt;3D-2D：PnP&lt;/li&gt;
&lt;li&gt;3D-3D：ICP&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="SLAM" scheme="https://acptek.github.io/categories/SLAM/"/>
    
    
      <category term="SLAM" scheme="https://acptek.github.io/tags/SLAM/"/>
    
      <category term="Math" scheme="https://acptek.github.io/tags/Math/"/>
    
      <category term="OpenCV" scheme="https://acptek.github.io/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>矩阵微分</title>
    <link href="https://acptek.github.io/2020/07/03/%E7%9F%A9%E9%98%B5%E5%BE%AE%E5%88%86/"/>
    <id>https://acptek.github.io/2020/07/03/矩阵微分/</id>
    <published>2020-07-03T11:53:35.000Z</published>
    <updated>2020-07-03T12:58:56.115Z</updated>
    
    <content type="html"><![CDATA[        <h2 id="矩阵微分"   >          <a href="#矩阵微分" class="heading-link"><i class="fas fa-link"></i></a>矩阵微分</h2>      <p>矩阵对于数量变量的微分</p><script type="math/tex; mode=display">\begin{align}& A=[a_{ij}(t)]_{m\times n}\\\Rightarrow&\frac{dA}{dt}=[\frac{da_{ij}(t)}{dt}]_{m \times n}\end{align} \tag{0}</script><p>运算法则</p><script type="math/tex; mode=display">\begin{align}&A是n阶常数矩阵 ,\\(1)\;&\frac{d}{dt}e^{tA}=Ae^{tA}=e^{tA}A\\(2)\;&\frac{d}{dt}\cos(tA)=-A\cdot\sin(tA)=-\sin(tA)\cdot A\\(3)\;&\frac{d}{dt}\sin(tA)=A\cdot\cos(tA)=\cos(tA)\cdot A\\\end{align}</script><a id="more"></a><p>数量函数对于向量/矩阵的微分</p><p>$f(x)=f(x_1,x_2,\cdots,x_n),\;x=[x_1,x_2,\cdots,x_n]^T$</p><script type="math/tex; mode=display">\frac{df(x)}{dx}=[\frac{\partial f}{\partial x_1}\;\frac{\partial f}{\partial x_2}\;\cdots\;\frac{\partial f}{\partial x_n}]^T\tag{1}</script><script type="math/tex; mode=display">\frac{df(x)}{dx^T}=[\frac{\partial f}{\partial x_1}\;\frac{\partial f}{\partial x_2}\;\cdots\;\frac{\partial f}{\partial x_n}]\tag{1}</script><p>定义为梯度：$grad[f(x)]= \bigtriangledown f(x)$</p><p>向量函数对于向量的微分</p><p>$a(x)=[a_1(x)\;a_2(x)\;\cdots\;a_m(x)]^T,\;x=[x_1\;x_2\;\cdots x_n]^T$</p><script type="math/tex; mode=display">\frac{da(x)}{dx^T}=\begin{bmatrix}\frac{\partial a_i}{\partial x_j}\end{bmatrix}_{m \times n}\tag{2}</script><script type="math/tex; mode=display">\frac{da^T(x)}{dx}=\begin{bmatrix}\frac{\partial a_j}{\partial x_i}\end{bmatrix}_{m \times n}\tag{2}</script><p>注：$a_i(x)$是关于 $x_1,x_2,\cdots,x_n$ 的函数，（2）中的矩阵称为雅克比矩阵</p><p>矩阵函数对于向量的微分</p><script type="math/tex; mode=display">A(x)=\begin{bmatrix}a_{11}(x) & a_{12}(x) & \cdots & a_{1l}(x)\\ a_{21}(x) & a_{22}(x) &\cdots  & a_{2l}(x)\\ \vdots & \vdots & \vdots & \vdots\\ a_{m1}(x) & a_{m2}(x) & \cdots & a_{ml}(x)\end{bmatrix}_{m \times l}</script><p>对 $x=[x_1\;x_2\;\cdots x_n]$ 求微分</p><script type="math/tex; mode=display">\frac{dA(x)}{dx}=\begin{bmatrix}\frac{\partial A(x)}{\partial x_1}\\ \frac{\partial A(x)}{\partial x_2}\\ \vdots\\\frac{\partial A(x)}{\partial x_n}\end{bmatrix}_{nm\times l} \tag{3}</script><p>对 $x=[x_1\;x_2\;\cdots x_n]^T$ 求微分</p><script type="math/tex; mode=display">\frac{dA(x)}{dx}=\begin{bmatrix}\frac{\partial A(x)}{\partial x_1} & \frac{\partial A(x)}{\partial x_2} &\cdots &\frac{\partial A(x)}{\partial x_n}\end{bmatrix}_{n\times ln} \tag{3}</script><p>对一个变量 $x_t$ 微分</p><script type="math/tex; mode=display">\frac{\partial A(x)}{\partial x_t}=\begin{bmatrix} \frac{\partial a_{ij}(x)}{\partial x_t} \end{bmatrix}_{m \times l} \tag{3}</script><p>复合函数微分</p><p>$f=f(Y),Y=Y(x)$</p><script type="math/tex; mode=display">\begin{align}& \frac{df}{dX}=\frac{dY^T}{dX}\frac{df}{dY}\\& \frac{df}{dX^T}=\frac{df}{dY^T}\frac{dY}{dX^T}\end{align} \tag{4}</script><p>$f=f(X,Y),Y=Y(x)$</p><script type="math/tex; mode=display">\begin{align}& \frac{df}{dX}=\frac{\partial f}{\partial X} + \frac{dY^T}{dX}\frac{\partial f}{\partial Y}\\&\frac{df}{dX^T}=\frac{\partial f}{\partial X^T} + \frac{df}{dY^T}\frac{\partial Y}{\partial X^T}\end{align} \tag{4}</script><p>求导法则：</p><script type="math/tex; mode=display">(A^{-1})'=-A^{-1}A'A^{-1}</script><p>导数与微分的联系（迹技巧）：</p><p>矩阵形式</p><script type="math/tex; mode=display">df=tr(\frac{\partial f}{\partial X}^TdX)</script><p>向量形式</p><script type="math/tex; mode=display">df=tr(\frac{\partial f}{\partial x}^Tdx)</script><p>函数对矩阵</p><blockquote><p><strong>若标量函数f是矩阵X经加减乘法、逆、行列式、逐元素函数等运算构成，则使用相应的运算法则对f求微分，再使用迹技巧给df套上迹并将其它项交换至dX左侧，对照导数与微分的联系，即能得到导数</strong></p><p><strong>特别地，若矩阵退化为向量，对照导数与微分的联系</strong></p></blockquote><p>先对特征式求导，再用迹技巧求微分</p><p>矩阵对矩阵</p><hr><p>参考：</p><ul><li><span class="exturl"><a class="exturl__link"   href="https://zhuanlan.zhihu.com/p/24709748"  target="_blank" rel="noopener">矩阵求导术（上） - 长躯鬼侠的文章 - 知乎</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li><span class="exturl"><a class="exturl__link"   href="https://zhuanlan.zhihu.com/p/24863977"  target="_blank" rel="noopener">矩阵求导术（下） - 长躯鬼侠的文章 - 知乎</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;矩阵微分&quot;   &gt;
          &lt;a href=&quot;#矩阵微分&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;矩阵微分&lt;/h2&gt;
      &lt;p&gt;矩阵对于数量变量的微分&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
\begin{align}&amp; A=[a_{ij}(t)]_{m\times n}\\\Rightarrow&amp;\frac{dA}{dt}=[\frac{da_{ij}(t)}{dt}]_{m \times n}\end{align} \tag{0}&lt;/script&gt;&lt;p&gt;运算法则&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
\begin{align}
&amp;A是n阶常数矩阵 ,\\
(1)\;&amp;\frac{d}{dt}e^{tA}=Ae^{tA}=e^{tA}A\\
(2)\;&amp;\frac{d}{dt}\cos(tA)=-A\cdot\sin(tA)=-\sin(tA)\cdot A\\
(3)\;&amp;\frac{d}{dt}\sin(tA)=A\cdot\cos(tA)=\cos(tA)\cdot A\\
\end{align}&lt;/script&gt;
    
    </summary>
    
      <category term="Math" scheme="https://acptek.github.io/categories/Math/"/>
    
    
      <category term="Math" scheme="https://acptek.github.io/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP 用户数据报协议</title>
    <link href="https://acptek.github.io/2020/07/03/TCP-IP-%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE/"/>
    <id>https://acptek.github.io/2020/07/03/TCP-IP-用户数据报协议/</id>
    <published>2020-07-03T11:20:22.000Z</published>
    <updated>2020-07-03T12:49:32.304Z</updated>
    
    <content type="html"><![CDATA[        <h1 id="用户数据报协议"   >          <a href="#用户数据报协议" class="heading-link"><i class="fas fa-link"></i></a>用户数据报协议</h1>      <ul><li>传输层的协议</li><li>区分统一主机的应用</li><li>对于通讯而言（最终目标）：区分任务</li></ul><a id="more"></a>        <h2 id="UDP-用户报文协议"   >          <a href="#UDP-用户报文协议" class="heading-link"><i class="fas fa-link"></i></a>UDP 用户报文协议</h2>      <p>无连接的服务，不可靠的传输，由应用解决差错</p>        <h3 id="报文格式"   >          <a href="#报文格式" class="heading-link"><i class="fas fa-link"></i></a>报文格式</h3>      <p><img src="http://acptek.gitee.io/blogpictures/TCPIP/Ch10_UDP_Format.png" alt="UDP报文格式"></p><ul><li><p>结构 ： 首部 + 数据</p></li><li><p>首部：<br>源端口号，目标端口 (16bit)<br>UDP报文长度：长度包括了头部的长度<br>UDP报文校验和 （整个报文+伪头部） （针对IP的扩展，校验自身报文确保数据的完整性）<br>Checksum：实现的时候如果值为零，双方则在通信的时候默认不校验。</p></li><li><p>UDP伪首部：加入通讯双方的IP地址，将通讯双方明确的区分<br>IPv4伪首部格式：<br><img src="http://acptek.gitee.io/blogpictures/TCPIP/Ch10_IPv4_PseudoHeaderFormat.png" alt="IPv4伪首部格式"></p><pre><code>源IP目标IP报文的协议号（同于 IP协议的协议编号字段protocol）（UDP对应值为17）报文长度：指收到的实际的报文长度</code></pre><p>（分组发送的时候不包含伪首部，仅仅用在校验的计算）</p><p>IPv6伪首部格式：<br><img src="http://acptek.gitee.io/blogpictures/TCPIP/Ch10_IPv6_PseudoHeaderFormat.png" alt="IPv6伪首部格式"></p><pre><code>    NEXT HEADER 字段填写的与UDP的协议号一致 (17)</code></pre></li></ul>        <h2 id="UDP-协议的封装关系"   >          <a href="#UDP-协议的封装关系" class="heading-link"><i class="fas fa-link"></i></a>UDP 协议的封装关系</h2>      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UDP：message，user datagram protocol</span><br><span class="line">UDP报文封装在IP数据区</span><br><span class="line"></span><br><span class="line">层与层之间提供服务接口</span><br><span class="line">UDP -&gt; 确定主机内的一个进程</span><br><span class="line">IP  -&gt; 确定一个主机</span><br></pre></td></tr></table></div></figure>        <h2 id="UDP-多路复用-与-解多路复用"   >          <a href="#UDP-多路复用-与-解多路复用" class="heading-link"><i class="fas fa-link"></i></a>UDP 多路复用 与 解多路复用</h2>      <ul><li>依据：端口号</li><li>发送方：收到报文后交付IP层再交付到链路层</li><li>接收方：根据分组的首部协议号交给UDP模块处理，UDP根据端口号交给对应的应用进程<br>接收队列（关联应用进程，队列长度有限</li></ul>        <h3 id="端口号的获取"   >          <a href="#端口号的获取" class="heading-link"><i class="fas fa-link"></i></a>端口号的获取</h3>      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 中心管理机构统一分配（全球分配方法，well-known）</span><br><span class="line">2 动态分配（进程服务器动态分配）</span><br><span class="line">客户端先与进程服务器联系</span><br><span class="line">进程服务器收到客户端请求后，会动态的将进程服务启动</span><br><span class="line">再将动态分配的端口号反馈给客户端</span><br></pre></td></tr></table></div></figure><hr><p>参考资料：</p><ul><li>INTERNETWORKING WITH TCP/IP PRINCIPLES, PROTOCOLS, AND ARCHITECTURE Vol1 (6th Edition).  DOUGLASE E. COMER </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;用户数据报协议&quot;   &gt;
          &lt;a href=&quot;#用户数据报协议&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;用户数据报协议&lt;/h1&gt;
      &lt;ul&gt;
&lt;li&gt;传输层的协议&lt;/li&gt;
&lt;li&gt;区分统一主机的应用&lt;/li&gt;
&lt;li&gt;对于通讯而言（最终目标）：区分任务&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="TCP/IP" scheme="https://acptek.github.io/categories/TCP-IP/"/>
    
    
      <category term="TCP/IP" scheme="https://acptek.github.io/tags/TCP-IP/"/>
    
      <category term="UDP" scheme="https://acptek.github.io/tags/UDP/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP IP差错控制协议</title>
    <link href="https://acptek.github.io/2020/07/03/TCP-IP-IP%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE/"/>
    <id>https://acptek.github.io/2020/07/03/TCP-IP-IP差错控制协议/</id>
    <published>2020-07-03T11:03:30.000Z</published>
    <updated>2020-07-22T06:05:25.618Z</updated>
    
    <content type="html"><![CDATA[        <h1 id="IP差错控制协议"   >          <a href="#IP差错控制协议" class="heading-link"><i class="fas fa-link"></i></a>IP差错控制协议</h1>      <p>ICMP-因特网控制报文协议<br>差错控制，是IP的补充</p><a id="more"></a>        <h2 id="ICMP传输方法"   >          <a href="#ICMP传输方法" class="heading-link"><i class="fas fa-link"></i></a>ICMP传输方法</h2>      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通过IP来发送，封装在IP的数据区</span><br><span class="line">发送的信息包括一些差错和控制信息</span><br></pre></td></tr></table></div></figure>        <h2 id="ICMP提供的功能"   >          <a href="#ICMP提供的功能" class="heading-link"><i class="fas fa-link"></i></a>ICMP提供的功能</h2>      <ul><li>属于报错的功能，只进行报错不进行纠错</li><li>只将差错报告给原始的发送者（源节点）</li></ul>        <h2 id="ICMP报文传输"   >          <a href="#ICMP报文传输" class="heading-link"><i class="fas fa-link"></i></a>ICMP报文传输</h2>      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ICMP封装在IP数据区，但只是IP的补充非IP的上层协议</span><br><span class="line">对ICMP报文的错误不再产生ICMP报文</span><br><span class="line"></span><br><span class="line">IPv4：IP首部protocol字段，ICMP在其中占据了一个位置 |value -&gt; 1|</span><br><span class="line">IPv6：NEXT HEADER  |value -&gt; 58|</span><br></pre></td></tr></table></div></figure>        <h2 id="ICMP报文格式"   >          <a href="#ICMP报文格式" class="heading-link"><i class="fas fa-link"></i></a>ICMP报文格式</h2>      <ul><li>TYPE ：8bit ，报文的大的类别</li><li>CODE ：8bit ，大类中的子类  (若没有子类，则为0）</li><li>CHECKSUM ：16bit ，校验和 （算法与IP的首部校验和算法相同，求16位整数序列反码和的反码）</li></ul>        <h3 id="IPv4和IPv6的ICMP报文类型："   >          <a href="#IPv4和IPv6的ICMP报文类型：" class="heading-link"><i class="fas fa-link"></i></a>IPv4和IPv6的ICMP报文类型：</h3>      <ul><li>v6中包含很多简化的工作，（取消v4中的一些类型<pre><code>      MLD ： 组管理协议 -&gt; 对应v4中的IGMP</code></pre></li><li>v4中的常用类型：<pre><code>      0 echo (request reply)      3 目标不可达      11 time Execced 超时  （在v6中，很多都借用了ICMP的类型）</code></pre></li></ul>        <h2 id="一些ICMP报文"   >          <a href="#一些ICMP报文" class="heading-link"><i class="fas fa-link"></i></a>一些ICMP报文</h2>      <ul><li>ICMPv4报文类型</li></ul><p><img src="http://acptek.gitee.io/blogpictures/TCPIP/Ch9_ICMPv4_Format.png" alt="ICMPv4"></p><ul><li>ICMPv6报文类型</li></ul><p><img src="http://acptek.gitee.io/blogpictures/TCPIP/Ch9_ICMPv6_Format.png" alt="ICMPv6"></p>        <h3 id="Echo"   >          <a href="#Echo" class="heading-link"><i class="fas fa-link"></i></a>Echo</h3>      <p>(ping命令：测试IP地址是否响应和可达)<br>(ping中的ICMP -&gt; echo request , echo reply)<br>(不同OS对ping的实现有差异)</p>        <h4 id="Echo报文格式"   >          <a href="#Echo报文格式" class="heading-link"><i class="fas fa-link"></i></a>Echo报文格式</h4>      <p><img src="http://acptek.gitee.io/blogpictures/TCPIP/Ch9_ICMP_EchoFormat.png" alt="Echo报文格式"></p><ul><li>Type<br>IPv4<pre><code>8：请求 Echo request0：响应 Echo response</code></pre>IPv6<pre><code>128：请求129：响应</code></pre></li><li>Code：可指定数据</li><li>Id，Seq：<br>目标用于信息匹配的字段<br>-&gt; 与源站请求的一致，则匹配进行响应</li><li>Checksum (16bit)：</li></ul><p>IPv4：仅仅计算ICMP报文本身进行校验和计算（首部+携带的数据<br>IPv6：还需要加入一个 “伪首部(pseudo-header)”进行计算 （为了统一 TCP，UDP</p><p>IPv6伪首部格式：</p><p><img src="http://acptek.gitee.io/blogpictures/TCPIP/Ch9_IPv6_PseudoHeader.png" alt="IPv6伪首部格式"></p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">伪头部：</span><br><span class="line">源地址IP</span><br><span class="line">目的地址IP</span><br><span class="line">报文长度（首部+数据   TCP,UDP,ICMP...</span><br><span class="line">上层的协议号（对v6而言：nextheader字段，对v4而言：protocol字段）</span><br><span class="line">32位长度，不足用0填充</span><br><span class="line">TCP 7</span><br><span class="line">UDP 19</span><br><span class="line">ICMPv4-17  ICMPv6-58</span><br><span class="line"></span><br><span class="line">使用伪首部的目的：</span><br><span class="line">1 要与UDP和TCP校验和的算法表示一致</span><br><span class="line">2 区分通信双方以及双方通信所使用的协议</span><br></pre></td></tr></table></div></figure><ul><li>Optional Data：<br>所带数据长度是可变长度，用于给网络管理员测试</li></ul>        <h3 id="目标不可达"   >          <a href="#目标不可达" class="heading-link"><i class="fas fa-link"></i></a>目标不可达</h3>              <h4 id="报文格式"   >          <a href="#报文格式" class="heading-link"><i class="fas fa-link"></i></a>报文格式</h4>      <p><img src="http://acptek.gitee.io/blogpictures/TCPIP/Ch9_DestUnrechFormat.png" alt="DU报文格式"></p><ul><li><p>type<br>IPv4:16种<br>IPv6：8种</p></li><li><p>code</p><p><img src="http://acptek.gitee.io/blogpictures/TCPIP/Ch9_DU_CodeType.png" alt="DU报文类型"></p></li><li><p>checksum</p></li></ul><p>// 未使用的保留0<br>// 出问题的IPv6报文的前缀部分：首部头+前64bit(IPv4)   ICMPv6的最大长度</p><p>​        </p>        <h3 id="Source-Quench-报文"   >          <a href="#Source-Quench-报文" class="heading-link"><i class="fas fa-link"></i></a>Source Quench 报文</h3>      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">拥塞控制相关</span><br></pre></td></tr></table></div></figure>        <h3 id="Redirect-重定向"   >          <a href="#Redirect-重定向" class="heading-link"><i class="fas fa-link"></i></a>Redirect 重定向</h3>      <ul><li><p>发生背景：在通信时，路由器发现有另一条更优的路径，则会通知源端可以下一次路由走更优的一跳，发送一个 redirect ICMP报文</p></li><li><p>缺点：不能结局所有的路由问题，因为ICMP报文只会发送给源端</p></li></ul><ul><li><p>ICMP重定向报文格式</p><p><img src="http://acptek.gitee.io/blogpictures/TCPIP/Ch9_ICMP_RedriectFormat.png" alt="ICMP重定向报文格式"></p></li><li><p>IPv6重定向报文格式    </p><p><img src="http://acptek.gitee.io/blogpictures/TCPIP/Ch9_IPv6_RedriectFormat.png" alt="IPv6重定向报文格式"></p></li></ul>        <h3 id="Time-Exceeded-超时"   >          <a href="#Time-Exceeded-超时" class="heading-link"><i class="fas fa-link"></i></a>Time Exceeded 超时</h3>              <h4 id="问题背景："   >          <a href="#问题背景：" class="heading-link"><i class="fas fa-link"></i></a>问题背景：</h4>      <p>通信中可能出现路由环路，生命期或跳数耗尽，丢弃报文向源端发送超时报文</p>        <h4 id="报文格式-1"   >          <a href="#报文格式-1" class="heading-link"><i class="fas fa-link"></i></a>报文格式</h4>      <p><img src="http://acptek.gitee.io/blogpictures/TCPIP/Ch9_ICMP_RT_Format.png" alt="ICMP超时报文格式"></p><ul><li>Type:<br>IPv4 :11<br>IPv6 :3</li><li>Code:<br>0: 到达生命期<br>1: 碎片重装超时</li></ul>        <h3 id="Parameter-Problem-参数问题"   >          <a href="#Parameter-Problem-参数问题" class="heading-link"><i class="fas fa-link"></i></a>Parameter Problem 参数问题</h3>      <ul><li>IPv4：<br><img src="http://acptek.gitee.io/blogpictures/TCPIP/Ch9_IPv4_ParaProbelmFormat.png" alt="IPv4参数错误报文"></li><li>IPv6：<br><img src="http://acptek.gitee.io/blogpictures/TCPIP/Ch9_IPv6_ParaProblemFormat.png" alt="IPv6参数错误报文"></li></ul><p>例如：取值超范围，不可辨认下一个头部……</p>        <h3 id="Timestamp-Request-时间戳-（request-reply）"   >          <a href="#Timestamp-Request-时间戳-（request-reply）" class="heading-link"><i class="fas fa-link"></i></a>Timestamp Request 时间戳 （request reply）</h3>      <p>用于主机间的时钟同步 (IPv4)</p><p><img src="http://acptek.gitee.io/blogpictures/TCPIP/Ch9_ICMP_TimestampFormat.png" alt="ICMP时间戳报文"></p><p>1 源时间戳 (发送请求的站点填入)<br>2 接收时间戳 （接收者填入）<br>3 传输时间戳 （接收者填入）<br>（2,3 基本一致， 差异主要在1之间，还要将往返时间包括进去）</p><hr><p>参考资料：</p><ul><li>INTERNETWORKING WITH TCP/IP PRINCIPLES, PROTOCOLS, AND ARCHITECTURE Vol1 (6th Edition).  DOUGLASE E. COMER </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;IP差错控制协议&quot;   &gt;
          &lt;a href=&quot;#IP差错控制协议&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;IP差错控制协议&lt;/h1&gt;
      &lt;p&gt;ICMP-因特网控制报文协议&lt;br&gt;差错控制，是IP的补充&lt;/p&gt;
    
    </summary>
    
      <category term="TCP/IP" scheme="https://acptek.github.io/categories/TCP-IP/"/>
    
    
      <category term="TCP/IP" scheme="https://acptek.github.io/tags/TCP-IP/"/>
    
      <category term="ICMP" scheme="https://acptek.github.io/tags/ICMP/"/>
    
      <category term="Echo" scheme="https://acptek.github.io/tags/Echo/"/>
    
      <category term="DU" scheme="https://acptek.github.io/tags/DU/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP IP转发</title>
    <link href="https://acptek.github.io/2020/07/03/TCP-IP-IP%E8%BD%AC%E5%8F%91/"/>
    <id>https://acptek.github.io/2020/07/03/TCP-IP-IP转发/</id>
    <published>2020-07-03T10:54:12.000Z</published>
    <updated>2020-07-03T12:55:48.623Z</updated>
    
    <content type="html"><![CDATA[        <h1 id="IP协议：转发IP数据报"   >          <a href="#IP协议：转发IP数据报" class="heading-link"><i class="fas fa-link"></i></a>IP协议：转发IP数据报</h1>      <a id="more"></a>        <h2 id="因特网中的转发"   >          <a href="#因特网中的转发" class="heading-link"><i class="fas fa-link"></i></a>因特网中的转发</h2>              <h3 id="routing-和-forwarding-的区别"   >          <a href="#routing-和-forwarding-的区别" class="heading-link"><i class="fas fa-link"></i></a>routing 和 forwarding 的区别</h3>      <p>routing指整个从源到目标转发的过程，路由选择<br>forwarding指转发，是路由器本地的操作</p>        <h3 id="IP的目标"   >          <a href="#IP的目标" class="heading-link"><i class="fas fa-link"></i></a>IP的目标</h3>      <p>对用户而言，构建成一个概念上的虚拟网</p>        <h3 id="转发信息库（FIB）"   >          <a href="#转发信息库（FIB）" class="heading-link"><i class="fas fa-link"></i></a>转发信息库（FIB）</h3>      <p>称为：转发表、路由表<br>一个路由节点在发送IP分组的时候的依据</p>        <h3 id="一些转发难度"   >          <a href="#一些转发难度" class="heading-link"><i class="fas fa-link"></i></a>一些转发难度</h3>      <p>进行转发决策时依据的参数<br>处理分组首部服务质量的需求</p>        <h2 id="直接传递和非直接传递"   >          <a href="#直接传递和非直接传递" class="heading-link"><i class="fas fa-link"></i></a>直接传递和非直接传递</h2>      <p>转发过程中的两种形式</p><ul><li>直接：节点发送的目标（不一定是最终目标）与自己在同一个物理网络</li><li>间接：不在同一个物理网络，转发给下一跳的路由器</li></ul>        <h3 id="1-直接传递（单一网络的传输）"   >          <a href="#1-直接传递（单一网络的传输）" class="heading-link"><i class="fas fa-link"></i></a>1  直接传递（单一网络的传输）</h3>      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 将IP数据报封装在链路层帧中</span><br><span class="line">2 目标IP地址映射成对应的物理地址</span><br><span class="line">3 由网卡传输出去</span><br><span class="line">4 比较网络前缀来确定连在一个网络上，然后与目标之间进行直接传递</span><br></pre></td></tr></table></div></figure>        <h3 id="2-间接传递"   >          <a href="#2-间接传递" class="heading-link"><i class="fas fa-link"></i></a>2  间接传递</h3>      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 发送方必须指出下一跳路由器，</span><br><span class="line">2 下一跳路由器继续指定，直到到达目标所在网连接的路由器</span><br></pre></td></tr></table></div></figure>        <h2 id="表驱动的IP转发"   >          <a href="#表驱动的IP转发" class="heading-link"><i class="fas fa-link"></i></a>表驱动的IP转发</h2>      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">包含：目标IP与目标主机地址，到达目标的下一跳</span><br></pre></td></tr></table></div></figure>        <h2 id="默认路由"   >          <a href="#默认路由" class="heading-link"><i class="fas fa-link"></i></a>默认路由</h2>      <p>转发表中的一个重要路由</p><ul><li>功能：在转发表中没有找到对应的路由表项，那么任何目标地址都会与默认路由匹配</li><li>作用：</li></ul><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 合并多个路由的具体表项为一个</span><br><span class="line">2 使得转发表变小</span><br><span class="line">3 残羹网络中减少大部分表项</span><br><span class="line">残羹网络：与因特网只有一条链接</span><br></pre></td></tr></table></div></figure>        <h2 id="特定主机路由"   >          <a href="#特定主机路由" class="heading-link"><i class="fas fa-link"></i></a>特定主机路由</h2>      <p>表项对应一个特定主机</p><ul><li>作用：本地管理网络控制<br>1 便于网络管理<br>2 允许网络测试<br>3 出于安全的控制</li></ul>        <h2 id="IP转发算法"   >          <a href="#IP转发算法" class="heading-link"><i class="fas fa-link"></i></a>IP转发算法</h2>      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">收到上层的IP分组，需要将其转发</span><br><span class="line">1 先从分组首部将目标IP地址抽取出来</span><br><span class="line">2 查找转发表</span><br><span class="line">有特定主机路由：转发出去</span><br><span class="line">无特定主机路由：计算出网络前缀，接3、4</span><br><span class="line">目标地址与子网掩码按位与得到网络前缀，将此网络前缀与表项中目标网络地址作比较</span><br><span class="line">3 本地网络？-&gt; 本地递交</span><br><span class="line">4 非本地网络？-&gt; 查找有无表项与此网络前缀匹配</span><br><span class="line">找到了-&gt; 发往下一跳路由器</span><br><span class="line">找不到-&gt; 转发网默认路由的下一跳（若无默认路由，无法转发，报错）</span><br></pre></td></tr></table></div></figure>        <h2 id="转发表表项匹配方法"   >          <a href="#转发表表项匹配方法" class="heading-link"><i class="fas fa-link"></i></a>转发表表项匹配方法</h2>      <p>最长前缀匹配：<br>    表项中的子网掩码长的优先匹配</p>        <h2 id="IP地址和转发表"   >          <a href="#IP地址和转发表" class="heading-link"><i class="fas fa-link"></i></a>IP地址和转发表</h2>      <p>对于分组中字段的修改情况：<br>    1 大部分字段不改动，例如：不改动源地址和目标地址<br>    2 改变TTL，若TTL减一为零则丢弃，首部校验和会改变</p>        <h2 id="下一跳的IP地址如何存放？"   >          <a href="#下一跳的IP地址如何存放？" class="heading-link"><i class="fas fa-link"></i></a>下一跳的IP地址如何存放？</h2>      <p>（IP地址首部不存储下一跳节点的IP地址）</p><ul><li>存储在帧的首部目标物理地址字段</li></ul><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 即将被处理的IP地址交到网络接口上进行处理，</span><br><span class="line">2 IP地址通过ARP映射到物理地址，此物理地址是帧首部目标的IP地址（下一跳）</span><br><span class="line">3 将IP地址放到帧的数据区，构造完整的帧再将其发送出去</span><br><span class="line">4 丢弃下一跳地址</span><br></pre></td></tr></table></div></figure>        <h2 id="节点处理到来的IP分组"   >          <a href="#节点处理到来的IP分组" class="heading-link"><i class="fas fa-link"></i></a>节点处理到来的IP分组</h2>      <p>链路层将分组交给IP模块</p><ul><li>对于一个主机节点：<br>1 检查目标IP地址，匹配（转交高层<br>2 差错情况，丢弃</li><li>对于一个路由器节点：<br>IP分组首部的目标地址是否和路由器接口地址匹配？<br>1 匹配，转交处理（一般用于测试的环境<br>2 不匹配则转发，TTL-1，若TTL大于0重新计算首部和然后封装在帧中转发出去，否则丢弃</li></ul>        <h2 id="转发表的获取、初始化、更新"   >          <a href="#转发表的获取、初始化、更新" class="heading-link"><i class="fas fa-link"></i></a>转发表的获取、初始化、更新</h2>      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">……</span><br></pre></td></tr></table></div></figure><hr><p>参考资料：</p><ul><li>INTERNETWORKING WITH TCP/IP PRINCIPLES, PROTOCOLS, AND ARCHITECTURE Vol1 (6th Edition).  DOUGLASE E. COMER </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;IP协议：转发IP数据报&quot;   &gt;
          &lt;a href=&quot;#IP协议：转发IP数据报&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;IP协议：转发IP数据报&lt;/h1&gt;
    
    </summary>
    
      <category term="TCP/IP" scheme="https://acptek.github.io/categories/TCP-IP/"/>
    
    
      <category term="TCP/IP" scheme="https://acptek.github.io/tags/TCP-IP/"/>
    
      <category term="forwarding" scheme="https://acptek.github.io/tags/forwarding/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP IP协议</title>
    <link href="https://acptek.github.io/2020/07/03/TCP-IP-IP%E5%8D%8F%E8%AE%AE/"/>
    <id>https://acptek.github.io/2020/07/03/TCP-IP-IP协议/</id>
    <published>2020-07-03T10:19:48.000Z</published>
    <updated>2020-07-03T12:48:32.671Z</updated>
    
    <content type="html"><![CDATA[        <h1 id="IP协议"   >          <a href="#IP协议" class="heading-link"><i class="fas fa-link"></i></a>IP协议</h1>      <ul><li>无连接的协议</li><li>为上层通讯应用提供了最基本的服务</li></ul><a id="more"></a>        <h2 id="因特网设计的思想"   >          <a href="#因特网设计的思想" class="heading-link"><i class="fas fa-link"></i></a>因特网设计的思想</h2>              <h3 id="对用户而言"   >          <a href="#对用户而言" class="heading-link"><i class="fas fa-link"></i></a>对用户而言</h3>      <p>抽象成为一个单一的网络<br>与底层的物理网络无关，运行在任何物理网络之上</p>        <h3 id="从概念上划分层次"   >          <a href="#从概念上划分层次" class="heading-link"><i class="fas fa-link"></i></a>从概念上划分层次</h3>      <ul><li>应用层要求可靠传输服务</li><li>传输层提供增强的传输服务</li><li>网际层提供无连接的分组传递服务</li></ul>        <h2 id="IP的目的（主要功能）"   >          <a href="#IP的目的（主要功能）" class="heading-link"><i class="fas fa-link"></i></a>IP的目的（主要功能）</h2>      <p>1 定义了报文的基本单位<br>2 定义了分组的转发<br>3 定义传输中遵循的一些规则（处理主机、路由器……<br>    ICMP辅助处理差错</p>        <h2 id="因特网数据报（IP分组）格式"   >          <a href="#因特网数据报（IP分组）格式" class="heading-link"><i class="fas fa-link"></i></a>因特网数据报（IP分组）格式</h2>      <p>帧格式：包含一个首部、数据区、尾部。<br>IP数据报（datagram）格式：包含首部（Header）和数据区（Payload）</p>        <h3 id="IPv4报文格式"   >          <a href="#IPv4报文格式" class="heading-link"><i class="fas fa-link"></i></a>IPv4报文格式</h3>      <p><img src="http://acptek.gitee.io/blogpictures/TCPIP/Ch7_IPv4_Format.png" alt="IPv4报文格式"></p>        <h3 id="字段含义"   >          <a href="#字段含义" class="heading-link"><i class="fas fa-link"></i></a>字段含义</h3>      <ul><li>VERS:版本，4个bit</li><li>HLEN:首部长度，4个bit，以四个字节为一个单位(4*15)</li><li>Service Type:</li></ul><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">服务类型 , 8bit,</span><br><span class="line">0-2:Precedence  3:D（低延迟）  T:4（高吞吐量） R:5（高可靠性）</span><br><span class="line"></span><br><span class="line">改进：（补充 -&gt; 适应媒体流的传输</span><br><span class="line"></span><br><span class="line">IPv4 ToS</span><br><span class="line">IPv6 Traffic class</span><br><span class="line">Service Type：0-5 CODEPOINT(DSCP)</span><br><span class="line"></span><br><span class="line">区分服务代码点：DSCP</span><br><span class="line">对流量进行分类，给不同类别的流量以不同的优先级</span><br><span class="line">低两位为未使用，高三位定义优先级</span><br><span class="line">将高六位进行划分，管理池：</span><br><span class="line">pool1: xxxxx0可以定义32个类别，IETF来定义</span><br><span class="line">pool2: xxxx11用于本地或实验</span><br><span class="line">pool3: xxxx01用于本地或实验，可以用于扩充第一个组</span><br></pre></td></tr></table></div></figure><ul><li>Total Length:总长度</li><li>Identification:分组分片</li><li>Flags: DF（不允许分片）, MF（有更多分片）…</li><li>Fragment Offset:分片的偏移（重装的时候的偏移量），13bit，分片的长度取8的整数倍 &gt; offset的数值是除以 8的数值，因为8的倍数可以向左偏移三位，与Flags的3位错开</li><li>TTL:分组的生命期，8bit（实际用途用于跳数的限制</li><li>Protocol:上层协议的编号</li><li>Header Checksum:首部校验（求16进制反码和的反码）</li><li>Source IP Address</li><li>Destination IP Address</li><li>Payload</li></ul>        <h3 id="IPv6-报文格式"   >          <a href="#IPv6-报文格式" class="heading-link"><i class="fas fa-link"></i></a>IPv6 报文格式</h3>      <p><img src="http://acptek.gitee.io/blogpictures/TCPIP/Ch7_IPv6_Format.png" alt="IPv6报文格式"></p>        <h4 id="IPv6特点"   >          <a href="#IPv6特点" class="heading-link"><i class="fas fa-link"></i></a>IPv6特点</h4>      <ul><li>相比IPv4去掉了很多字段</li><li>基本首部固定长度</li></ul>        <h4 id="字段含义-1"   >          <a href="#字段含义-1" class="heading-link"><i class="fas fa-link"></i></a>字段含义</h4>      <ul><li><p>Next Header字段<br>基本首部和扩展首部都包含这样的字段</p><pre><code>基本首部</code></pre><p>​    扩展首部<br>通过Next Header将这些首部链在一起，例如<br>1 基本首部 + TCP报文段<br>2 基本首部 + 路由首部 + TCP报文段<br>3 基本首部 + 路由首部 + 认证首部 + TCP报文段</p></li></ul>        <h4 id="40个8位长度的IPv6固定长度基本首部格式"   >          <a href="#40个8位长度的IPv6固定长度基本首部格式" class="heading-link"><i class="fas fa-link"></i></a>40个8位长度的IPv6固定长度基本首部格式</h4>      <p><img src="http://acptek.gitee.io/blogpictures/TCPIP/Ch7_IPv6_BaseHeaderFromat.png" alt="IPv6基本首部格式"></p><ul><li>VERS</li><li>TRAFFIC CLASS : 对应v4的ToS</li><li>FLOW LABEL：        流的标识号，用于取代目标IP，中间转发是根据流的ID进行转发</li><li>PAYLOAD LENGTH：    不包括首部的40字节基本长度</li><li>NEXT HEADER ：        将首部串到一起（也可以用来指定上层的协议</li><li>HOP LIMIT：对应IPv4中的TTL</li><li>SOURCE ADDRESS 128bit</li><li>DST ADD 128bit</li></ul><p>​    </p>        <h2 id="物理网的最大传输单位-MTU"   >          <a href="#物理网的最大传输单位-MTU" class="heading-link"><i class="fas fa-link"></i></a>物理网的最大传输单位 MTU</h2>      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">太小：降低效率</span><br><span class="line">太大：分片问题</span><br><span class="line">例如：以太网 MTU&#x3D;1500</span><br></pre></td></tr></table></div></figure>        <h2 id="IP-分片"   >          <a href="#IP-分片" class="heading-link"><i class="fas fa-link"></i></a>IP 分片</h2>              <h3 id="IPv4分片"   >          <a href="#IPv4分片" class="heading-link"><i class="fas fa-link"></i></a>IPv4分片</h3>      <p>IPv4分片的大小是8的整数倍<br>IPv4在目标节点负责重装，中间路由器不负责重装</p>        <h3 id="IPv6-分片"   >          <a href="#IPv6-分片" class="heading-link"><i class="fas fa-link"></i></a>IPv6 分片</h3>      <p><img src="http://acptek.gitee.io/blogpictures/TCPIP/Ch7_IPv6_Fragment.png" alt="IPv6分片"></p><p>对于v6不允许中间的路由器分片，所以源站会先找出到目标站路径上的最小MTU</p><p>分片功能放到 扩展首部<br>规定只能在源主机进行分片，源到目标主机路径上的路由器不允许分片</p>        <h4 id="Path-MTU："   >          <a href="#Path-MTU：" class="heading-link"><i class="fas fa-link"></i></a>Path MTU：</h4>      <p>从源到目标所经过的所有链路上MTU中最小的MTU</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">找到 path MTU （PMTUD）, 主机同时周期性进行查询</span><br><span class="line">查询过程：二分试探，如果中间传输报文过大，则返回</span><br><span class="line">ICMPv6：Packet Too Big 报文</span><br><span class="line">ICMPv4：Dest Unreach 报错，（DF 设为 1）</span><br></pre></td></tr></table></div></figure>        <h4 id="IPv6-分片扩展首部-格式"   >          <a href="#IPv6-分片扩展首部-格式" class="heading-link"><i class="fas fa-link"></i></a>IPv6 分片扩展首部 格式</h4>      <p><img src="http://acptek.gitee.io/blogpictures/TCPIP/Ch7_IPv6_ExtensionHeader.png" alt="IPv6分片扩展首部格式"></p><ul><li>FRAGMENT OFFSET  13bit</li><li>MF 1bit</li><li>IDENTIFICATION: 标识号，32bit</li></ul>        <h4 id="IPv6-分片的重装"   >          <a href="#IPv6-分片的重装" class="heading-link"><i class="fas fa-link"></i></a>IPv6 分片的重装</h4>      <p>在目标进行重装，中间节点不进行重装</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">缺点：</span><br><span class="line">1 若MTU较大，引起效率低</span><br><span class="line">2 分片数量多后丢失的可能性较大</span><br><span class="line">优点：</span><br><span class="line">1 每个分片进行独立路由传输</span><br><span class="line">2 中间节点不需要进行存储</span><br></pre></td></tr></table></div></figure>        <h2 id="选项"   >          <a href="#选项" class="heading-link"><i class="fas fa-link"></i></a>选项</h2>      <p>源IP 和 目标IP<br>IPv4选项部分是可变长度的，需要进行填充，填到32bit为止</p><p>IPv4选项定义在首部：可变长，一般用来进行测试、调试<br>IPv6首部不包含选项：这些功能被移到了扩展首部</p>        <h3 id="IPv4-选项"   >          <a href="#IPv4-选项" class="heading-link"><i class="fas fa-link"></i></a>IPv4 选项</h3>      <p>（在实际通信中使用较少</p>        <h4 id="选项的组成："   >          <a href="#选项的组成：" class="heading-link"><i class="fas fa-link"></i></a>选项的组成：</h4>      <ul><li>option code：定义选项的类型</li><li>length：选项总长度</li><li>data：数据</li></ul>        <h4 id="选项-Option-code字段"   >          <a href="#选项-Option-code字段" class="heading-link"><i class="fas fa-link"></i></a>选项 Option code字段</h4>      <p>8bit</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0 ： copy</span><br><span class="line">copy &#x3D; 0：只有第一个带上原来分组的选项</span><br><span class="line">copy &#x3D; 1：在分片的时候所有分片需要带上选项</span><br><span class="line">1-2：Option Class</span><br><span class="line">分成了4类，0、2有定义，1、3保留</span><br><span class="line">option class &#x3D; 0：进行控制</span><br><span class="line">option class &#x3D; 1：调试与测试</span><br><span class="line">3-7：Option number</span><br></pre></td></tr></table></div></figure>        <h4 id="IPv4选项举例"   >          <a href="#IPv4选项举例" class="heading-link"><i class="fas fa-link"></i></a>IPv4选项举例</h4>      <ul><li><p>记录路由选项：</p><p><img src="http://acptek.gitee.io/blogpictures/TCPIP/Ch7_IPv4_OptionRecordRouter.png" alt="IPv4记录路由选项"></p><p>源站发出分组，初始化一个空地址列表，中间路由器在转发分组时依次加入IP地址</p></li><li><p>源路由选项 ：</p><p><img src="http://acptek.gitee.io/blogpictures/TCPIP/Ch7_IPv4_OptionSourceRouter.png" alt="IPv4源路由选项"></p><p>用于吞吐量测试</p></li><li><p>时间戳选项</p></li></ul>        <h3 id="IPv6-选项扩展"   >          <a href="#IPv6-选项扩展" class="heading-link"><i class="fas fa-link"></i></a>IPv6 选项扩展</h3>      <p><img src="http://acptek.gitee.io/blogpictures/TCPIP/Ch7_IPv6_ExtensionOption.png" alt="IPv6的一些扩展选项"></p><p><img src="http://acptek.gitee.io/blogpictures/TCPIP/Ch7_IPv6_ExtensionOptionFormat.png" alt="IPv6扩展选项格式"></p><hr><p>参考资料：</p><ul><li>INTERNETWORKING WITH TCP/IP PRINCIPLES, PROTOCOLS, AND ARCHITECTURE Vol1 (6th Edition).  DOUGLASE E. COMER </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;IP协议&quot;   &gt;
          &lt;a href=&quot;#IP协议&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;IP协议&lt;/h1&gt;
      &lt;ul&gt;
&lt;li&gt;无连接的协议&lt;/li&gt;
&lt;li&gt;为上层通讯应用提供了最基本的服务&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="TCP/IP" scheme="https://acptek.github.io/categories/TCP-IP/"/>
    
    
      <category term="TCP/IP" scheme="https://acptek.github.io/tags/TCP-IP/"/>
    
      <category term="IP" scheme="https://acptek.github.io/tags/IP/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP ARP协议</title>
    <link href="https://acptek.github.io/2020/07/03/TCP-IP-ARP%E5%8D%8F%E8%AE%AE/"/>
    <id>https://acptek.github.io/2020/07/03/TCP-IP-ARP协议/</id>
    <published>2020-07-03T10:15:51.000Z</published>
    <updated>2020-07-03T12:55:27.936Z</updated>
    
    <content type="html"><![CDATA[        <h1 id="ARP-协议-—-将IP地址映射成物理地址"   >          <a href="#ARP-协议-—-将IP地址映射成物理地址" class="heading-link"><i class="fas fa-link"></i></a>ARP 协议  —  将IP地址映射成物理地址</h1>      <p>分组带上发送者和接收者地址<br>在帧的首部填上物理地址</p><p>问题描述，A和B进行通信<br>A   —-   B<br>Ia  —-  Ib<br>Pa  —-  Pb</p><p>一般问题<br>    1 源和目标在同一网段<br>    2 源和目标由路由器相连（跨多个网络）</p><a id="more"></a>            <h2 id="物理地址-硬件地址-类型"   >          <a href="#物理地址-硬件地址-类型" class="heading-link"><i class="fas fa-link"></i></a>物理地址/硬件地址 类型</h2>      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">IPv4 总空间32位，无法容纳一个MAC地址</span><br><span class="line"></span><br><span class="line">在IPv4上的地址映射举例：</span><br><span class="line">1 proNET &#x3D;&gt; 接口卡上的开关可以拨动，只有8bit</span><br><span class="line">--&gt; 直接地址映射</span><br><span class="line">例如，在IPv4&#x2F;IPv6中可以直接映射实现</span><br><span class="line">配置方案：在IP地址的主机号部分进行一一对应</span><br><span class="line"></span><br><span class="line">2 Ethernet &#x3D;&gt; 48位物理地址，无法装载</span><br><span class="line">--&gt; 动态绑定法：</span><br><span class="line">ARP协议：先向地址广播一个ARP请求，目标匹配自身IP地址响应ARP请求</span><br><span class="line">跨网发生在每一个子网内</span><br><span class="line"></span><br><span class="line">不直接广播IP地址方式的原因：</span><br><span class="line">1 广播不会跨网</span><br><span class="line">2 浪费资源</span><br><span class="line">ARP采用广播方式开销大</span><br></pre></td></tr></table></div></figure>        <h2 id="ARP-Cache：改善ARP性能"   >          <a href="#ARP-Cache：改善ARP性能" class="heading-link"><i class="fas fa-link"></i></a>ARP Cache：改善ARP性能</h2>      <p>先保存目标IP的物理地址，可以使得下一次不需要发起一次ARP请求<br>表项：<br>    -&gt; IP , MAC<br>    -&gt; TTY<br>维护：使用定时器（典型的生命期是20min，超时删去）</p><p>软状态：匿名（当信息发生改变/过时的时候，不会告知相关的节点）<br>缺点：延迟时间较长，例如在出现节点崩溃的情况需要等到节点不活跃时期（到生命期）</p>        <h2 id="改进ARP："   >          <a href="#改进ARP：" class="heading-link"><i class="fas fa-link"></i></a>改进ARP：</h2>      <ul><li>被查询的机器若收到请求则添加到自己的Cache中，所有的本网的节点都收到ARP请求，发送者的地址信息则在本网站点中都更新</li><li>同时，机器在崩溃重启的时候向外发送一个ARP请求，此时原先的节点会对自己的表项做一个更新</li></ul>        <h2 id="关于地址映射："   >          <a href="#关于地址映射：" class="heading-link"><i class="fas fa-link"></i></a>关于地址映射：</h2>      <p>​    1 ARP只是其中的一种方案，并非所有网络都需要此过程<br>​    2 ARP的解析属于底层技术，属于底层物理网络有关的部分</p>        <h1 id="ARP-实现"   >          <a href="#ARP-实现" class="heading-link"><i class="fas fa-link"></i></a>ARP 实现</h1>              <h2 id="ARP功能的分类"   >          <a href="#ARP功能的分类" class="heading-link"><i class="fas fa-link"></i></a>ARP功能的分类</h2>      <ul><li>地址的映射</li><li>响应ARP请求</li></ul>        <h2 id="ARP过程中的一些分析"   >          <a href="#ARP过程中的一些分析" class="heading-link"><i class="fas fa-link"></i></a>ARP过程中的一些分析</h2>      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 当用户发送一个报文的时候，需要对地址进行映射；</span><br><span class="line">ARP使用cache技术，如果在cache中能够找到地址对，就直接使用；如果找不到，则发送ARP请求。（在发送ARP请求后可能得不到响应，1 请求丢失，2 目标主机处于关机状态）</span><br><span class="line">2 发送分组后，在地址解析成功之前分组先被存储到缓冲队列当中（即一个应用还在运行的过程中），如果系统上同时有多个应用都需要解析这样的地址，底层ARP模块要确保不能产生多个这样的请求。</span><br><span class="line">3 当ARP响应返回的时候</span><br><span class="line">3.1 需要对ARP Cache进行更新</span><br><span class="line">3.2 上层等待传输的分组得到地址解析结果后，从队列中移除</span><br><span class="line">4 收到ARP请求后，进行响应</span><br><span class="line">4.1 从请求报文抽取发送方信息（发送方的IP地址和物理地址），更新本地Cache</span><br><span class="line">4.2 处理分组（响应&#x2F;丢弃）</span><br></pre></td></tr></table></div></figure>        <h2 id="ARP的封装关系"   >          <a href="#ARP的封装关系" class="heading-link"><i class="fas fa-link"></i></a>ARP的封装关系</h2>      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">封装在链路层 帧的数据区中</span><br><span class="line">报文TYPE ： 0806H</span><br></pre></td></tr></table></div></figure>        <h2 id="ARP-报文格式"   >          <a href="#ARP-报文格式" class="heading-link"><i class="fas fa-link"></i></a>ARP 报文格式</h2>      <ul><li><p><strong>非定长格式</strong><br>因为不同的物理网络报文的长度，格式不一样；网络层上的地址也有多种不同类型的地址，格式也可能不一样</p></li><li><p><strong>在以太网中的报文格式</strong> </p><p><img src="http://acptek.gitee.io/blogPictures/TCPIP/Ch6_Ethernet_ARP_MessageFormat.png" alt="以太网报文格式"></p><p>Sender HA  6字节（物理地址）<br>Sender IP  4字节（IP地址）<br>Target HA （目标物理地址）<br>Target IP （目标IP地址）</p><p>HARDWARE TYPE：以太网MAC地址，类型值为1<br>PROTOCOL TYPE：表示网络层的协议类型，以太网0x0800<br>OPERATION：报文类型</p><pre><code>1 ：ARP请求2 ：ARP响应3 ：RARP请求4 ：RARP响应</code></pre></li></ul>        <h2 id="自动缓存再检验"   >          <a href="#自动缓存再检验" class="heading-link"><i class="fas fa-link"></i></a>自动缓存再检验</h2>              <h3 id="Jitter-抖动现象"   >          <a href="#Jitter-抖动现象" class="heading-link"><i class="fas fa-link"></i></a>Jitter 抖动现象</h3>      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指连续传输的分组从一个站传输到另一个站，接受分组的延迟时间有变化</span><br><span class="line">当传输延迟很大时，对某些应用（多媒体应用）造成很大影响</span><br><span class="line">所以，需要避免这种抖动。</span><br></pre></td></tr></table></div></figure>        <h3 id="ARP造成的抖动："   >          <a href="#ARP造成的抖动：" class="heading-link"><i class="fas fa-link"></i></a>ARP造成的抖动：</h3>      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cache表项中包含和cache表项中映射由于定时器超时失效；当失效时需要重新发起一次ARP请求需要额外的时间解析。</span><br></pre></td></tr></table></div></figure>        <h3 id="解决方法：early-revalidation（早期再检验）"   >          <a href="#解决方法：early-revalidation（早期再检验）" class="heading-link"><i class="fas fa-link"></i></a>解决方法：early revalidation（早期再检验）</h3>      <ul><li>解决思路：<br>减少分组传输中的抖动：延迟时间的变化值</li><li>方案：<br>另外设置一个定时器（每个表项都设置一个）：<br>重新验证定时器，超时间隔比原先计时器小一些，如果响应还存在，则重新复位计时器</li></ul>        <h2 id="RARP-RARP-gt-BOOTP-gt-DHCP"   >          <a href="#RARP-RARP-gt-BOOTP-gt-DHCP" class="heading-link"><i class="fas fa-link"></i></a>RARP  |  RARP -&gt; BOOTP -&gt; DHCP</h2>      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">已知物理地址，求对应的IP地址（是一个反向的地址映射）</span><br><span class="line"></span><br><span class="line">针对无硬盘系统:</span><br><span class="line">本地的局域网安装一个RARP服务器，包含一个地址对的数据库，有管理员人工配置绑定表</span><br><span class="line"></span><br><span class="line">以太网：ARP  0x0806</span><br><span class="line">                            RARP 0x8035</span><br><span class="line"></span><br><span class="line">应用场景：虚拟机从一个IP迁移到另一个IP</span><br></pre></td></tr></table></div></figure>        <h2 id="ARP-Cache-在3层交换机上的实现"   >          <a href="#ARP-Cache-在3层交换机上的实现" class="heading-link"><i class="fas fa-link"></i></a>ARP Cache 在3层交换机上的实现</h2>      <ul><li>目标：<br>减少ARP的流量</li><li>实现举例：<br>A向B发送一个ARP请求<br>交换机先收到A发的ARP请求，查询自己的Cache，若有B的物理地址则向A发送响应（相当于一个代理，一个节流的过程）</li></ul>        <h2 id="代理ARP"   >          <a href="#代理ARP" class="heading-link"><i class="fas fa-link"></i></a>代理ARP</h2>      <ul><li>作用：<br>将一个IP网络映射到两个物理的网络地址（两个或多个不同的物理子网）</li><li>使用范围：<br>应用于使用ARP的网络环境中</li><li>分析：<br>运行代理ARP的路由采用了一种说谎的方式<br>1 利用了ARP协议之间的信任<br>2 需要在地址绑定表中插入，在安装的时候合法性与一致性都存在问题<br>3 具体实现上的安全问题，例如Spoofing欺骗</li><li>spoofing欺骗：<br>例如：三台机器A，B，C连在一个网络中，A和B通信，C是入侵者，C要截取A和B间的通信。C监听ARP请求，获取到A和B的IP地址和MAC地址，那么此时C可以向B发送ARP请求：IP地址是A的，MAC地址是C的；同样，发给A时IP地址是B，MAC地址是C的；（发送多次才能奏效）；此时，促使了A和B修改了它们的ARP表项。所以A和B中的通信都经过C。</li><li>不同的IP地址对应一个同一个物理地址<br>优点：加进一个单独的路由器不会影响网络中的其他节点<br>缺点：1只用于ARP地址解析的场景下 2不适用于复杂的网络 3不支持合理的路由表（受控管理的规模有限）</li></ul>        <h2 id="IPv6-邻居发现协议"   >          <a href="#IPv6-邻居发现协议" class="heading-link"><i class="fas fa-link"></i></a>IPv6 邻居发现协议</h2>      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 IP地址是邻居发现协议（NDP）中的一项功能</span><br><span class="line">2 在传输的时候封装在 ICMPv6中</span><br><span class="line">3 一般在系统启动过程中执行NDP协议</span><br><span class="line">4 一个节点需要周期性的连续的检测邻居的状态</span><br><span class="line">5 使用多播</span><br><span class="line">6 NDP使用solicited-node（被恳求节点）多播地址</span><br></pre></td></tr></table></div></figure><hr><p>参考资料：</p><ul><li>INTERNETWORKING WITH TCP/IP PRINCIPLES, PROTOCOLS, AND ARCHITECTURE Vol1 (6th Edition).  DOUGLASE E. COMER </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ARP-协议-—-将IP地址映射成物理地址&quot;   &gt;
          &lt;a href=&quot;#ARP-协议-—-将IP地址映射成物理地址&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;ARP 协议  —  将IP地址映射成物理地址&lt;/h1&gt;
      &lt;p&gt;分组带上发送者和接收者地址&lt;br&gt;在帧的首部填上物理地址&lt;/p&gt;
&lt;p&gt;问题描述，A和B进行通信&lt;br&gt;A   —-   B&lt;br&gt;Ia  —-  Ib&lt;br&gt;Pa  —-  Pb&lt;/p&gt;
&lt;p&gt;一般问题&lt;br&gt;    1 源和目标在同一网段&lt;br&gt;    2 源和目标由路由器相连（跨多个网络）&lt;/p&gt;
    
    </summary>
    
      <category term="TCP/IP" scheme="https://acptek.github.io/categories/TCP-IP/"/>
    
    
      <category term="TCP/IP" scheme="https://acptek.github.io/tags/TCP-IP/"/>
    
      <category term="ARP" scheme="https://acptek.github.io/tags/ARP/"/>
    
      <category term="RARP" scheme="https://acptek.github.io/tags/RARP/"/>
    
      <category term="ARP Proxy" scheme="https://acptek.github.io/tags/ARP-Proxy/"/>
    
      <category term="NDP" scheme="https://acptek.github.io/tags/NDP/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP 因特网的寻址方案</title>
    <link href="https://acptek.github.io/2020/07/03/TCP-IP-%E5%9B%A0%E7%89%B9%E7%BD%91%E7%9A%84%E5%AF%BB%E5%9D%80%E6%96%B9%E6%A1%88/"/>
    <id>https://acptek.github.io/2020/07/03/TCP-IP-因特网的寻址方案/</id>
    <published>2020-07-03T10:12:32.000Z</published>
    <updated>2020-07-03T12:56:17.789Z</updated>
    
    <content type="html"><![CDATA[        <h1 id="因特网的寻址方案"   >          <a href="#因特网的寻址方案" class="heading-link"><i class="fas fa-link"></i></a>因特网的寻址方案</h1>      <a id="more"></a>        <h3 id="1-标识一台主机"   >          <a href="#1-标识一台主机" class="heading-link"><i class="fas fa-link"></i></a>1 标识一台主机</h3>      <p>​    名字 -&gt; 对象是什么<br>​    地址 -&gt; 对象在哪里<br>​    路径 -&gt; 如何到达对象<br>​    （通过IP地址来进行标识）</p>        <h3 id="2-早期的IP地址方案"   >          <a href="#2-早期的IP地址方案" class="heading-link"><i class="fas fa-link"></i></a>2 早期的IP地址方案</h3>              <h4 id="有类别的地址方案"   >          <a href="#有类别的地址方案" class="heading-link"><i class="fas fa-link"></i></a>有类别的地址方案</h4>      <p>长度 32bit -&gt; 对应一个32位的整数 （网络号+主机号）</p>        <h4 id="地址分类：ABCDE，D类为广播地址，E类为保留地址"   >          <a href="#地址分类：ABCDE，D类为广播地址，E类为保留地址" class="heading-link"><i class="fas fa-link"></i></a>地址分类：ABCDE，D类为广播地址，E类为保留地址</h4>      <p>定义的是主机和一个网络的连接，（例如多接口主机需要多个IP地址）</p><p>IP地址不是指定具体一台地址，而是连接到网卡的一条路径</p><p>具体表示：点分十进制，<br>类别    低地址        高地址<br>A      1.0.0.0        127.0.0.0<br>B    128.0.0.0    191.255.0.0<br>C    192.0.0.0    223.255.255.0<br>D    224.0.0.0    239.255.255.255<br>E    240.0.0.0    255.255.255.254</p>        <h4 id="地址的特殊类别："   >          <a href="#地址的特殊类别：" class="heading-link"><i class="fas fa-link"></i></a>地址的特殊类别：</h4>      <p>​    1 单播：（不能作为目标地址来使用）<br>​        hostid全为零：本网的网络地址<br>​    2 广播：（不能作为源地址来使用）<br>​        netid确定情况下hostid全为1：定向广播地址<br>​        32位全为1：本网有限广播。（在系统启动时若还没得到网络号可以使用此地址进行广播，若得到网络号则用定向广播地址）<br>​        32位全为0：保留地址（在初始化时节点还未获取IP地址则如此表示）<br>​    3 多播：（多播是将分组传送到一个指定的主机集合<br>​        loopback（不能上线，逻辑分配的地址，仅在主机内部做测试）</p>        <h4 id="地址方案缺陷："   >          <a href="#地址方案缺陷：" class="heading-link"><i class="fas fa-link"></i></a>地址方案缺陷：</h4>      <p>​    一台主机从一个网络移动到另一个网络，则它的地址需要重新分配。<br>​    网络地址数量太多。<br>​    分类地址规模固定。<br>​    主机由多个接口时，通信报文传输路径由多条</p>        <h3 id="3-网络字节顺序"   >          <a href="#3-网络字节顺序" class="heading-link"><i class="fas fa-link"></i></a>3 网络字节顺序</h3>      <p>​    大端存储和小端存储<br>​    因特网中的传输规则：<br>​        多个字节的整数，采用大端的形式</p>        <h3 id="4-IPv4子网地址"   >          <a href="#4-IPv4子网地址" class="heading-link"><i class="fas fa-link"></i></a>4 IPv4子网地址</h3>              <h4 id="子网划分（将原来两部分的地址划分成了三部分的地址，是一个分层的结构）"   >          <a href="#子网划分（将原来两部分的地址划分成了三部分的地址，是一个分层的结构）" class="heading-link"><i class="fas fa-link"></i></a>子网划分（将原来两部分的地址划分成了三部分的地址，是一个分层的结构）</h4>      <p>网络号：因特网部分<br>主机号：本地部分<br>    取其中一部分bit出来 来区分本地的不同的物理网络，可以将这一部分看成网络的子网号，剩余部分为主机号</p>        <h4 id="可变长的子网划分-VLSM"   >          <a href="#可变长的子网划分-VLSM" class="heading-link"><i class="fas fa-link"></i></a>可变长的子网划分 VLSM</h4>      <p>​    背景问题：一个机构内部的网络规模不一样，不同局域网中的主机数量不同。此时，固定长度的子网划分的方法不适用。所以使用可变长的子网划分方法，大的网络的主机号多一些子网号部分少一些，小的网络号反之。<br>​    缺点：管理员设计不当可能导致地址重复使用<br>​    优点：可以支持大小网络混合的环境，可以提高地址的利用率</p><p>注：VLSM中全0全1地址是可用的，区别于单纯的子网划分</p>        <h4 id="子网掩码（用于指定子网划分）"   >          <a href="#子网掩码（用于指定子网划分）" class="heading-link"><i class="fas fa-link"></i></a>子网掩码（用于指定子网划分）</h4>      <p>长度：32bit<br>设定规则：对应IP地址子网部分的bit取1，对应主机地址的部分取0<br>说明：子网掩码和IP地址的类别无关</p><p>记法：（两种表示方法）<br>    1 三元组（网络号，子网号，主机号）<br>            缺点：无法得知子网号与主机号的位数<br>            优点：屏蔽底层细节<br>    2 as/24 (CIDR)：整数值为网络号与子网号的位数</p>        <h3 id="5-目标：最小化网络数量"   >          <a href="#5-目标：最小化网络数量" class="heading-link"><i class="fas fa-link"></i></a>5 目标：最小化网络数量</h3>      <p>1 对于一个路由表，网络数量增加路由表项也会增加，当增加到一定数量之后路由器无法承受<br>2 地址的消耗问题，尤其是B类地址</p>        <h4 id="解决方案："   >          <a href="#解决方案：" class="heading-link"><i class="fas fa-link"></i></a>解决方案：</h4>      <p>​    无类别的寻址方案：CIDR -&gt; 无类别域间路由<br>​        1 减少路由表的表项数量<br>​        2 分配不均<br>​        </p>        <h4 id="CIDR的最初应用："   >          <a href="#CIDR的最初应用：" class="heading-link"><i class="fas fa-link"></i></a>CIDR的最初应用：</h4>      <p>​    超网分配方案：以多个连续用的C类地址的块来连成一块B类<br>​<br>​    </p>        <h4 id="CIDR记法："   >          <a href="#CIDR记法：" class="heading-link"><i class="fas fa-link"></i></a>CIDR记法：</h4>      <p>​    斜杠记法，例如 128.211.168.0/21，其中/21表示掩码的21位<br>​    </p>        <h4 id="CIDR和VLSM的区别"   >          <a href="#CIDR和VLSM的区别" class="heading-link"><i class="fas fa-link"></i></a>CIDR和VLSM的区别</h4>      <blockquote><p>在使用CIDR聚合地址时，将原来有类IP地址中的网络位划出一部分作为主机位使用。<br>在使用VLSM划分子网时，将原来有类IP地址中的主机位按照需要划出一部分作为网络位使用。<br>CIDR是把几个有类网络合成一个大的网络（超网），用于路由地址聚合。<br>VLSM是把一个有类网络分成几个小型网络（子网），用于更高效划分子网。</p></blockquote>        <h3 id="IPv6寻址方案"   >          <a href="#IPv6寻址方案" class="heading-link"><i class="fas fa-link"></i></a>IPv6寻址方案</h3>              <h4 id="IPv6记法："   >          <a href="#IPv6记法：" class="heading-link"><i class="fas fa-link"></i></a>IPv6记法：</h4>      <p>采用冒号分十六进制记法<br>将128位地址平均分成8组，每组16位<br>全为零的一组可以直接记成0<br>零压缩记法： 连续全零组记为 :: ，在一个地址中最多只能出现1次<br>CIDR表示：例如 FF05::03/60</p>        <h4 id="IPv6地址空间"   >          <a href="#IPv6地址空间" class="heading-link"><i class="fas fa-link"></i></a>IPv6地址空间</h4>      <p>前缀            地址类型            地址空间分片<br>010            全局单播地址        1/8<br>1111111010    本地链路单播地址    1/1024<br>11111111    多播地址            1/256</p>        <h4 id="从IPv4到IPv6的迁移"   >          <a href="#从IPv4到IPv6的迁移" class="heading-link"><i class="fas fa-link"></i></a>从IPv4到IPv6的迁移</h4>      <p>​    高64位全零，中间两个16位为0000和FFFF，低32位是IPv4地址</p>        <h4 id="IPv6单播地址"   >          <a href="#IPv6单播地址" class="heading-link"><i class="fas fa-link"></i></a>IPv6单播地址</h4>      <p>​    高N位为全球路由前缀，中间（64-N）位是子网号，最后64位是接口号</p>        <h4 id="IPv6接口标识和MAC地址"   >          <a href="#IPv6接口标识和MAC地址" class="heading-link"><i class="fas fa-link"></i></a>IPv6接口标识和MAC地址</h4>      <p>将MAC地址映射成64位接口ID：格式命名为EUI-64</p><p>将48位MAC地址映射成EUI-64：<br>    （MAC地址：    高24位代表厂家，表示一个机构的唯一标识符，低24位为厂家分配，是接口地址）<br>    1 在MAC地址的高24位和低24位之间插入一个16位的，15个1和1个0（FFFE）<br>    2 将Bit6从原来的0改成1<br>    Bit1：G/L位，表示地址是local的还是global的，一般情况下使用的是global地址为0，所以将此0改为1<br>    Bit0：I/G位，用来表示地址是单播地址还是组播地址<br>全局地址：48位地址<br>局部地址：16位地址</p>        <h4 id="IPv6多播和任播地址"   >          <a href="#IPv6多播和任播地址" class="heading-link"><i class="fas fa-link"></i></a>IPv6多播和任播地址</h4>              <h5 id="IPv6中没有广播，通过多播的方式来解决"   >          <a href="#IPv6中没有广播，通过多播的方式来解决" class="heading-link"><i class="fas fa-link"></i></a>IPv6中没有广播，通过多播的方式来解决</h5>      <p>广播的缺点：<br>    1 浪费的资源多<br>    2 广播一般情况下不跨网<br>所以IPv6采用多播来取代广播</p><p>协议中预先定义的一些保留的多播组：<br>    all routers ： 网上的所有路由器节点<br>    all hosts ： 网段上的所有主机节点<br>    all nodes ： 所有节点</p>        <h4 id="IPv6-Anycast地址"   >          <a href="#IPv6-Anycast地址" class="heading-link"><i class="fas fa-link"></i></a>IPv6 Anycast地址</h4>      <p>本质上是一个单播地址<br>作用：处理多服务器的情况（handle server replication）<br>    这些服务器以一个逻辑的整体对外提供服务；服务器所有的配置、提供的功能和对外提供的任播地址都是一样的。当用户在访问这些服务器的时候，使用Anycast地址去访问，最后解析出来的地理位置上距离最近的服务器上进行通信。</p><p>典型应用例如：DNS服务器</p>        <h4 id="IPv6-Link-Local-地址"   >          <a href="#IPv6-Link-Local-地址" class="heading-link"><i class="fas fa-link"></i></a>IPv6 Link-Local 地址</h4>      <p>用于本地局部使用，不是一个全局地址<br>节点在初始启动时，自动得到一个Link-Local地址</p><p>Link-Local地址的类别：<br>    由最高的10位来决定： 1111 1110 10</p><p>分组中带有Link-Local地址，报文不会被转发到不同的网络上去。Link-Local地址只局限在接口所在的网段中。</p>        <h4 id="IPv6中接口自动获取地址"   >          <a href="#IPv6中接口自动获取地址" class="heading-link"><i class="fas fa-link"></i></a>IPv6中接口自动获取地址</h4>      <p>1 OS启动激活接口<br>2 构造Link-Local地址<br>3 从48位转换为EUI-64得到接口ID，作为低64位，高10位是Link-Local地址，中间54位全为0<br>4 得到此接口上的linklocal地址，接口可以通过此地址与本地链路上的其他节点进行通信<br>5 本地链路中的路由器向外发送一条路由恳求，路由器返回通告包括：全局单播地址的前缀<br>6 全局前缀加上接口ID最终得到全局单播地址</p><hr><p>参考资料：</p><ul><li>INTERNETWORKING WITH TCP/IP PRINCIPLES, PROTOCOLS, AND ARCHITECTURE Vol1 (6th Edition).  DOUGLASE E. COMER </li><li>Understanding IPv6 ,Your Essential Guide to IPv6 on Windows Networks 3rd(2012) .  Joseph Davies.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;因特网的寻址方案&quot;   &gt;
          &lt;a href=&quot;#因特网的寻址方案&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;因特网的寻址方案&lt;/h1&gt;
    
    </summary>
    
      <category term="TCP/IP" scheme="https://acptek.github.io/categories/TCP-IP/"/>
    
    
      <category term="TCP/IP" scheme="https://acptek.github.io/tags/TCP-IP/"/>
    
      <category term="因特网寻址方案" scheme="https://acptek.github.io/tags/%E5%9B%A0%E7%89%B9%E7%BD%91%E5%AF%BB%E5%9D%80%E6%96%B9%E6%A1%88/"/>
    
      <category term="子网划分" scheme="https://acptek.github.io/tags/%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86/"/>
    
      <category term="VLSM" scheme="https://acptek.github.io/tags/VLSM/"/>
    
      <category term="CIDR" scheme="https://acptek.github.io/tags/CIDR/"/>
    
      <category term="IPv6寻址方案" scheme="https://acptek.github.io/tags/IPv6%E5%AF%BB%E5%9D%80%E6%96%B9%E6%A1%88/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP 协议分层</title>
    <link href="https://acptek.github.io/2020/07/03/TCP-IP-%E5%8D%8F%E8%AE%AE%E5%88%86%E5%B1%82/"/>
    <id>https://acptek.github.io/2020/07/03/TCP-IP-协议分层/</id>
    <published>2020-07-03T10:10:30.000Z</published>
    <updated>2020-07-03T12:49:12.052Z</updated>
    
    <content type="html"><![CDATA[        <h1 id="协议分层"   >          <a href="#协议分层" class="heading-link"><i class="fas fa-link"></i></a>协议分层</h1>      <ul><li>节点（主机、路由器）上的软件结构</li><li>分层的基本原理</li><li>IP的实现软件通过分层后便于理解</li><li>在此协议架构上，分组传递的路径</li></ul><a id="more"></a>        <h3 id="1-分层的原因"   >          <a href="#1-分层的原因" class="heading-link"><i class="fas fa-link"></i></a>1 分层的原因</h3>      <p>协议需要解决的问题：<br>    1 硬件故障<br>    2 网络拥塞<br>    3 分组丢失<br>    4 延迟<br>    5 数据污染<br>    6 数据包重复、乱序<br>    ……<br>所以需要分成子问题，再分别对子问题进行解决</p>        <h3 id="2-分层的基本原理"   >          <a href="#2-分层的基本原理" class="heading-link"><i class="fas fa-link"></i></a>2 分层的基本原理</h3>              <h4 id="ISO-7-layer-没有具体的实现-X-25-（数字通信，非模拟）"   >          <a href="#ISO-7-layer-没有具体的实现-X-25-（数字通信，非模拟）" class="heading-link"><i class="fas fa-link"></i></a>ISO 7-layer  (没有具体的实现) - X.25 - （数字通信，非模拟）</h4>      <p>​    物理层：        主机需要与分组交换机连接，（串形线<br>​    数据链路层：        主机与分组交换机之间传输数据（帧，校验与确认<br>​    网络层：        定义传输的基本单位（分组 -&gt; 分成几个帧进行传输，处理拥塞问题）<br>​    传输层：        提供端到端的可靠传输 double check<br>​    会话层：        处理远程终端接入<br>​    表示层：        为应用层提供服务（语法转换、数据压缩加密、格式转换等<br>​    应用层：        用户使用的最终目标</p><p>（复杂功能定义在网络核心上）</p>        <h4 id="TCP-IP-5-layer（层与层之间的接口-gt-消息，传输分组，IP数据报，帧）"   >          <a href="#TCP-IP-5-layer（层与层之间的接口-gt-消息，传输分组，IP数据报，帧）" class="heading-link"><i class="fas fa-link"></i></a>TCP/IP 5-layer（层与层之间的接口 -&gt; 消息，传输分组，IP数据报，帧）</h4>      <p>​    应用层：        应用，（根据自身需求选择传输服务，提供报文的序号，确保传输顺序或是连续的流（流服务）<br>​    传输层：        端到端的可靠通信<br>​    网络层：        主机到主机间的通信（传递IP分组，使用路由算法转发）<br>​            （一个节点收到IP分组后：检查IP分组的合法性，选择路由输出接口，ICMP协议报文交换）<br>​    网络接口层：         将网络层交付来的IP分组在具体的物理网络上传输 （例如在局域网使用MAC协议）</p><p>（网络的核心功能相对较弱，主要智能部分在传输层以上部分）</p>        <h3 id="TCPIP分层传输的两种模型："   >          <a href="#TCPIP分层传输的两种模型：" class="heading-link"><i class="fas fa-link"></i></a>TCPIP分层传输的两种模型：</h3>      <p>1 端到端 （分层原理：接收方收到的东西与发送方收到的东西完全一致）<br>    高层协议（网际层以上的部分</p><p>2 机器到机器<br>    网际层（IP分组在进过路由转发TTL时，会减1，发生的数据的改变，所以也是机器到机器<br>    低层（网际层以下</p>        <h3 id="分层的缺点："   >          <a href="#分层的缺点：" class="heading-link"><i class="fas fa-link"></i></a>分层的缺点：</h3>      <p>效率降低（解决效率问题是跨层优化问题的解决方案） </p>        <h3 id="多路复用-和-解多路复用"   >          <a href="#多路复用-和-解多路复用" class="heading-link"><i class="fas fa-link"></i></a>多路复用 和 解多路复用</h3>      <p>上层向下层递交的时候会添加信息，是用来解多路复用的依据</p><p>说明：</p><p>​    1 链路层上的传输基本单位为帧，帧的TYPE字段是作为解多路复用的依据。</p><p>​        例如，TYPE=0x800-&gt;IP, TYPE=0x806-&gt;ARP, TYPE=0x8035-&gt;RARP</p><p>​    2 网络层上传输的IP报文中，首部Protocol字段作为解多路复用的依据。</p><p>​        例如，protocol=1-&gt;ICMP, protocol=17-&gt;UDP, protocol=6-&gt;TCP</p><p>​    3 传输层上的TCP/UDP报文根据目标端口号来解多路复用，对应到特定的应用。</p><hr><p>参考资料：</p><ul><li>INTERNETWORKING WITH TCP/IP PRINCIPLES, PROTOCOLS, AND ARCHITECTURE Vol1 (6th Edition).  DOUGLASE E. COMER </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;协议分层&quot;   &gt;
          &lt;a href=&quot;#协议分层&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;协议分层&lt;/h1&gt;
      &lt;ul&gt;
&lt;li&gt;节点（主机、路由器）上的软件结构&lt;/li&gt;
&lt;li&gt;分层的基本原理&lt;/li&gt;
&lt;li&gt;IP的实现软件通过分层后便于理解&lt;/li&gt;
&lt;li&gt;在此协议架构上，分组传递的路径&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="TCP/IP" scheme="https://acptek.github.io/categories/TCP-IP/"/>
    
    
      <category term="TCP/IP" scheme="https://acptek.github.io/tags/TCP-IP/"/>
    
      <category term="协议分层" scheme="https://acptek.github.io/tags/%E5%8D%8F%E8%AE%AE%E5%88%86%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP 底层网络技术概述</title>
    <link href="https://acptek.github.io/2020/07/03/TCP-IP-%E5%BA%95%E5%B1%82%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0/"/>
    <id>https://acptek.github.io/2020/07/03/TCP-IP-底层网络技术概述/</id>
    <published>2020-07-03T09:57:36.000Z</published>
    <updated>2020-07-03T12:48:54.778Z</updated>
    
    <content type="html"><![CDATA[        <h1 id="底层网络技术概述"   >          <a href="#底层网络技术概述" class="heading-link"><i class="fas fa-link"></i></a>底层网络技术概述</h1>      <ul><li>分组交换技术</li><li>底层硬件技术</li></ul><a id="more"></a>        <h3 id="网络通信的两种解决方法"   >          <a href="#网络通信的两种解决方法" class="heading-link"><i class="fas fa-link"></i></a>网络通信的两种解决方法</h3>      <p>​    1 面向连接 ： 电路交换 circuit switch，（永久性连接，是专用连接<br>​        优点：保证网络的带宽<br>​        缺点：代价高</p><p>​    2 无连接 ： 分组交换网络 packet switch<br>​        优点：代价低<br>​        缺点：无法保证网络带宽，但是可以通过构建高带宽的分组交换网络</p>        <h3 id="网络分类（覆盖范围"   >          <a href="#网络分类（覆盖范围" class="heading-link"><i class="fas fa-link"></i></a>网络分类（覆盖范围</h3>      <p>​    WAN<br>​    LAN</p>        <h3 id="网络硬件地址"   >          <a href="#网络硬件地址" class="heading-link"><i class="fas fa-link"></i></a>网络硬件地址</h3>      <p>​    不同网络类型的地址格式有差别<br>​    四种应用的网络<br>​        以太网 Ethernet<br>​        无线局域网 Wi-Fi<br>​        ZigBee<br>​        同步光纤网 SONET</p>        <h3 id="以太网"   >          <a href="#以太网" class="heading-link"><i class="fas fa-link"></i></a>以太网</h3>      <p>​    分组交换式的局域网<br>​    DIX -&gt; IEEE802.3</p>        <h4 id="以太网不同的媒体方案："   >          <a href="#以太网不同的媒体方案：" class="heading-link"><i class="fas fa-link"></i></a>以太网不同的媒体方案：</h4>      <ul><li>1 粗同轴电缆：10Base5 （10Mbps 500m）<br>收发器transceiver连在电缆上，网卡（网络接口卡）连在主机上，二者间需要一根专门的电缆连接</li><li>2 细同轴电缆：10Base2 （10Mbps 185m）<br>收发器集成在接口卡中</li><li>3 双绞线：10Base-T<br>有4对双绞线<pre><code>   高速以太网 100Base-T</code></pre></li><li>4 光纤：10Base-F<br>抗干扰强，用于远距离的连接</li></ul>        <h4 id="以太网使用的MAC层协议-："   >          <a href="#以太网使用的MAC层协议-：" class="heading-link"><i class="fas fa-link"></i></a>以太网使用的MAC层协议 ：</h4>      <p><strong>CSMA/CD，碰撞检测功能</strong><br>接口卡中的收发器：侦听信号的功能 （区分信号空闲或忙碌状态<br>CSMA/CD 要求站点在传输数据帧之前，先要侦听信道的状态</p>        <h4 id="以太网使用PoE技术：Power-of-Ethernet"   >          <a href="#以太网使用PoE技术：Power-of-Ethernet" class="heading-link"><i class="fas fa-link"></i></a>以太网使用PoE技术：Power of Ethernet</h4>      <p>小型设备供电支持加载双绞线电缆上对设备进行供电</p>        <h4 id="以太网的特点："   >          <a href="#以太网的特点：" class="heading-link"><i class="fas fa-link"></i></a>以太网的特点：</h4>      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 带宽的不同种类</span><br><span class="line">2 自动协商，例如以双方都能支持的最高速率来进行工作</span><br></pre></td></tr></table></div></figure>        <h4 id="以太网的重要属性："   >          <a href="#以太网的重要属性：" class="heading-link"><i class="fas fa-link"></i></a>以太网的重要属性：</h4>      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 广播策略：通信是以广播的方式</span><br><span class="line">2 尽最大努力交付</span><br><span class="line">3 CSMA&#x2F;CD：媒体访问控制所使用的协议</span><br></pre></td></tr></table></div></figure>        <h4 id="以太网物理地址（MAC地址"   >          <a href="#以太网物理地址（MAC地址" class="heading-link"><i class="fas fa-link"></i></a>以太网物理地址（MAC地址</h4>      <p>48位</p>        <h4 id="以太网帧格式（单位字节）"   >          <a href="#以太网帧格式（单位字节）" class="heading-link"><i class="fas fa-link"></i></a>以太网帧格式（单位字节）</h4>      <p><img src="http://acptek.gitee.io/blogpictures/TCPIP/Ch2_Ethernet_FrameFormat.png" alt="以太网帧格式"></p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">目标地址 6</span><br><span class="line">原地址 6</span><br><span class="line">帧类型&#x2F;数据区长度 2 （但是padding不算在内，数据区长度为0那padding即为46）</span><br><span class="line">数据 46 - 1500 （最小46padding）</span><br><span class="line">帧校验序列 4 （CRC，由硬件产生）</span><br><span class="line"></span><br><span class="line">区分类型与长度的方法：</span><br><span class="line">将类型值都取成比1500大的值</span><br></pre></td></tr></table></div></figure>        <h3 id="无线局域网-Wi-Fi-（IEEE802-11）"   >          <a href="#无线局域网-Wi-Fi-（IEEE802-11）" class="heading-link"><i class="fas fa-link"></i></a>无线局域网 Wi-Fi （IEEE802.11）</h3>      <p>​    AP + STAs<br>​    Ad Hoc：点对点<br>​    WiMax 802.16</p>        <h3 id="ZigBee-802-15-4"   >          <a href="#ZigBee-802-15-4" class="heading-link"><i class="fas fa-link"></i></a>ZigBee 802.15.4</h3>      <p>​    个域网<br>​    低功耗的无线网络技术<br>​    分组长度：127字节<br>​    payload（有效负荷长度）：102字节<br>​    两种MAC地址格式（长、短）：16位、64位</p>        <h3 id="点对点网络"   >          <a href="#点对点网络" class="heading-link"><i class="fas fa-link"></i></a>点对点网络</h3>      <p>peer to peer ，无须物理地址来区分</p>        <h3 id="VLAN：虚拟局域网"   >          <a href="#VLAN：虚拟局域网" class="heading-link"><i class="fas fa-link"></i></a>VLAN：虚拟局域网</h3>      <p>​    配置交换机 -&gt; 将一个交换机看成对个更小交换机的集合<br>​    每一个VLAN定义一个独立的广播域</p>        <h3 id="底层网络设备"   >          <a href="#底层网络设备" class="heading-link"><i class="fas fa-link"></i></a>底层网络设备</h3>              <h4 id="中继器"   >          <a href="#中继器" class="heading-link"><i class="fas fa-link"></i></a>中继器</h4>      <p>​    工作在物理层<br>​    延伸电缆长度<br>​    最多经过四个中继器（12345原则</p>        <h4 id="桥"   >          <a href="#桥" class="heading-link"><i class="fas fa-link"></i></a>桥</h4>      <p>​    工作在链路层，识别帧的格式<br>​    桥收到一个完整的帧然后转发。整个过程对主机来说是透明的（透明桥）</p>        <h3 id="链路层目的："   >          <a href="#链路层目的：" class="heading-link"><i class="fas fa-link"></i></a>链路层目的：</h3>      <p>​    1 为IP模块发送和接收IP数据报<br>​    2 为ARP模块发送ARP请求和接收ARP应答<br>​    3 为RARP发送RARP请求和接收RARP应答</p><hr><p>参考资料：</p><ul><li>INTERNETWORKING WITH TCP/IP PRINCIPLES, PROTOCOLS, AND ARCHITECTURE Vol1 (6th Edition).  DOUGLASE E. COMER </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;底层网络技术概述&quot;   &gt;
          &lt;a href=&quot;#底层网络技术概述&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;底层网络技术概述&lt;/h1&gt;
      &lt;ul&gt;
&lt;li&gt;分组交换技术&lt;/li&gt;
&lt;li&gt;底层硬件技术&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="TCP/IP" scheme="https://acptek.github.io/categories/TCP-IP/"/>
    
    
      <category term="TCP/IP" scheme="https://acptek.github.io/tags/TCP-IP/"/>
    
      <category term="MAC" scheme="https://acptek.github.io/tags/MAC/"/>
    
      <category term="以太网" scheme="https://acptek.github.io/tags/%E4%BB%A5%E5%A4%AA%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP 概览</title>
    <link href="https://acptek.github.io/2020/07/03/TCP-IP-%E6%A6%82%E8%A7%88/"/>
    <id>https://acptek.github.io/2020/07/03/TCP-IP-概览/</id>
    <published>2020-07-03T09:05:34.000Z</published>
    <updated>2020-07-03T12:56:04.015Z</updated>
    
    <content type="html"><![CDATA[        <h1 id="概览"   >          <a href="#概览" class="heading-link"><i class="fas fa-link"></i></a>概览</h1>      <a id="more"></a>        <h3 id="Internet"   >          <a href="#Internet" class="heading-link"><i class="fas fa-link"></i></a>Internet</h3>      <p>​    特指网络环境</p><p>IP -&gt; 分组传递 -&gt; 无连接传输<br>TCP -&gt; 可靠的流传输 (针对TCP协议提供的服务，是一种面向连接的服务)</p><p>作为标准的RFC在系统中都有实现</p>        <h3 id="Internetworking"   >          <a href="#Internetworking" class="heading-link"><i class="fas fa-link"></i></a>Internetworking</h3>      <p>​    互联异构的（完全不同类型的）物理网络</p>        <h3 id="TCP-IP-的发展："   >          <a href="#TCP-IP-的发展：" class="heading-link"><i class="fas fa-link"></i></a>TCP/IP 的发展：</h3>      <p>​    ARPA -&gt; DARPA ：定义了体系结构与相关协议</p>        <h3 id="Internet-Services：因特网提供的服务"   >          <a href="#Internet-Services：因特网提供的服务" class="heading-link"><i class="fas fa-link"></i></a>Internet Services：因特网提供的服务</h3>      <p>​    是一个协议簇，一系列的协议<br>​        1 定义报文格式<br>​        2 收到响应的动作<br>​        3 差错的处理<br>​    优点：隐藏底层网络的细节</p>        <h3 id="如何看待因特网提供的服务："   >          <a href="#如何看待因特网提供的服务：" class="heading-link"><i class="fas fa-link"></i></a>如何看待因特网提供的服务：</h3>              <h4 id="1-从用户视角："   >          <a href="#1-从用户视角：" class="heading-link"><i class="fas fa-link"></i></a>1 从用户视角：</h4>      <p>​        一系列的应用程序（常用的如www，云访问，远程桌面，电子邮件，文件传输，流媒体等</p>        <h4 id="2-从网络层视角：因特网提供两种服务"   >          <a href="#2-从网络层视角：因特网提供两种服务" class="heading-link"><i class="fas fa-link"></i></a>2 从网络层视角：因特网提供两种服务</h4>      <p>​        1 无连接的分组传递服务<br>​        2 可靠的流传送服务</p>        <h3 id="因特网服务的一些特点："   >          <a href="#因特网服务的一些特点：" class="heading-link"><i class="fas fa-link"></i></a>因特网服务的一些特点：</h3>      <p>​        1 网络技术的独立性，协议独立于任何类型的网络硬件<br>​        2 通用的互联，网络中的任意两台计算机都能进行通信<br>​        3 端到端的确认，可靠的流传输，主机到主机与中间路由无关<br>​        4 应用协议标准</p>        <h3 id="因特网的历史："   >          <a href="#因特网的历史：" class="heading-link"><i class="fas fa-link"></i></a>因特网的历史：</h3>      <p>​    1979 APRA<br>​    1980s 从第一代协议迁移到第二代协议（相关操作系统支持的代表：BSD Unix<br>​    1983 APRA -&gt;1 (MILNET)民用  -&gt;2 (ARPANET)军用<br>​    1986 NSFNET 加入到APRA，成为APRA的主干</p>        <h3 id="因特网的管理机构："   >          <a href="#因特网的管理机构：" class="heading-link"><i class="fas fa-link"></i></a>因特网的管理机构：</h3>      <p>​    IAB<br>​    1989 IAB重新组着成IRTF和IETF</p>        <h3 id="因特网协议文档-RFC"   >          <a href="#因特网协议文档-RFC" class="heading-link"><i class="fas fa-link"></i></a>因特网协议文档 RFC</h3>      <p>​    从IETF上获取：www.ietf.org</p>        <h3 id="从IPv4到IPv6的转换"   >          <a href="#从IPv4到IPv6的转换" class="heading-link"><i class="fas fa-link"></i></a>从IPv4到IPv6的转换</h3>      <p>​     IPv6：<br>​    1 更大的地址空间<br>​    2 地址分层的层次结构上分的更多更细<br>​    3 首部格式是一个全新的格式，做了一定的简化<br>​    4 选项作为扩展首部<br>​    5 扩展性上适应新的网络硬件和应用<br>​    6 支持自动的配置和分配IP地址<br>​    7 支持资源的分配</p><p>IPv6 支持 自动配置 （配置TCPIP参数等<br>        支持 QoS</p>        <h3 id="概览中涉及的一些概念"   >          <a href="#概览中涉及的一些概念" class="heading-link"><i class="fas fa-link"></i></a>概览中涉及的一些概念</h3>      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1 分层</span><br><span class="line">TCP&#x2F;IP是一组不同层次上的多个协议的组合</span><br><span class="line">TCP&#x2F;IP 四层协议系统</span><br><span class="line">1）链路层：OS中的设备驱动程序、网卡</span><br><span class="line">2）网络层：处理分组在网络中的活动（例如分组选路</span><br><span class="line">IP、ICMP、ICMP</span><br><span class="line">3）运输层：为两台主机上的应用程序提供端到端的通信</span><br><span class="line">TCP 可靠数据通信</span><br><span class="line">UDP 任何必需的可靠性必须由应用层来提供</span><br><span class="line">4）应用层：负责处理特定的应用程序细节</span><br><span class="line">Telnet，FTP，SMTP，SNMP，……</span><br><span class="line"></span><br><span class="line">2 互联网地址</span><br><span class="line"></span><br><span class="line">3 域名系统</span><br><span class="line"></span><br><span class="line">4 封装</span><br><span class="line"></span><br><span class="line">5 分用</span><br><span class="line"></span><br><span class="line">6 端口号</span><br><span class="line"></span><br><span class="line">7 RFC</span><br></pre></td></tr></table></div></figure><hr><p>参考资料：</p><ul><li>INTERNETWORKING WITH TCP/IP PRINCIPLES, PROTOCOLS, AND ARCHITECTURE Vol1 (6th Edition).  DOUGLASE E. COMER </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概览&quot;   &gt;
          &lt;a href=&quot;#概览&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;概览&lt;/h1&gt;
    
    </summary>
    
      <category term="TCP/IP" scheme="https://acptek.github.io/categories/TCP-IP/"/>
    
    
      <category term="TCP/IP" scheme="https://acptek.github.io/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>特征点提取与匹配</title>
    <link href="https://acptek.github.io/2019/10/27/%E7%89%B9%E5%BE%81%E7%82%B9%E6%8F%90%E5%8F%96%E4%B8%8E%E5%8C%B9%E9%85%8D/"/>
    <id>https://acptek.github.io/2019/10/27/特征点提取与匹配/</id>
    <published>2019-10-27T03:45:11.000Z</published>
    <updated>2020-07-03T12:59:11.264Z</updated>
    
    <content type="html"><![CDATA[<p>视觉里程计：根据相邻图像的信息估计相机的运动，作为后端的初值</p><p>特征点法、直接法</p><p>在相机运动过程中观测到的路标点，在某一个位姿，相机观测到物体的像素坐标为$(u,v)$，则对应满足相机模型关系：</p><script type="math/tex; mode=display">Z P_{uv}=Z\begin{bmatrix}u\\v\\1\end{bmatrix}=K(RP_w+t)=KTP_w</script>        <h2 id="特征点提取与匹配"   >          <a href="#特征点提取与匹配" class="heading-link"><i class="fas fa-link"></i></a>特征点提取与匹配</h2>      <a id="more"></a>        <h3 id="特征点概念"   >          <a href="#特征点概念" class="heading-link"><i class="fas fa-link"></i></a>特征点概念</h3>      <p>​    1）路标：有代表性的点</p><p>​    2）特征：图像信息的另一种数字表达形式，角点&gt;特征&gt;区块</p><p>特征点 = 关键点 + 描述子</p>        <h4 id="关键点"   >          <a href="#关键点" class="heading-link"><i class="fas fa-link"></i></a>关键点</h4>      <p>特征点在图像中的位置</p>        <h4 id="描述子"   >          <a href="#描述子" class="heading-link"><i class="fas fa-link"></i></a>描述子</h4>      <p>描述关键点周围像素信息的向量，例如对关键点周围亮度的表现。</p><p>在ORB中，在关键点周围随机选择128对或256对点（对于每张相机图像里的每个关键点，都可以使用相同的随机选择模板），以每一对的亮度相似程度按二进制赋值，生成一个128或256位的二进制数，以此数来表述描述子。</p><p>同时，在ORB-BRIEF描述子中，考虑到图像的旋转，针对每张图像以灰度质心法计算图像中每个特征点方向，或者计算整体图像旋转的向量，以此旋转向量调整随机选择模板（对随机选择的点也进行旋转），再生成描述子。</p><p>最后，对描述子进行特征匹配。在ORB中，描述子的匹配以汉明匹配方式进行匹配。但是在ORB中，BRIEF描述子没有涉及到尺度这一特征。</p><p>​    </p>        <h3 id="特征提取算法"   >          <a href="#特征提取算法" class="heading-link"><i class="fas fa-link"></i></a>特征提取算法</h3>      <p>SIFT：尺度不变特征变换（计算量大）</p><p>FAST关键点：没有描述子（计算快） </p><p>ORB：FAST特征点 + BRIEF描述子</p>        <h3 id="ORB特征提取和匹配"   >          <a href="#ORB特征提取和匹配" class="heading-link"><i class="fas fa-link"></i></a>ORB特征提取和匹配</h3>      <p><img src="http://acptek.gitee.io/blogpictures/SLAM/ORB_Feature.jpg" alt="ORB_Feature"></p>        <h4 id="FAST关键点"   >          <a href="#FAST关键点" class="heading-link"><i class="fas fa-link"></i></a>FAST关键点</h4>      <p>目的是对图像的 平移、旋转、尺度 进行特征提取。</p>        <h5 id="图像金字塔："   >          <a href="#图像金字塔：" class="heading-link"><i class="fas fa-link"></i></a>图像金字塔：</h5>      <p>用于提取图像的尺度特征，描述相机前后运动的过程</p><p>​    1 塔底为原始图像，每往上一层对图像进行固定倍率（例：1.2，1.5，2倍等）缩放，得到不同分辨率图像（小远大近）</p><p>​    2 两图像间，匹配不同层上的图像</p><p>Oriented FAST关键点中没有涉及到这一特性</p>        <h5 id="特征旋转：计算图像灰度质心（以图像块灰度值作为权重的中心-）"   >          <a href="#特征旋转：计算图像灰度质心（以图像块灰度值作为权重的中心-）" class="heading-link"><i class="fas fa-link"></i></a>特征旋转：计算图像灰度质心（以图像块灰度值作为权重的中心 ）</h5>      <p>​    1 图像块的矩：其中，I(x, y)为f(x, y)的二值图像，取值0或1</p><script type="math/tex; mode=display">m_{pq}=\sum\limits_{x,y\in B}x^py^qI(x,y),\;p,q=\{0,1\}</script><p>​    2 图像块的质心：$ C=(m<em>{10}/m</em>{00},m<em>{01}/m</em>{00}) $</p><p>​    3 特征方向：表示为 $ \theta=\arctan(m<em>{01}/m</em>{10}) $，连接几何中心O和质心C得到的方向向量</p>        <h4 id="BRIEF描述子"   >          <a href="#BRIEF描述子" class="heading-link"><i class="fas fa-link"></i></a>BRIEF描述子</h4>      <p>在关键点附近随机选取K对点，以K位二进制的形式反映他们的大小关系，以此作为对一个特征点的描述。又由于在FAST关键点中计算了关键点的方向，利用方向信息计算旋转后的特征。</p>        <h4 id="ORB特征匹配"   >          <a href="#ORB特征匹配" class="heading-link"><i class="fas fa-link"></i></a>ORB特征匹配</h4>      <p>数据关联问题：确定前后看到的路标间的对应关系</p><p>问题：1 误匹配  2 匹配方法</p><p>描述点的距离表示了两个特征之间的相似程度</p><p>注：（SIFT……）快速近似邻近（FLANN），但不适用于计算汉明距离</p><hr><p><img src="http://acptek.gitee.io/blogpictures/SLAM/ORB_Feature_Frame.jpg" alt="ORB_Feature"></p><hr><p>参考资料：</p><ul><li>视觉SLAM十四讲：从理论到实践（第2版）.  高翔.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;视觉里程计：根据相邻图像的信息估计相机的运动，作为后端的初值&lt;/p&gt;
&lt;p&gt;特征点法、直接法&lt;/p&gt;
&lt;p&gt;在相机运动过程中观测到的路标点，在某一个位姿，相机观测到物体的像素坐标为$(u,v)$，则对应满足相机模型关系：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
Z P_{uv}=Z\begin{bmatrix}u\\v\\1\end{bmatrix}=K(RP_w+t)=KTP_w&lt;/script&gt;
        &lt;h2 id=&quot;特征点提取与匹配&quot;   &gt;
          &lt;a href=&quot;#特征点提取与匹配&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;特征点提取与匹配&lt;/h2&gt;
    
    </summary>
    
      <category term="SLAM" scheme="https://acptek.github.io/categories/SLAM/"/>
    
    
      <category term="SLAM" scheme="https://acptek.github.io/tags/SLAM/"/>
    
      <category term="Math" scheme="https://acptek.github.io/tags/Math/"/>
    
      <category term="OpenCV" scheme="https://acptek.github.io/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>状态估计中的最小二乘</title>
    <link href="https://acptek.github.io/2019/10/16/%E7%8A%B6%E6%80%81%E4%BC%B0%E8%AE%A1%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98/"/>
    <id>https://acptek.github.io/2019/10/16/状态估计中的最小二乘/</id>
    <published>2019-10-16T11:39:16.000Z</published>
    <updated>2020-07-03T12:59:28.519Z</updated>
    
    <content type="html"><![CDATA[        <h1 id="状态估计"   >          <a href="#状态估计" class="heading-link"><i class="fas fa-link"></i></a>状态估计</h1>      <blockquote><p>状态估计，是根据系统的先验模型和测量序列，对系统内在状态进行重构的问题</p></blockquote><a id="more"></a>        <h2 id="背景"   >          <a href="#背景" class="heading-link"><i class="fas fa-link"></i></a>背景</h2>      <script type="math/tex; mode=display">\left\{\begin{matrix}运动方程（相机位姿）：x_k = f(x_{k-1},u_k,w_k) \\观测方程（针孔模型）：z_{k,j}=h(y_j,x_k,v_{k,j})\end{matrix}\right.</script><p>$x_k = T_k = \exp({\xi_k}^\wedge)$：x_k是一个六自由度的位姿，可以由一个变换矩阵来描述，也可以用李代数的指数来描述。</p><p>$sz_{k,j}=K\exp(\xi^\wedge)y_j$：内参×外参×路标点 = 像素点距离×像素</p><hr>        <h2 id="考察问题"   >          <a href="#考察问题" class="heading-link"><i class="fas fa-link"></i></a>考察问题</h2>      <p>当已知观测方程和运动方程的具体形式，如何对估计值进行优化？</p><p>即：如何通过 观测量z 和 输入量u 去优化 机器人的轨迹、位置x 和 路标点的位置y （SLAM过程）？</p><p>这是一个状态估计问题：通过已知的带有噪声的数据 去推断出无法直接获得的状态</p><hr>        <h2 id="该问题下的状态估计"   >          <a href="#该问题下的状态估计" class="heading-link"><i class="fas fa-link"></i></a>该问题下的状态估计</h2>              <h3 id="状态变量："   >          <a href="#状态变量：" class="heading-link"><i class="fas fa-link"></i></a>状态变量：</h3>      <p>$x={x_1,…,x_N,y_1,…y_M}$：所有时刻的位姿x 和 所有时刻的路标（地图）y</p><p>所以状态估计等同于求解条件分布： P(x | z, u)    x在z，u条件下的概率分布（x, z, u都表示所有时刻的统称）</p>        <h3 id="状态估计问题分类："   >          <a href="#状态估计问题分类：" class="heading-link"><i class="fas fa-link"></i></a>状态估计问题分类：</h3>      <p>1 线性系统 ：若f和h是线性方程（有几个线性量，加和，数乘组成）</p><p>2 高斯噪声：噪声属于高斯分布</p><p>3 非线性系统</p><p>4 非高斯噪声</p><p>此处的状态估计具有 马尔科夫性（下一个时刻的状态依赖于上一个时刻的状态）</p>        <h3 id="状态估计描述"   >          <a href="#状态估计描述" class="heading-link"><i class="fas fa-link"></i></a>状态估计描述</h3>      <p>在k个时间点上，基于初始状态信息、一系列观测数据、一系列输入，以及系统的运动模型和观测模型，来计算系统的真实状态估计值。</p><hr>        <h2 id="从概率学角度求状态估计"   >          <a href="#从概率学角度求状态估计" class="heading-link"><i class="fas fa-link"></i></a>从概率学角度求状态估计</h2>      <p>在不知道输入控制u，只有图像时，忽略u并只考虑观测数据</p><p>P(x|z)：已知图像，推断x的分布：称为后验概率</p><p>贝叶斯：</p><p>似然概率：p(z|x)：在某一个状态x下观测图像（确定图像与当前图像的相似程度）</p><p>先验概率：P(x)：x自己的状态</p><p>对于p(x|z)：x的维度很高，难以写出其分布，但是可以求：</p>        <h3 id="1）最大后验估计"   >          <a href="#1）最大后验估计" class="heading-link"><i class="fas fa-link"></i></a>1）最大后验估计</h3>      <p>​    使得 p(x|z)最大的 x 的估计 (${x^*}_{MAP}$)，即在某一种分布下 x 的最优估计，此时是一个估计出的量</p><p>​    ${x^*}_{M A P} = \arg \max P(x|z) = \arg \max P(z|x)P(x)$</p><p>​    注释：寻求一个x使得p(x|z)达到最大，此时称为x为最大后验估计，表示：在怎样的x下拿到的相机数据和现在数据（已有的）是最像的</p>        <h3 id="2）最大似然估计"   >          <a href="#2）最大似然估计" class="heading-link"><i class="fas fa-link"></i></a>2）最大似然估计</h3>      <p>​    当最大后验估计中无法得知 x时（不知道 机器人轨迹 的先验是什么样子的时候），则直接最大化似然</p><p>​    ${x^*}_{MLE} = \arg \max P(z|x)$</p><p>​    注释：当不知道先验概率时（x原本应该是什么样子，或者x就是一个随机的运动）即没有先验时，则此时最大化似然就可以了。表示：最大化x，使得在此状态下看到的数据最像我们看到的数据，P(z|x)  即“在哪种状态下，最容易产生当前的观测”</p><hr>        <h2 id="求解最大似然估计"   >          <a href="#求解最大似然估计" class="heading-link"><i class="fas fa-link"></i></a>求解最大似然估计</h2>      <p>某次观测：$z<em>{k,j}=h(y_j, x _k)+v</em>{k, j}$，噪声服从0均值高斯分布$v<em>k\sim \mathcal{N}(0,Q</em>{k,j})$</p><p>所以观测数据条件概率（将h加到噪声分布上）</p><script type="math/tex; mode=display">P(z_{j,k}|x_k,y_j)=N(h(y_j, x _k), Q_{k,j})</script><p>对于N维高斯分布 $x\sim \mathcal{N}(\mu,\Sigma)$的概率密度展开式：</p><script type="math/tex; mode=display">p(x)=\frac{1}{\sqrt{(2\pi)^N\det(\Sigma)} }\exp(-\frac{1}{2}(x-\mu)^T\Sigma^{-1}(x-\mu))</script><p>它的右侧指数部分为一个二次型，若$\Sigma=I$，则指数部分就是一个二范数（误差的平方）</p><p>将展开式两边取对数并添加负号，得到p(x)只与马氏距离$-\frac{1}{2}(x-\mu)^T\Sigma^{-1}(x-\mu)$有关。</p><p>所以要求最大似然估计，就是求最小$-\ln(p(x))$</p>        <h3 id="最小二乘"   >          <a href="#最小二乘" class="heading-link"><i class="fas fa-link"></i></a>最小二乘</h3>      <p>代入SLAM观测模型，</p><script type="math/tex; mode=display">(x_k, y_j)^*=\arg\min( \;(z-h(x,y))^T Q^{-1} (z-h(x,y))\;)</script><p>等式右侧为一个最小二乘，即最小化噪声项（误差）的一个二次型（马氏距离）</p><p>其中，$Q^{-1}$为信息矩阵（协方差矩阵的逆，协方差反映两个变量相向的程度），用于噪声的控制调整</p><script type="math/tex; mode=display">P(z,u|x,y)=\prod_kP(u_k|x_{k-1},x_k)\prod_{k,j}P(z_{k,j}|x_k, y_j)</script><p>定义运动误差和观测误差：$e<em>{u, k}，e</em>{z, j, k}$，最小化估值和真实值之间的误差（即马氏距离）时，每一个误差对应一个最小二乘，所以得到一个最小二乘问题 $\min J(x, y)$ ，它等于所有时刻运动误差和观测误差的总和。</p><p>此最小二乘问题等价于状态的最大似然估计</p><hr>        <h1 id="非线性最小二乘"   >          <a href="#非线性最小二乘" class="heading-link"><i class="fas fa-link"></i></a>非线性最小二乘</h1>      <p>探讨通用的无约束非线性最小二乘问题的求解</p>        <h2 id="一阶梯度"   >          <a href="#一阶梯度" class="heading-link"><i class="fas fa-link"></i></a>一阶梯度</h2>      <p>最速下降法，取增量为反向梯度 $\Delta x^*=-J(x_k)$</p>        <h2 id="二阶梯度"   >          <a href="#二阶梯度" class="heading-link"><i class="fas fa-link"></i></a>二阶梯度</h2>      <p>牛顿法，保留了二阶梯度，$\Delta x = -H^{-1}J$</p>        <h2 id="高斯牛顿法"   >          <a href="#高斯牛顿法" class="heading-link"><i class="fas fa-link"></i></a>高斯牛顿法</h2>      <p>将误差一阶展开，代入最小二乘，求梯度求解</p><script type="math/tex; mode=display">J(x)J^T(x)\Delta x=-J(x)f(x) \; \Rightarrow\;H(x)\Delta x=g(x)</script><p>称为高斯牛顿方程（正规方程）$H\Delta x=g$ .</p><p>其中：J(x)为f(x)关于x的导数，是一个1×n的向量</p><p>缺陷：</p><p>1）$H = JJ^T$可能不正定，无法求$H^{-1}$</p><p>2）不考虑步长的取值造成误差</p><p>求解过程：</p><blockquote><p>1 最小二乘式，确定待估计的变量</p><p>2 误差式</p><p>3 计算雅克比矩阵J 和 误差e</p><p>4 求解增量方程 Hx=g</p><p>5 迭代</p></blockquote>        <h2 id="LM"   >          <a href="#LM" class="heading-link"><i class="fas fa-link"></i></a>LM</h2>      <p>增加指标</p><script type="math/tex; mode=display">\rho = \frac{f(x + \Delta x) - f(x)}{ J(x)^T\Delta x}</script><p>以该指标为 $\Delta x$ 添加一个信赖区域，以$\rho$值的大小来控制信赖区域的半径，使得在此区域内取得的$JJ^T \sim H$，从而用雅克比矩阵运算代替海塞矩阵的运算，同时，在约束项的控制下，保证了求解项左边矩阵可逆。</p><p>将约束项加入到最小二乘中：</p><script type="math/tex; mode=display">\mathcal{L}(\Delta x_k,\lambda)=\frac{1}{2}\left \| f(x_k) + J(x_k)^T\Delta x_k \right \|^2+\frac{\lambda}{2}(\left \| D\Delta x_k \right \|^2-\mu)</script><p>其中，D为非负数对角阵，表示了对空间的约束。</p><p>对$\Delta x$求导后得：$(H+\lambda D^TD)\Delta x_k=g$</p><hr>        <h1 id="矩阵微分"   >          <a href="#矩阵微分" class="heading-link"><i class="fas fa-link"></i></a>矩阵微分</h1>      <blockquote><p>先使用微分法则展开复合微分项，再通过迹技巧，结合下式求解</p></blockquote><script type="math/tex; mode=display">df=tr(\frac{\partial f}{\partial X}^TdX)</script><hr><p>参考资料：</p><ul><li>视觉SLAM十四讲：从理论到实践（第2版）.  高翔.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;状态估计&quot;   &gt;
          &lt;a href=&quot;#状态估计&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;状态估计&lt;/h1&gt;
      &lt;blockquote&gt;
&lt;p&gt;状态估计，是根据系统的先验模型和测量序列，对系统内在状态进行重构的问题&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="SLAM" scheme="https://acptek.github.io/categories/SLAM/"/>
    
    
      <category term="SLAM" scheme="https://acptek.github.io/tags/SLAM/"/>
    
      <category term="Math" scheme="https://acptek.github.io/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>相机标定</title>
    <link href="https://acptek.github.io/2019/10/04/%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/"/>
    <id>https://acptek.github.io/2019/10/04/相机标定/</id>
    <published>2019-10-04T12:06:13.000Z</published>
    <updated>2020-07-03T12:59:22.484Z</updated>
    
    <content type="html"><![CDATA[<p>坐标系</p><p>世界坐标系 $(x_w,y_w,z_w)$</p><p>相机坐标系  $(x_c,y_c,z_c)$</p><p>图像坐标系 $(x,y)$</p><p>$x_p=f\frac{x_c}{z_c},y_p=f\frac{y_c}{z_c}$</p><p>像素坐标系 $(u,v)$</p><p>$u=\frac{x_c}{d_x}+u_0,v=\frac{y_c}{d_y}+v_0$</p><a id="more"></a><p>坐标系转换</p><p>1 世界坐标系到相机坐标系（旋转矩阵）</p><p>2 相机坐标系到图像坐标系（透视投影矩阵 3X4矩阵）</p><p>3 图像坐标系到像素坐标系（K 内参矩阵）</p><script type="math/tex; mode=display">K=\begin{bmatrix}f_x & 0 & u_0\\ 0 & f_y & v_0\\ 0 & 0 & 1\end{bmatrix}，f_x=\frac{f}{d_x},f_y=\frac{f}{d_y}</script><script type="math/tex; mode=display">Z P_{uv}=Z\begin{bmatrix}u\\v\\1\end{bmatrix}=K(RP_w+t)=KTP_w</script>        <h2 id="张正友标定法"   >          <a href="#张正友标定法" class="heading-link"><i class="fas fa-link"></i></a>张正友标定法</h2>              <h3 id="在不考虑透镜畸变情况下求解内参和外参"   >          <a href="#在不考虑透镜畸变情况下求解内参和外参" class="heading-link"><i class="fas fa-link"></i></a>在不考虑透镜畸变情况下求解内参和外参</h3>      <p>相机内参： fx,fy,u0,v0(,r=K12) ​</p><p>相机外参：$T_x,T_y,T_z,\omega,\delta,\theta$</p><p>单应性矩阵：单应性矩阵用于表示投射图像间的透视变换，变换图像的视图</p><p>单应性：从一个平面到另一个平面的投影映射，例如</p><script type="math/tex; mode=display">\tilde{Q}=\begin{bmatrix}X\\Y\\Z\\1\end{bmatrix}\;\rightarrow\;\tilde{q}=\begin{bmatrix}x\\y\\1\end{bmatrix}\;\Rightarrow\;\tilde{q}=sH\tilde{Q}</script><p>定义标定板平面为世界坐标系中 Z=0 的平面</p><script type="math/tex; mode=display">s\begin{bmatrix}u\\v\\1\end{bmatrix}=K\begin{bmatrix}R & t\end{bmatrix}\begin{bmatrix}x\\y\\z\\1\end{bmatrix}=K\begin{bmatrix}r_1 & r_2 & r_3 & t\end{bmatrix}\begin{bmatrix}x\\y\\0\\1\end{bmatrix}=K\begin{bmatrix}r_1 & r_2\end{bmatrix}\begin{bmatrix}x\\y\\1\end{bmatrix}</script><p>其中，$s$为尺度因数（使得单应性定义到该尺度的比例），$H=K\begin{bmatrix}r_1 &amp; r_2 &amp; t\end{bmatrix}$为成像平面和标定平面之间的单应矩阵（由变换和相机内参两部分组成，$r_1,r_2,t$ 分别为旋转矩阵的前两个列向量和平移向量），$\begin{bmatrix}R&amp;t\end{bmatrix}$是一个3X4的矩阵（前3X3是旋转矩阵，后3X1是一个平移向量t）</p><p>图像平面(src)的点集与目标平面(dst)上的点集 间的关系（由单应性矩阵确定）：</p><script type="math/tex; mode=display">\begin{align}& p_{dst}=Hp_{src} , p_{src}=H^{-1}p_{dst}\\\\&p_{dst}=\begin{bmatrix}x_{dst}\\y_{dst}\\1\end{bmatrix},p_{src}=\begin{bmatrix}x_{src}\\y_{src}\\1\end{bmatrix}\end{align}</script><p>记：$H=\begin{bmatrix}h_1&amp;h_2&amp;h_3\end{bmatrix}$</p>        <h4 id="求内参矩阵"   >          <a href="#求内参矩阵" class="heading-link"><i class="fas fa-link"></i></a>求内参矩阵</h4>      <p>由 </p><script type="math/tex; mode=display">H=s^{-1}K\begin{bmatrix}r_1 & r_2&t\end{bmatrix}\tag{1}</script><script type="math/tex; mode=display">r_1r_2=0\tag{2},|r_i|=1</script><p>（1）（2）可推导出两等式，</p><script type="math/tex; mode=display">\begin{align}&h_1^TK^{-T}K^{-1}h_2=0\\&h_1^TK^{-T}K^{-1}h_1=h_2^TK^{-T}K^{-1}h_2\end{align}</script><p>通过两张不同位置的图片，可以标定后求解出相机内参矩阵K（四个未知数四个方程）</p>        <h4 id="求外参矩阵"   >          <a href="#求外参矩阵" class="heading-link"><i class="fas fa-link"></i></a>求外参矩阵</h4>      <p>在求得内参矩阵后，则可以估算外参矩阵：</p><script type="math/tex; mode=display">\begin{align}&H=s^{-1}K\begin{bmatrix}r_1 & r_2&t\end{bmatrix}\\\Rightarrow&\left\{\begin{matrix}r_1=s^{-1}A^{-1}h_1\\ r_2=s^{-1}A^{-1}h_2\\ r_3=r_1\times r_2\\ t = s^{-1}A^{-1}h_3\end{matrix}\right.,s^{-1}=\frac{1}{||K^{-1}h_1||}=\frac{1}{||K^{-1}h_2||}\end{align}</script>        <h3 id="考虑畸变，求解畸变系数"   >          <a href="#考虑畸变，求解畸变系数" class="heading-link"><i class="fas fa-link"></i></a>考虑畸变，求解畸变系数</h3>      <p>径向畸变处理</p>        <h3 id="参数最优化"   >          <a href="#参数最优化" class="heading-link"><i class="fas fa-link"></i></a>参数最优化</h3>      <p>非线性最小二乘法，极大似然估计</p><hr><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// image creator</span></span><br><span class="line"><span class="keyword">if</span>(!((i+j)%<span class="number">2</span>))</span><br><span class="line">    rectangle(ChessImage, Point(Start.x+i*SingleSize, Start.y+j*SingleSize),</span><br><span class="line">                                     Point(Start.x+(i+<span class="number">1</span>)*SingleSize<span class="number">-1</span>, Start.y+(j+<span class="number">1</span>)*SingleSize<span class="number">-1</span>),</span><br><span class="line">                                     Scalar(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">-1</span>);</span><br></pre></td></tr></table></div></figure><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// image capture</span></span><br><span class="line">VideoCapture capture;</span><br><span class="line">Mat frame;</span><br><span class="line">capture.open( [filename] )</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) capture &gt;&gt; frame</span><br></pre></td></tr></table></div></figure><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// opencv/samples/cpp/calibration.cpp</span></span><br><span class="line">cv::findChessboardCorners() <span class="comment">//绘制交点</span></span><br><span class="line">cv::calibrationCamera() <span class="comment">//校准</span></span><br></pre></td></tr></table></div></figure><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cv::undistort() //校正畸变</span></span><br><span class="line"><span class="keyword">double</span> x = (u - cx)/fx, y = (v - cy)/fy;</span><br><span class="line"> <span class="comment">// X/Z , Y/Z -&gt; 归一化坐标 （X/Z Y/Z 1）-&gt; 映射到二维 -&gt; (x y) -&gt; 写成极坐标形式 （r theta）</span></span><br><span class="line"><span class="keyword">double</span> r = <span class="built_in">sqrt</span>(x*x + y*y); <span class="comment">// 极坐标 长度</span></span><br><span class="line"><span class="keyword">double</span> u_distort = fx *  x * (<span class="number">1</span> + k1*<span class="built_in">pow</span>(r, <span class="number">2</span>) + k2*<span class="built_in">pow</span>(r, <span class="number">4</span>) + k3*<span class="built_in">pow</span>(r, <span class="number">6</span>) ) + <span class="number">2</span>*p1*x*y + p2*(<span class="built_in">pow</span>(r, <span class="number">2</span>)  + <span class="number">2</span>*<span class="built_in">pow</span>(x, <span class="number">2</span>) ) + cx;</span><br><span class="line"><span class="keyword">double</span> v_distort = fy * y * (<span class="number">1</span> + k1*<span class="built_in">pow</span>(r, <span class="number">2</span>)  + k2*<span class="built_in">pow</span>(r, <span class="number">4</span>) + k3*<span class="built_in">pow</span>(r, <span class="number">6</span>) ) + p1*(<span class="built_in">pow</span>(r, <span class="number">2</span>)  + <span class="number">2</span>*<span class="built_in">pow</span>(y, <span class="number">2</span>) ) + <span class="number">2</span>*p2*x*y + cy;</span><br></pre></td></tr></table></div></figure><p>畸变方程</p><script type="math/tex; mode=display">\left\{\begin{matrix}x_{distorted}= x(1+k_1r^2+k_2r^4+k_3r^6)+2p_1xy+p_2(r^2+2x^2)\\y_{distorted}= y(1+k_1r^2+k_2r^4+k_3r^6)+p_1(r^2+2y^2)+2p_2xy\end{matrix}\right. \Rightarrow \left\{\begin{matrix} u=f_xx_{distorted} + c_x\\ v=f_yy_{distorted} + c_y\end{matrix}\right.</script><p><img src="http://acptek.gitee.io/blogpictures/SLAM/sample.png" alt="Undistort Sample"></p><figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./imagelist_creator imagelist.yaml [path].jpg</span><br><span class="line">./calibration -w=[num] -h=[num] [-op] [-oe] [...] imagelist.yaml</span><br></pre></td></tr></table></div></figure><figure class="highlight yaml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># out_camera_data.yml</span></span><br><span class="line"><span class="attr">camera_matrix:</span>  <span class="string">//相机内参</span></span><br><span class="line"><span class="attr">distortion_coefficients:</span> <span class="string">//畸变系数</span></span><br></pre></td></tr></table></div></figure><hr><p>参考：</p><ul><li>1 视觉SLAM十四讲：从理论到实践（第2版）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;坐标系&lt;/p&gt;
&lt;p&gt;世界坐标系 $(x_w,y_w,z_w)$&lt;/p&gt;
&lt;p&gt;相机坐标系  $(x_c,y_c,z_c)$&lt;/p&gt;
&lt;p&gt;图像坐标系 $(x,y)$&lt;/p&gt;
&lt;p&gt;$x_p=f\frac{x_c}{z_c},y_p=f\frac{y_c}{z_c}$&lt;/p&gt;
&lt;p&gt;像素坐标系 $(u,v)$&lt;/p&gt;
&lt;p&gt;$u=\frac{x_c}{d_x}+u_0,v=\frac{y_c}{d_y}+v_0$&lt;/p&gt;
    
    </summary>
    
      <category term="CV" scheme="https://acptek.github.io/categories/CV/"/>
    
    
      <category term="SLAM" scheme="https://acptek.github.io/tags/SLAM/"/>
    
      <category term="OpenCV" scheme="https://acptek.github.io/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>李代数求导</title>
    <link href="https://acptek.github.io/2019/09/22/VSLAM-4-2-%E6%9D%8E%E4%BB%A3%E6%95%B0%E6%B1%82%E5%AF%BC/"/>
    <id>https://acptek.github.io/2019/09/22/VSLAM-4-2-李代数求导/</id>
    <published>2019-09-22T12:49:43.000Z</published>
    <updated>2020-07-03T12:50:41.945Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>1） SLAM的过程就是不断的估计相机的位姿和建立地图，在此过程中会出现一定的误差，所以目的是寻找一个最佳位姿（通过优化方法，一般采用迭代优化方法，每次迭代都更新一个位姿的增量delta，使得目标函数最小。这个delta就是通过误差函数对T微分得到的。也就是说我们需要对变换矩阵T求微分），使得整体误差最小。</p><p>为此，可以列出关于变换矩阵T的目标函数，要求解方程需要对变换矩阵求导。</p><p>2） 就旋转矩阵而言，其矩阵加法不封闭，为此不满足导数定义中“加一个极小量”。所以，要使得矩阵满足求导运算，引出李群和李代数。</p><p>李群是具有连续性质的群，群上定义了某种矩阵的集合。对于旋转矩阵、变换矩阵都是满足李群的定义，例如旋转矩阵在旋转矩阵的集合中关于乘法运算满足李群。李群运算不满足求导，但与李群对应的李代数满足加法后保持性质。至此，将变换矩阵求导的问题转化为了求李代数的导数问题。</p><p>在讨论李代数的物理意义时，so(3)就代表了旋转向量组成的空间。实际上，so(3)是三维向量phi的集合，每个向量phi^表达了这个李代数对应的李群SO(3)上旋转矩阵R的导数。其中，R与phi是一个指数映射关系。</p><p>关于李代数和李群在几何意义上的关系：李代数对应李群的正切空间，描述了李群的局部导数。</p></blockquote><a id="more"></a>        <h2 id="李代数求导"   >          <a href="#李代数求导" class="heading-link"><i class="fas fa-link"></i></a>李代数求导</h2>              <h3 id="BCH公式"   >          <a href="#BCH公式" class="heading-link"><i class="fas fa-link"></i></a>BCH公式</h3>      <script type="math/tex; mode=display">\ln(\exp(A)\exp(B))=A+B+\frac{1}{2}[A,B]+\frac{1}{12}[A,[A,B]]-\frac{1}{12}[B[A,B]]+...</script><p>其中“[ , ]”为李括号。</p><p>考虑SO(3)上的李代数：</p><script type="math/tex; mode=display">\ln(\exp(\phi_1^\wedge)\exp(\phi_2^\wedge))^\vee=\left\{\begin{matrix}{J_l(\phi_2)}^{-1}\phi_1+\phi_2\;\;当\phi_1为小量\\ {J_r(\phi_1)}^{-1}\phi_2+\phi_1\;\;当\phi_2为小量\end{matrix}\right.\tag{*}</script><p>第一个近似描述了：对一个旋转矩阵$R2$（李代数$\phi_2$），左乘一个微小旋转$R_1$，近似看作：在李代数$\phi_2$上加了一项${J_l(\phi_2)}^{-1}\phi_1$.</p><script type="math/tex; mode=display">J_l=J=\frac{\sin\theta}{\theta}I+(1-\frac{\sin\theta}{\theta})\alpha\alpha^T+\frac{1-\cos\theta}{\theta}\alpha^\wedge\tag{**}</script><script type="math/tex; mode=display">J^{-1}=\frac{\theta}{2}\cot\frac{\theta}{2}I+(1-\frac{\theta}{2}\cot\frac{\theta}{2})\alpha\alpha^T-\frac{\theta}{2}\alpha^\wedge\tag{**}</script><p>右乘：$J_r(\phi)=J_l(-\phi)$</p><p>至此，得到李群乘法和李代数加法的关系</p>        <h3 id="BCH近似"   >          <a href="#BCH近似" class="heading-link"><i class="fas fa-link"></i></a>BCH近似</h3>      <p>$旋转矩阵R，其李代数\phi，微小旋转\Delta R，其李代数\Delta\phi$，李群乘法$\rightarrow$李代数加法</p><script type="math/tex; mode=display">\exp(\Delta\phi^\wedge)\exp(\phi^\wedge)=\exp((\phi+J_l^{-1}(\phi)\Delta\phi)^\wedge)\tag{***}</script><p>李代数加法$\rightarrow$李群乘法</p><script type="math/tex; mode=display">\exp((\phi+\Delta\phi)^\wedge)=\exp((J_l\Delta\phi)^\wedge)\exp(\phi^\wedge)=\exp(\phi^\wedge)\exp((J_r\Delta\phi)^\wedge)\tag{***}</script>        <h3 id="李代数求导-1"   >          <a href="#李代数求导-1" class="heading-link"><i class="fas fa-link"></i></a>李代数求导</h3>      <p>两种思路：</p><p>1 导数模型 ， 2 扰动模型</p>        <h4 id="SO-3-上的李代数求导"   >          <a href="#SO-3-上的李代数求导" class="heading-link"><i class="fas fa-link"></i></a>SO(3)上的李代数求导</h4>      <p>$位姿T，观察点的世界坐标p，产生的观测数据z，随即噪声w$，对于N个观测误差$e=z-Tp$，（寻找一个最优T，使误差最小）</p><script type="math/tex; mode=display">\underset{T}{\min}J(T)=\sum_{i=1}^N||z_i-Tp_i||_2^2</script>        <h4 id="李代数求导-2"   >          <a href="#李代数求导-2" class="heading-link"><i class="fas fa-link"></i></a>李代数求导</h4>      <p>1）按照导数模型，（根据李代数的加法结合导数的定义来求旋转后点的坐标对于旋转的导数，或者说是求旋转很小时偏移的变化率），可以求得：</p><script type="math/tex; mode=display">\begin{align}& \frac{\partial (\exp(\phi^\wedge)p)}{\partial \phi}\approx-(Rp)^\wedge J_l\\&\\\Rightarrow &\frac{\partial (Rp)}{\partial \phi}=(-Rp)^\wedge J_l\tag{旋转后的点对于李代数的导数}\end{align}</script><p>2）扰动模型，对旋转矩阵R进行一次扰动$\Delta R$（对应的李代数为$\varphi $），看结果相对于扰动的变化率。</p><script type="math/tex; mode=display">\frac{\partial (Rp)}{\partial \phi}=(-Rp)^\wedge</script>        <h4 id="SE-3-上的李代数求导"   >          <a href="#SE-3-上的李代数求导" class="heading-link"><i class="fas fa-link"></i></a>SE(3)上的李代数求导</h4>      <p>空间点p，变换T（对应的李代数为$\xi$），扰动变换$\Delta T=\exp(\delta\xi^\wedge)$，其李代数为$\delta\xi=[\delta\rho,\delta\phi]^T$：</p><script type="math/tex; mode=display">\frac{\partial (Tp)}{\partial \delta\xi}=\begin{bmatrix}I & -(Rp+t)^\wedge\\ 0^T & 0^T\end{bmatrix}git</script><hr><p>参考资料：</p><ul><li>视觉SLAM十四讲：从理论到实践（第2版）.  高翔.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;1） SLAM的过程就是不断的估计相机的位姿和建立地图，在此过程中会出现一定的误差，所以目的是寻找一个最佳位姿（通过优化方法，一般采用迭代优化方法，每次迭代都更新一个位姿的增量delta，使得目标函数最小。这个delta就是通过误差函数对T微分得到的。也就是说我们需要对变换矩阵T求微分），使得整体误差最小。&lt;/p&gt;
&lt;p&gt;为此，可以列出关于变换矩阵T的目标函数，要求解方程需要对变换矩阵求导。&lt;/p&gt;
&lt;p&gt;2） 就旋转矩阵而言，其矩阵加法不封闭，为此不满足导数定义中“加一个极小量”。所以，要使得矩阵满足求导运算，引出李群和李代数。&lt;/p&gt;
&lt;p&gt;李群是具有连续性质的群，群上定义了某种矩阵的集合。对于旋转矩阵、变换矩阵都是满足李群的定义，例如旋转矩阵在旋转矩阵的集合中关于乘法运算满足李群。李群运算不满足求导，但与李群对应的李代数满足加法后保持性质。至此，将变换矩阵求导的问题转化为了求李代数的导数问题。&lt;/p&gt;
&lt;p&gt;在讨论李代数的物理意义时，so(3)就代表了旋转向量组成的空间。实际上，so(3)是三维向量phi的集合，每个向量phi^表达了这个李代数对应的李群SO(3)上旋转矩阵R的导数。其中，R与phi是一个指数映射关系。&lt;/p&gt;
&lt;p&gt;关于李代数和李群在几何意义上的关系：李代数对应李群的正切空间，描述了李群的局部导数。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="SLAM" scheme="https://acptek.github.io/categories/SLAM/"/>
    
    
      <category term="SLAM" scheme="https://acptek.github.io/tags/SLAM/"/>
    
      <category term="Math" scheme="https://acptek.github.io/tags/Math/"/>
    
  </entry>
  
</feed>
