<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[TCP/IP 边界网关协议]]></title>
    <url>%2F2020%2F07%2F24%2FTCP-IP-%E8%BE%B9%E7%95%8C%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[BGP 协议 在自治系统之间进行路由的协议 任何一个单一的路由协议都无法解决因特网这么大规模包含这么多路由器的这种环境下进行路由交换的路由需求。 所以需要对其进行划分成一些独立的组，称为AS。它们相互独立，由不同的管理机构来管理。 1 路由协议 路由更新协议 在单一的主干（单一的网络）上工作 在主干核心网中工作，但是不能进行扩展 原因：随着网络站点的增加，影响路由更新协议正常工作 每个路由器处理接收转发的流量会增加 同时因特网上的网络数量也会增加 这些网络由不同的机构管理，是相对独立的 在巨大的网络中使用一个单一的路由更新协议是不实际的 将路由器分成一些独立的组 原因： 考虑到流量增加问题 路由器间是间接通信的 网络和路由器非单一机构管理 组的大小限制 需要考虑的因素： 交换路由信息的算法 网络容量、带宽等 路由协议的细节 涉及到的两个问题：1 延迟 2 额外开销 额外跳 访问一个网络时使用默认路由导致额外的跳数 自治系统 AS 定义：由一个单一的管理机构管辖的一组网络和路由器。 内部路由器使用的路由协议：由管理机构决定 内部：路由协议由管理机构决定 区分不同AS：属于两个不同的AS的路由器间交换路由信息时，应该包含对方AS的编号 2 外部网关协议及其可达性问题 EGP 外部网关协议 指的是一类协议，能够在不同的自治系统中传递可达性信息的协议，使用较多的是BGP协议。 BGP：边界网关协议 目前流行使用的版本是第四版，称为BGP4 在自治系统内部包含很多路由器，从中选出一个作为边界路由器。两个自治系统的边界路由器之间交换路由信息时，使用BGP BGP 边界网关协议 只是用于传递网络可达性，而非作为路由信息来进行传递 特性 用于AS与AS之间的通信 IBGP：内部BGP，对于特定的AS有多个边界路由器，IBGP保证通过不同的边界路由器传播出去的本地AS路由信息一致（协调内部信息） 能向外传播可达性的消息（包括中间AS作为转发等） 下一跳方式进行每个目标通告 BGP支持策略路由 使用可靠传输服务 以增量方式更新（只发送新的路由信息，节约带宽） 支持无类别的寻址方案 路由汇聚（多条路由压缩成一条） 认证身份 功能： 能够进行邻居（对等方 peer）发现与邻居之间连接创建 任何一方可以向另一方发送正向（可达的合法目标）或负向（先前公布的目标已失效）的可达性信息（使用UPDATE） 在维持的过程中不断进行验证，确保连接 （使用KEEPALIVE） 报文类型 OPEN：双方建立连接 UPDATE：路由信息更新报文 NOTIFICATION：进行差错处理（例如拆除连接） KEEPALIVE：不断验证保证连接 REFRESH：动态向对方申请相应路由信息 BGP报文首部 3个固定长度字段，19个字节 字段： MARKER：用于定界，表示报文的开始与结束的位置 LENGTH：表示整个报文的长度，最大长度为4096字节 TYPE：报文类型 BGP OPEN报文 用于创建BGP对等体之间的连接 HOLD TIME 一对BGP peers之间连接的有效期，时钟超时间隔，超时终止（接收方两个连续的报文的最大时间间隔） 将HOLD TIME的值设为0，表示双方不进程保持连接的交换，则不需要KEEPALIVE报文 KEEPALIVE的时间间隔是hold timer的1/3，KEEPALIVE是以秒为单位的，所以hold timer的值不少于3 s BGP IDENTIFIER 用于唯一区分一个AS的编号：一般使用IP地址进行标识（多接口路由器从则中选取一个作为ID） Optional Parameter 可选参数 收到OPEN报文，则以KEEPALIVE报文进行响应 BGP UPDATE报文 由于连接建立后的数据交换 传递的信息： 可达的新的目标 需要撤销的原来的现在不可用的目标 WITHDRAWN：需要撤销的现在非法的老的目标 PATH ATTR：路径属性 新的目标前都带有公共的路径属性。所以路径属性不一样时需要发多个UPDATE报文。 BGP KEEPALIVE报文 作为连接创建的确认，作为连接维持的报文 报文后不带数据，只包含报文首部：19字节 使用的理由： 1 BGP使用TCP传输服务 2 考虑节约带宽：报文中不带有数据，报文长度最短，有利于保持连接的传输 KEEPALIVE的时间间隔是hold timer的1/3 BGP Notification报文 主要是用于差错处理 一旦发生错误，发送Notification报文关闭TCP连接 报文格式： 错误码： 1：报文首部出错 2：OPEN报文出错 3：UPDATE报文出错 4：Hold timer超时 5：有限状态机出错 6：拆除连接 子类型错误码： BGP Refresh报文 Marker，Length，Type Address family identifier Reserved Subsequent address family identifier BGP 压缩形式掩码地址对 适应于无类别的寻址方案 传输方式：采用LENGTH-PREFIX方法： LEN：掩码长度 PREFIX：长度可变，根据LEN的值来确定长度 当LEN为零时，表示默认路由 3 BGP 路径属性 路径属性信息 通过路径属性可以提供额外的属性，比简单的DV包含更多信息，包括 Next hop 从本地到达目标的某个路径（路径上每个自治系统的编号） 可以得知路径的来源（来源于EGP还是IGP） BGP路径属性在UPDATE报文格式出现，在attributes后面跟了多个目标（一对多的关系）。这些attributes是后面这些目标公用的，目标的attributes不一样那么必须要分多个UPDATE报文进行通告。 使用路径属性的理由 可以检测到路径中是否包含回路：列出了路径上所有的AS号，若其中有两个号码相同则存在回路 可以帮助接收方实现策略上的约束 可以使得接收方了解到所有路由信息中每一条路由的源（路径是EGP还是IGP获取的） 路径属性包含的内容 包含了如下结构的列表 (type, length, value) type：2字节 length：1~2字节（取决于type中的一个标志） value：总的表项的值由value来确定 type字段 标志位 0：属性是否必须 1：属性是否可以转发 2：属性是否完整 3：属性长度length字段的字节数 5-7：未使用，置零 type值 1：指出路径信息的源 2：到达目标路径上的AS列表 3：到达目标的下一跳 4：MED：自治系统包含多个边界路由器，告知其中较优的 5：本地AS有多个出口，告知其中较优的 6：表示路由汇聚 7：路由汇聚的自治系统的ID 8：通告目标的共有ID 6 BGP 多协议扩展（MBGP） 扩展中的属性 可选属性 不能转发 两种扩展属性的Type （放在BGP Path Attributes中传输） NLRI（type14）可达 - 网络层可达信息 SNPA：子网协议地址（具体的每一个目标，到达这些目标都是通过Next Hop到达） NLRI（type15）不可达 4 BGP存在的问题 BGP不能同时使用到达一个目标的多条路径，对于某个可达的目标网络路径中只能选择一个 BGP不支持自治系统间的负载均衡（这只能将一个AS拆成多个） 针对广域网环境很难做出最优的路由（需要通过管理人工设置） 在通告可达性的时候所有自治系统需要一致同意这个方案，BGP很难保证全球一致性 5 因特网路由的体系结构与注册的数据库 目标：保证路由信息的全球一致性 当前因特网路由的体系结构 大的服务商连到NAP（网络访问点）上，通过NAP来接入到因特网。 NAP也成为IXP（因特网交换节点）。 通过NAP相连，不同的因特网服务商通过相互之间建立的对等关系来交换路由信息。 不同的服务商之间的关系：上下游关系，中间转发关系 采用路由注册数据库服务 （使用局部数据库） 但是会出现“黑洞”现象：通告了不可达的地址 参考资料： INTERNETWORKING WITH TCP/IP PRINCIPLES, PROTOCOLS, AND ARCHITECTURE Vol1 (6th Edition). DOUGLASE E. COMER]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
        <tag>BGP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP 路由选择，核心网，对等网和相关路由算法]]></title>
    <url>%2F2020%2F07%2F20%2FTCP-IP-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%EF%BC%8C%E6%A0%B8%E5%BF%83%E7%BD%91%EF%BC%8C%E5%AF%B9%E7%AD%89%E7%BD%91%E5%92%8C%E7%9B%B8%E5%85%B3%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[路由选择，核心网，对等网和相关路由算法 路由表（转发表）包含的内容 路由表中内容的获取 转发表的来源 在OS启动过程中，获取初始化表项 更新过程： 第一个表项：目标在本地网络直接转发 第二个表项：默认路由 路由器也可以使用默认路由 使用部分信息进行转发 主机：可以使用（相比路由器对网络的了解要少很多，可以依赖路由器） 极限情况下只有两个表项（两条路径）：一条路由对应接口所连接的网络（本地网络），另一个是默认路由 路由器：也可以使用默认路由。一般包含对网络完整的了解 1 全局星型拓扑：适用于小型网络，不适用于类似因特网的大型网络 2 所有交汇点列出全部网络信息：路由器间信息交换量过大 3 分半：方案可行 原始的因特网路由架构 因特网最早建立在ARPANET的主干上，随着网络规模增加，手工配制方式不可行 ARPANET到达一定规模后的路由架构：（核心与非核心路由器） ​ 核心是一些中心路由器，剩余大部分属于外围路由器。中心主干网的路由器较少，所以他们将主干网上的所有路由信息列进路由表。外围路由器连到核心网中，向核心网路由器提供一些部分路由信息（默认路由） 优点：外围网络变化不影响其他网络 缺点：会造成不一致性 核心路由器不能采取部分信息进行路由：会出现低效的情况（甚至形成环路）。所以要求核心路由器之间必须相互交换完整的路由信息。 核心路由结构发展为对等网路由结构 NSFNET作为主干加到原来ARPANET的主干上 加入的方法：开始网络规模不大，通过一个核心路由器的方式加入，要求核心的路由器有明确的表项明确指向NSFNET中的所有目标，对于非NSFNET的目标通过默认路由到达。随着NSFNET规模增加后，变成了多个路由相连，发展成了对等网路由的结构。 出现问题：存在多条路由路径。 需要对全局网络达成一致的协议，避免路由回路问题 路径（路由信息）传播 路由协议算法 路由协议两个功能 1 计算最短路径：是一个路径的集合（不止一条，有多条 2 若网络中发生路由节点变化，需要对网络拓扑进行更新（动态的方式 路由协议独立于路由器的转发机制：路由器转发时依据转发表进行转发路由协议：目的是 产生/更新 转发表 区分 转发表 与 FIB（转发信息库） FIB，FIB是转发信息库。转发表从FIB获取信息，路由算法会从FIB中选取合适的内容添加到转发表当中去路由策略：人为设置一些添加的条件 路由算法 DV：距离矢量路由(BellmanFord) 本地路由器在本地FIB列出一些一致的路径（到达某些目标一致的表项） 表项在初始化的时候包含直接相邻的网 更新消息：邻居路由节点之间周期性交换路由表（将FIB发送给邻居节点） 更新本地路由表：1 选择到达目标的路径更短 ，2 新表项加入 ， 3 路径变化 不适用于网络规模扩大：更新消息内容与网络规模有关 LS：SPF路由（最短路优先） 需要网络中的路由需要对整个网络拓扑有一个完整的了解 任务： 1 检测邻居的活动 2 将了解到的路由状态信息告诉其他路由器：采用洪泛（只告知状态信息而非路径信息） 若链路状态发生变化，更新消息 路由协议的可靠性 封装在IP层协议 -&gt; 封装在传输层协议进行传输 如果采用不可靠传输协议出现差错，需要路由协议本身解决： ​ 解决方法：1 对传输的报文进行校验 2 软状态方法（带有重传的肯定确认方法） 3 序号编号 参考资料： INTERNETWORKING WITH TCP/IP PRINCIPLES, PROTOCOLS, AND ARCHITECTURE Vol1 (6th Edition). DOUGLASE E. COMER]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
        <tag>路由算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP 传输控制报文协议]]></title>
    <url>%2F2020%2F07%2F10%2FTCP-IP-%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E6%8A%A5%E6%96%87%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[TCP 可靠的流传输服务 概述 传输控制协议，字节流服务适用于其他不同类型的网络传递服务 可靠传输的特性 1 面向流的服务（比特流、字节流）2 采用虚电路方式（逻辑连接，面向连接的传输服务）3 通过缓存技术传输（考虑到传输的效率） Push机制：设置后不会放在缓存中，数据立即发出（不放到发送缓冲区），直接向应用递交（不放到接收缓冲区）4 非结构的流（不是以记录为单位的流服务）5 提供全双工的通信方式，每个方向相对独立（首部有两个序号：发送序号和接收序号） 确认：采用 捎带（piggybacked）技术，把确认放在发给对方的数据报文当中，进行确认。目的是提高传输效率。 提高可靠性的方法 带有重传的肯定确认接收方收到数据时给出肯定确认，发送方对于每一个发送出去的数据报文都启动一个定时器（时钟）来跟踪发送的报文（跟踪对其的确认），一旦超时则重传 超时和重传 接收方收到的报文可能重复，涉及设置超时的间隔的问题。如果超时间隔设置的过小，会产生过早超时问题，带来重复接收的问题。判定重复方法：在报文首部增加序号字段，每个报文给一个不同的序号，向发送方返回的确认也可以带上序号。 滑动窗口 对比停等：提高带宽的利用率，发送方可以连续发送多个数据报（窗口取值大于1窗口（未确认的包数）的最大值不能超过序号空间（序号空间的大小，取决于包首部序号值的位数） 如果超过序号空间，则未确认的包中至少有两个包的序号是相同的，接收方无法做区分 分组首部包含kbit的序列号，序号空间为2^k针对 回退N协议：窗口大小不能超过序号空间针对 选择重传协议：窗口大小不能超过序号空间大小的一半 接收方也存在一个窗口，与发送方相对应也是一个滑动窗口 TCP协议 TCP标准包含： 数据报和确认格式 过程可靠 区分主机上的多个不同目标 差错恢复 进行连接的管理（连接的初始化，关闭等） TCP不包括： 没有定义与应用之间的细节 对于底层网络没有特殊要求 分层 属于传输层TCP提供面向连接的虚电路服务（字节流服务使用TCP服务，多个应用可以进行同时的通信。此处多路复用与解多路复用的依据是端口号 段，流和序列号 TCP的传输单位：段 TCP提供一种流的服务，数据流包含在段内进行传输 TCP段 封装在 IP分组的数据区 需要考虑的问题：1 如何提高传输效率？2 如何流量控制？（因特网中不同主机的收发速度、主机间的通信路径负荷等因素） 解决方案：滑动窗口协议 TCP滑动窗口中，窗口的大小在不断变化，接收方需要告诉发送方通过窗口通告方式：接收方发送确认来告诉发送方（确认包中有一个窗口通告值，表示当前窗口剩余大小）从而实现流量控制。 在TCP的改进方案中有显示拥塞控制机制。 TCP 段格式 传输的数据单位是 段 作用：创建连接、传输数据段、进行确认、通告本地窗口大小等（很多不同类型的段来完成不容类型的功能） 段格式： 源端口 目的端口 (seq)序号 32bit：发送序号 (ack)确认号 32bit：接收序号 HLEN 4bit：TCP段的首部长度，是以字节为单位 保留 6bit Code Bits：TCP标志 6bit，表示TCP段的类型 WINDOW：16bit，向发送方通告本地接收缓冲区的大小 报文校验和 16bit 紧急指针 16bit -&gt; 联合code bits中urgent标志使用 选项 20bit Padding填充 数据 Code Bits字段 URG：紧急指针ACK：确认PSH：带有PUSH标志的段要求不能进行缓存处理RST：立即拆除原来建立的一条连接SYN：创建连接并进行序号的同步（发送方接收方之间建立连接时，选择自己的初始序号并告诉对方FIN：指双方在传输完毕数据后双方切断连接 Out of Band Data（带外数据） 普通数据的传输占用了一条连接，控制数据优先级高于普通数据，这些控制数据不收流量约束机制的限制（实际上是TCP中带内数据：可以在普通数据中加入一些控制数据，夹杂在普通数据流里，但是会优先处理） 选项字段 格式：kind（1字节）+ length（1字节）+info（可变字节），长度可变 MSS：最大报文段长度。TCP中最初规定的一种选项，kind=2 MSS告诉对方TCP：本方能接收的报文段的数据字段的最大长度是MSS个字节 MSS与链路层MTU相关 一些其他选项： Windows Scale：kind=3，对TCP首部的Window的扩充（针对于网络延迟长但是带宽高的网络，需要提高窗口值） TimeStamp：kind=8，时间戳，计算RTT等、当序号到达最大值时翻转为0时提供时间戳可以序号进行大小的判断 SACK：kind=5，可以进行选择性的确认，通过SACK支出接收块中缺少了哪些 …… TCP Checksum字段 算法：将被校验的序列看成16位的整数序列，求这个序列反码和的反码 计算的时候需要使用伪头（与UDP相同） IPv4的TCP伪首部格式： 与UDP的伪首部的区别在于协议号，TCP报文长度字段不同。 同样，IPv6的TCP伪首部格式： ACK TCP中不以段为单位进行编号，以字节为单位进行编号1 因为每个段所带的数据长度不一样；在重传时，所带数据比原来的段还要多一些。若以段为单位进行编号，此时就很难去区分数据长度的不同。2 所以针对字节流，TCP设定字节流起始位置。所以，TCP中的序号是对于数据流中的每个字节编号。 确认的序号：所收到段的最后数据字节的序号。在实际给确认值时，还需要在其基础上加一，表示下一次期待的段的号码。 积累方式的确认：当前号接收正确，当前号之前的也都接收正确 接收对于接收到的段还需要进行重新排序后，再递交给上层的应用 接收方给的确认：收到连续字节流中最后那个字节的序号 (如果发送方发送五个段，接收方只接收到了后面四个，那么接收方还是返回第一个段的起始位置。发送方接下来重新发送全部五个段，或者停止发送等待接收方返回的确认。这会造成效率低下的问题。) 超时和重传 TCP每发送一个段就启用一个时钟跟踪，如果超时前时钟确认未收到则重新发送由于因特网中有很多异构的网络，在这些网络上的网络延迟不相同，所以对超时时间的设置算法需要有自适应的能力 设定超时重传依据RTT RTT样本采用样本估算方法采用加权平均方法： RTT = (aRTT原来的数值)+((1-a) 新的RTT样本)设置超时时间 Timeout = B * RTT （其中B为大于1的常数） 样本估算 Karn算法 对重传的样本不做统计 但是在初始时都是重传样本，此时RTT就一直得不到调整，那么时钟就可能一直超时产生持续的重传，所以此时采用时钟退避。 时钟的退避若样本是重传样本，则对Timeout做调整（例如，乘以2） 网络延迟的方差问题 网络延迟的方差指的是网络延迟的变化率。方差大则出现抖动，使用方差替代常量调整RTT RTT的变化往返延迟的方差与 1/(1-L) 成比例，L是当前网络负载 最初TCP标准估算平均RTT的方法设置 B 为2，此时网络负载最多到达30% 之后标准采用一个方差来替代 原来的常量B 对超时时钟间隔的设置： DIFF= SAMPLE- Old RTTSmoothed RTT= Old RTT + δ DIFFDEV= Old_DEV +ρ (|DIFF| - Old_DEV)Timeout = Smoothed RTT + η DEV DIFF：样本和旧的RTT间的差异DEV：平均偏差δ：在0-1之间，对加权平均值Smooth RTT进行控制ρ：在0-1之间，对偏差DEV进行控制η：控制平均方差DEV对Timeout的影响 拥塞处理 造成重传，增加延迟，甚至出现拥塞崩溃 解决方案 降低传输速率 (过时）ICMP中source quench报文通知主机出现网络拥塞，让源站减缓发送过程 TCP处理方法 (AIMD) 乘法减（muldec）：以乘上一个系数的方式来减少，一般情况下减半接收方窗口大小：在收到报文后返回的确认中通告给发送方拥塞窗口：在发生拥塞状况的时候引入的窗口值，此时发送方发送的数据要有接收窗口大小和拥塞窗口大小来决定。发送方一般做法是取这两个窗口值的小的。TCP判断拥塞的方式：检测到丢包情况。（可能会出现震荡现象） 慢启动发送拥塞，将窗口降为1，之后不断增加2的倍数段如果窗口值到达最初设定的窗口值的一半，此时进入拥塞避免阶段（在所有段的确认都收回时，窗口值加一） TCP 快速恢复 Fast recovery：快速恢复 如果丢包现象不是经常发生，则可以采用启发式的测略 如果接收方收到三次重复的确认，则启动快速恢复。（此时往往比超时重传快） 快重传不同版本： Tahoe： 传统的处理，AIMD Reno： 窗口中丢失了一个报文段的情况 NewReno： 相比Reno处理一个报文的丢失，NewReno可以处理两个报文的丢失。 两个段丢失时，确认返回有两种情况： ​ 1 如果确认在窗口尾部的号码时，表示只丢失了一个段 ​ 2 如果确认的序号比丢失的号码大但是比窗口尾部的号码小，表示丢失了第二个段 Vegas：用平均估算RTT的值来替代丢包的情况 TCP显示反馈机制 标准TCP协议中没有显示的拥塞反馈机制 TCP中两个相关的技术： SACK选项：选择确认​接收方收到发送方发来的不连续的段，SACK选项说明从一个序号到另一个序号的段已经收到了，发送方只重传空缺的数据。 ECN：显示拥塞通告，直接显示反馈 采用ECN测略需要修改TCP协议和IP协议 （利用协议首部未定义的字段） 在IP协议首部的TOS字段中，最低的两位被定义成ECN 在TCP协议首部的保留字段中，使用其中的两个bit，一个bit是CWR位：表示发送方的拥塞窗口减少了，另一个bit是ECE位：显示拥塞通告 12ECN扩展功能表述主机A向主机B发送报文。在中间路径的路由器上发生拥塞。IP分组达路由器后，路由器将分组首部的TOS字段中的ECN两位都置为1，然后转发出去。在主机B收到这个报文后，发现链路上发生拥塞，此时向主机A返回的确认报文中首部的ECE位置为1，通知主机A发生网络拥塞。主机A在收到主机B发来的确认包后，将自己的拥塞窗口减半。将接下来要发出去给B的TCP数据段首部中的CWR置为1表示要将拥塞窗口减半。 拥塞处理策略 中间路由器拥塞的状况 tail-drop：后来的全部丢弃 如果被丢弃的报文段属于一个相同的TCP连接，则发送方进入慢启动状态 如果被丢弃的报文段属于多个不同的TCP连接，则这些连接都进入了慢启动状态，称为：全局同步（此时网络性能大幅降低） random Early Detection：用于取代tail-drop的策略系统内设置两个阈值：最小值Tmin和最大值Tmax RED的处理原则：（关键时Tmin，Tmax和概率p的设置） 1 队列长度小于Tmin，则报文加入2 队列长度超过Tmax，则报文丢弃3 选择随机以概率p丢弃 TCP连接管理 连接建立和拆除 建立连接 两次握手存在的问题 发送方的连接请求可能是重传的，这会进行重复的建立连接 三次握手 1234- 1 Send: SYN seq &#x3D; x （x的选择只与site1有关，这是一个初始的序号）- 2 Recv: SYN Send: SYN seq &#x3D; y, ACK x+1 (y的选择只与site2有关，假设将SYN标志看成1个字节的数据)- 3 Recv: SYN, ACK Send: ACK y+1- 4 ACK TCB (传输控制块：一个数据结构) 说明 序号的选取问题双方选取的初始序号，是各自根据本地情况来选取的。初始号的选取具有一定的随机性，只有在连接的时候会涉及到初始序号的选择问题。涉及到安全问题：若第三方非法用户，需要知道通讯双方的初始序号 数据的携带问题一般情况下，seq段不带数据。如果携带数据，这些数据会先缓存起来，直到三次握手成功后才进行发送和接收。一般在通讯中，最后的ACK段会携带数据 关闭连接 正常关闭：gracefully 一个方向上的关闭不影响另一个方向的数据流 原来缓冲区的缓存数据仍需要发完 将段的首部FIN标志置1，对方收到FIN会回复一个确认，收到确认后，两个方向的数据全部断开，总共4次握手（若是3次的情况，则为修改过的断连握手过程） 理解成两个方向上的断连 标准的断连过程 123456789- 1 Send: FIN seq &#x3D; x- 2 Recv: FIN Send : ACK x+1 （FIN标志在协议中也算作一个字节）- 3 Recv: ACK- 3 Send: FIN seq &#x3D; y ACK x+1- 4 Recv: FIN, ACK Send: ACK y+1- 5 Recv: ACK&#x2F;&#x2F; 若3次，则两个3操作合并为一次操作（site1断连的时候恰好site2中没有数据在发送） 突发式的关闭： RST 粗暴的关闭 应用：在出口安装一个设备，检测每一个包，检测目标IP是否属于黑名单，是则向用户发送一个RST 断开连接 TCP State Machine 有限状态机 TIMED WAIT ：等待两个段的生命期在子网中存储起来，突然冒出，则会造成错误接收1 一方向另一方发送的数据段2 接收方返回的确认段 强迫数据传输 一般将数据存到缓存中等到缓存满时再发送出去，使用Push标志后立即发送 实时应用：例如ssh远程连接 TCP性能问题 协议的最大吞吐量： 两个站点在10M的以太网下最大可以到达8M 收发双方应用的速度不一样导致一些性能问题。 SWS：傻窗口综合征 信道利用率几乎为零 避免SWS Nagle算法：主要是进行缓存的积累 发送方避免：发送方使用缓冲区积累一定长度的数据量 针对不同的应用等待不同的时间 延时时间的处理： ​ 在TCP中通过ACK来触发。在确认到达时缓冲区中积累了一定量的数据。 接收方避免：接收方维持一个本地缓冲区空闲空间大小，区域大小放在确认中反馈给发送方，在反馈的时候进行延迟（延迟确认的两个条件）—&gt; 最长等待时间1 缓冲区可用空闲区达到原先缓冲区大小的一半2 接收缓冲区可用空闲区积累到能够放下一个MSS ​ 二者任意满足其一，接收方就可以将这块空闲的区域通告给发送方。（在实现中包括采用一种零窗口探测来避免死锁） 缓冲区暴涨现象 缓冲区大到一定程度时，缓冲区延迟非常长。无法适用实时应用。 参考资料： INTERNETWORKING WITH TCP/IP PRINCIPLES, PROTOCOLS, AND ARCHITECTURE Vol1 (6th Edition). DOUGLASE E. COMER]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
        <tag>TCP</tag>
        <tag>网络拥塞处理</tag>
        <tag>TCP连接管理</tag>
        <tag>TCP性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS8 - PBS Pro 单节点安装]]></title>
    <url>%2F2020%2F07%2F03%2FCentOS8-PBS-Pro-%E5%8D%95%E8%8A%82%E7%82%B9%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[CentOS8 - PBS Pro 单节点安装 1 安装依赖 安装编译所需的依赖 12345yum install -y gcc make rpm-build libtool hwloc-devel \ libX11-devel libXt-devel libedit-devel libical-devel \ ncurses-devel perl postgresql-devel postgresql-contrib python3-devel tcl-devel \ tk-devel swig expat-devel openssl-devel libXext libXft \ autoconf automake 但是这里libical-devel 安装不上需要手动安装 在aarch64架构上： 1sudo rpm -ivh https:&#x2F;&#x2F;rpmfind.net&#x2F;linux&#x2F;centos&#x2F;8-stream&#x2F;AppStream&#x2F;aarch64&#x2F;os&#x2F;Packages&#x2F;libical-devel-3.0.3-3.el8.aarch64.rpm 然后，就“依赖递归”了，可以编写脚本递归安装 安装运行所需的依赖 12$ yum install -y expat libedit postgresql-server postgresql-contrib python3 \ sendmail sudo tcl tk libical 2 创建非root用户，下载源码 创建用户 12$ sudo addusr -m stu$ sudo passwd stu 下载源码 12$ git clone -b release_20_0_branch https:&#x2F;&#x2F;github.com&#x2F;openpbs&#x2F;openpbs.git$ cd openpbs 3 编译和安装 123456$ .&#x2F;autogen.sh$ .&#x2F;configure --help # 这里查看编译选项$ .&#x2F;configure --prefix&#x3D;&#x2F;opt&#x2F;pbs$ make$ sudo make install 4 配置 12345$ systemctl stop firewalld.service # 关闭防火墙$ sudo &#x2F;opt&#x2F;pbs&#x2F;libexec&#x2F;pbs_postinstall # 执行脚本初始化节点$ sudo vi &#x2F;etc&#x2F;pbs.conf # 单节点：将PBS_START_MOM设置为1，将server作为计算节点$ sudo chmod 4755 &#x2F;opt&#x2F;pbs&#x2F;sbin&#x2F;pbs_iff &#x2F;opt&#x2F;pbs&#x2F;sbin&#x2F;pbs_rcp 5 启动服务 1$ sudo &#x2F;etc&#x2F;init.d&#x2F;pbs start 应用PATH或者MANPATH更新 1$ . &#x2F;etc&#x2F;profile.d&#x2F;pbs.sh 6 创建节点和工作队列 1234$ sudo &#x2F;opt&#x2F;pbs&#x2F;bin&#x2F;qmgr qmgr: create node hostname qmgr: create queue workq queue_type&#x3D;e,enabled&#x3D;t,started&#x3D;t qmgr: ^D 7 测试 测试在非root用户下提交作业 1234$ su stu$ qstat -a$ echo &quot;sleep 60&quot; | qsub$ qstat -f Job_ID 8 一些问题 8.1 关于 qstat:cannot connect to server 检查hosts文件，将IP地址与主机名添加进去 12$ uname -a$ sudo vi &#x2F;etc&#x2F;hosts 8.2 关于qmgr:cannot connect to server node 检查node节点pbsnodes -a 删除重新创建 1234$ sudo &#x2F;opt&#x2F;pbs&#x2F;bin&#x2F;qmgr qmgr: delete node hostname qmgr: create node hostname qmgr: ^D 8.3 关于node节点 state != free 同上，删除节点重新创建 正常情况： 12MOM &#x3D; hostnamestate &#x3D; free 8.4 其他 12345$ tail 10 &#x2F;var&#x2F;spool&#x2F;pbs&#x2F;server_logs&#x2F;20200610 # 查看日志$ qmgr set queue workq resources_max.walltime &#x3D; 120:00:00 # 设置单个节点最大运行 set node localhost.localdomain max_user_run&#x3D;1 # 设置最大的任务运行数为1 参考资料： 1 https://github.com/openpbs/openpbs 2 https://github.com/openpbs/openpbs/blob/master/INSTALL 3 https://pkgs.org/ 4 https://rpmfind.net/linux/RPM/index.html 5 http://community.pbspro.org/]]></content>
      <categories>
        <category>Parallel Computing</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Centos8</tag>
        <tag>PBS Pro</tag>
        <tag>Configuration</tag>
        <tag>aarch64</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[根据匹配点估计相机运动]]></title>
    <url>%2F2020%2F07%2F03%2F%E6%A0%B9%E6%8D%AE%E5%8C%B9%E9%85%8D%E7%82%B9%E4%BC%B0%E8%AE%A1%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[根据匹配点对估计相机运动 2D-2D：对极几何 3D-2D：PnP 3D-3D：ICP 2D-2D：对极几何 1 对极约束 极线：在对极几何约束模型中，若不知道p与p2，那么p1对应所在I2平面的位置就在极点e2出发的一条射线上，具体就是e2(p2)所在的直线上。（其中，p1,p2都是p在对应平面上的投影点） 实践中已知量：p1,p2 //通过特征匹配确定 未知量：p, e1, e2 待求量：相机的运动 T12，p 约束模型中两个像素点 $p_1,p_2$ 的关系， s_1p_1 = KP_w\;,\;s_2p_2 = K(RP_w+t)其中，s1，s2是世界坐标中的z轴坐标，是一个尺度。前一个等式为P在l1上的直接投影，而后一个等式是在相机内参不变的情况下在前一个等式两边增加一个变换矩阵T，根据P在l1的投影得出相机运动后P在l2的投影。 对极约束关系式： x_2^Tt^\wedge Rx_1=0 \tag{1} p_2^TK^{-T}t^\wedge RK^{-1}p_1=0 \tag{2}另 $E=t^\wedge R$（本质矩阵），$F=K^{-T}EK^{-1}$（基础矩阵） \Rightarrow x_2^TEx_1=p_2^TFp_1=0然后通过匹配的特征点对求出E或F，进而求出R，t 2 本质矩阵 八点法求解本质矩阵 通过八对特征点，建立八个方程，将本质矩阵以八个自由度计算，最后再对计算结果优化，使矩阵满足本质矩阵只有五个自由度的性质。 SVD分解求解相机运动 R，t \begin{align} & E=U\Sigma V^T\\ \Rightarrow\;& t_1^\wedge,t_2^\wedge=UR_Z(\pm\frac{\pi}{2})\Sigma U^T\\ & R_1,R_2=UR_Z(\pm\frac{\pi}{2})V^T \end{align}其中，V、U为正交矩阵，$\Sigma=diag(\sigma, \sigma,0)$是一个对角矩阵，最后一维为0表示相差一个尺度，若求出的不满足这个形式，则调整前两维相等，最后一维为零。 3 单应矩阵 三角测量 s_2x_2=s_1Rx_1+t\; \Rightarrow\;s_2x_2^\wedge x_2=\underline{0=s_1x_2^\wedge Rx_1+x_2^\wedge t}得到一个超定方程，用最小二乘求解 或者 \begin{align}s_2x_2-s_1Rx_1+t \;& \Rightarrow\;\left\{\begin{matrix}s_2x_2^Tx_2-s_1x_2^TRx_1=x_2^Tt\\ s_2(Rx_1)^Tx_2-s_1(Rx_1)^TRx_1=(Rx_1)^Tt\end{matrix}\right.\\&\\& \Rightarrow \begin{bmatrix}x_2^Tx_2 & -x_2^Tx_1\\ (Rx_1)^Tx_2 & -(Rx_1)^TRx_1\end{bmatrix}\begin{bmatrix}s_1\\ s_2\end{bmatrix}=\begin{bmatrix}x_2^Tt\\ (Rx_1)^Tt\end{bmatrix}\end{align} \tag{Cramer's Rule} 参考资料： 视觉SLAM十四讲：从理论到实践（第2版）. 高翔.]]></content>
      <categories>
        <category>SLAM</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>Math</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩阵微分]]></title>
    <url>%2F2020%2F07%2F03%2F%E7%9F%A9%E9%98%B5%E5%BE%AE%E5%88%86%2F</url>
    <content type="text"><![CDATA[矩阵微分 矩阵对于数量变量的微分 \begin{align}& A=[a_{ij}(t)]_{m\times n}\\\Rightarrow&\frac{dA}{dt}=[\frac{da_{ij}(t)}{dt}]_{m \times n}\end{align} \tag{0}运算法则 \begin{align} &A是n阶常数矩阵 ,\\ (1)\;&\frac{d}{dt}e^{tA}=Ae^{tA}=e^{tA}A\\ (2)\;&\frac{d}{dt}\cos(tA)=-A\cdot\sin(tA)=-\sin(tA)\cdot A\\ (3)\;&\frac{d}{dt}\sin(tA)=A\cdot\cos(tA)=\cos(tA)\cdot A\\ \end{align} 数量函数对于向量/矩阵的微分 $f(x)=f(x_1,x_2,\cdots,x_n),\;x=[x_1,x_2,\cdots,x_n]^T$ \frac{df(x)}{dx}=[\frac{\partial f}{\partial x_1}\;\frac{\partial f}{\partial x_2}\;\cdots\;\frac{\partial f}{\partial x_n}]^T\tag{1} \frac{df(x)}{dx^T}=[\frac{\partial f}{\partial x_1}\;\frac{\partial f}{\partial x_2}\;\cdots\;\frac{\partial f}{\partial x_n}]\tag{1}定义为梯度：$grad[f(x)]= \bigtriangledown f(x)$ 向量函数对于向量的微分 $a(x)=[a_1(x)\;a_2(x)\;\cdots\;a_m(x)]^T,\;x=[x_1\;x_2\;\cdots x_n]^T$ \frac{da(x)}{dx^T}=\begin{bmatrix}\frac{\partial a_i}{\partial x_j}\end{bmatrix}_{m \times n}\tag{2} \frac{da^T(x)}{dx}=\begin{bmatrix}\frac{\partial a_j}{\partial x_i}\end{bmatrix}_{m \times n}\tag{2}注：$a_i(x)$是关于 $x_1,x_2,\cdots,x_n$ 的函数，（2）中的矩阵称为雅克比矩阵 矩阵函数对于向量的微分 A(x)=\begin{bmatrix} a_{11}(x) & a_{12}(x) & \cdots & a_{1l}(x)\\ a_{21}(x) & a_{22}(x) &\cdots & a_{2l}(x)\\ \vdots & \vdots & \vdots & \vdots\\ a_{m1}(x) & a_{m2}(x) & \cdots & a_{ml}(x) \end{bmatrix}_{m \times l}对 $x=[x_1\;x_2\;\cdots x_n]$ 求微分 \frac{dA(x)}{dx}=\begin{bmatrix} \frac{\partial A(x)}{\partial x_1}\\ \frac{\partial A(x)}{\partial x_2}\\ \vdots\\ \frac{\partial A(x)}{\partial x_n} \end{bmatrix}_{nm\times l} \tag{3}对 $x=[x_1\;x_2\;\cdots x_n]^T$ 求微分 \frac{dA(x)}{dx}=\begin{bmatrix} \frac{\partial A(x)}{\partial x_1} & \frac{\partial A(x)}{\partial x_2} & \cdots & \frac{\partial A(x)}{\partial x_n} \end{bmatrix}_{n\times ln} \tag{3}对一个变量 $x_t$ 微分 \frac{\partial A(x)}{\partial x_t}=\begin{bmatrix} \frac{\partial a_{ij}(x)}{\partial x_t} \end{bmatrix}_{m \times l} \tag{3}复合函数微分 $f=f(Y),Y=Y(x)$ \begin{align} & \frac{df}{dX}=\frac{dY^T}{dX}\frac{df}{dY}\\ & \frac{df}{dX^T}=\frac{df}{dY^T}\frac{dY}{dX^T} \end{align} \tag{4}$f=f(X,Y),Y=Y(x)$ \begin{align} & \frac{df}{dX}=\frac{\partial f}{\partial X} + \frac{dY^T}{dX}\frac{\partial f}{\partial Y}\\ &\frac{df}{dX^T}=\frac{\partial f}{\partial X^T} + \frac{df}{dY^T}\frac{\partial Y}{\partial X^T} \end{align} \tag{4}求导法则： (A^{-1})'=-A^{-1}A'A^{-1}导数与微分的联系（迹技巧）： 矩阵形式 df=tr(\frac{\partial f}{\partial X}^TdX)向量形式 df=tr(\frac{\partial f}{\partial x}^Tdx)函数对矩阵 若标量函数f是矩阵X经加减乘法、逆、行列式、逐元素函数等运算构成，则使用相应的运算法则对f求微分，再使用迹技巧给df套上迹并将其它项交换至dX左侧，对照导数与微分的联系，即能得到导数 特别地，若矩阵退化为向量，对照导数与微分的联系 先对特征式求导，再用迹技巧求微分 矩阵对矩阵 参考： 矩阵求导术（上） - 长躯鬼侠的文章 - 知乎 矩阵求导术（下） - 长躯鬼侠的文章 - 知乎]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP 用户数据报协议]]></title>
    <url>%2F2020%2F07%2F03%2FTCP-IP-%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[用户数据报协议 传输层的协议 区分统一主机的应用 对于通讯而言（最终目标）：区分任务 UDP 用户报文协议 无连接的服务，不可靠的传输，由应用解决差错 报文格式 结构 ： 首部 + 数据 首部：源端口号，目标端口 (16bit)UDP报文长度：长度包括了头部的长度UDP报文校验和 （整个报文+伪头部） （针对IP的扩展，校验自身报文确保数据的完整性）Checksum：实现的时候如果值为零，双方则在通信的时候默认不校验。 UDP伪首部：加入通讯双方的IP地址，将通讯双方明确的区分IPv4伪首部格式： 源IP 目标IP 报文的协议号（同于 IP协议的协议编号字段protocol）（UDP对应值为17） 报文长度：指收到的实际的报文长度 （分组发送的时候不包含伪首部，仅仅用在校验的计算） IPv6伪首部格式： NEXT HEADER 字段填写的与UDP的协议号一致 (17) UDP 协议的封装关系 123456UDP：message，user datagram protocolUDP报文封装在IP数据区 层与层之间提供服务接口UDP -&gt; 确定主机内的一个进程IP -&gt; 确定一个主机 UDP 多路复用 与 解多路复用 依据：端口号 发送方：收到报文后交付IP层再交付到链路层 接收方：根据分组的首部协议号交给UDP模块处理，UDP根据端口号交给对应的应用进程接收队列（关联应用进程，队列长度有限 端口号的获取 123451 中心管理机构统一分配（全球分配方法，well-known）2 动态分配（进程服务器动态分配） 客户端先与进程服务器联系 进程服务器收到客户端请求后，会动态的将进程服务启动 再将动态分配的端口号反馈给客户端 参考资料： INTERNETWORKING WITH TCP/IP PRINCIPLES, PROTOCOLS, AND ARCHITECTURE Vol1 (6th Edition). DOUGLASE E. COMER]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
        <tag>UDP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP IP差错控制协议]]></title>
    <url>%2F2020%2F07%2F03%2FTCP-IP-IP%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[IP差错控制协议 ICMP-因特网控制报文协议差错控制，是IP的补充 ICMP传输方法 12通过IP来发送，封装在IP的数据区发送的信息包括一些差错和控制信息 ICMP提供的功能 属于报错的功能，只进行报错不进行纠错 只将差错报告给原始的发送者（源节点） ICMP报文传输 12345ICMP封装在IP数据区，但只是IP的补充非IP的上层协议对ICMP报文的错误不再产生ICMP报文 IPv4：IP首部protocol字段，ICMP在其中占据了一个位置 |value -&gt; 1|IPv6：NEXT HEADER |value -&gt; 58| ICMP报文格式 TYPE ：8bit ，报文的大的类别 CODE ：8bit ，大类中的子类 (若没有子类，则为0） CHECKSUM ：16bit ，校验和 （算法与IP的首部校验和算法相同，求16位整数序列反码和的反码） IPv4和IPv6的ICMP报文类型： v6中包含很多简化的工作，（取消v4中的一些类型 MLD ： 组管理协议 -&gt; 对应v4中的IGMP v4中的常用类型： 0 echo (request reply) 3 目标不可达 11 time Execced 超时 （在v6中，很多都借用了ICMP的类型） 一些ICMP报文 ICMPv4报文类型 ICMPv6报文类型 Echo (ping命令：测试IP地址是否响应和可达)(ping中的ICMP -&gt; echo request , echo reply)(不同OS对ping的实现有差异) Echo报文格式 TypeIPv48：请求 Echo request 0：响应 Echo response IPv6128：请求 129：响应 Code：可指定数据 Id，Seq：目标用于信息匹配的字段-&gt; 与源站请求的一致，则匹配进行响应 Checksum (16bit)： IPv4：仅仅计算ICMP报文本身进行校验和计算（首部+携带的数据IPv6：还需要加入一个 “伪首部(pseudo-header)”进行计算 （为了统一 TCP，UDP IPv6伪首部格式： 12345678910111213伪头部： 源地址IP 目的地址IP 报文长度（首部+数据 TCP,UDP,ICMP... 上层的协议号（对v6而言：nextheader字段，对v4而言：protocol字段） 32位长度，不足用0填充 TCP 7 UDP 19 ICMPv4-17 ICMPv6-58 使用伪首部的目的： 1 要与UDP和TCP校验和的算法表示一致 2 区分通信双方以及双方通信所使用的协议 Optional Data：所带数据长度是可变长度，用于给网络管理员测试 目标不可达 报文格式 typeIPv4:16种IPv6：8种 code checksum // 未使用的保留0// 出问题的IPv6报文的前缀部分：首部头+前64bit(IPv4) ICMPv6的最大长度 ​ Source Quench 报文 1拥塞控制相关 Redirect 重定向 发生背景：在通信时，路由器发现有另一条更优的路径，则会通知源端可以下一次路由走更优的一跳，发送一个 redirect ICMP报文 缺点：不能结局所有的路由问题，因为ICMP报文只会发送给源端 ICMP重定向报文格式 IPv6重定向报文格式 Time Exceeded 超时 问题背景： 通信中可能出现路由环路，生命期或跳数耗尽，丢弃报文向源端发送超时报文 报文格式 Type:IPv4 :11IPv6 :3 Code:0: 到达生命期1: 碎片重装超时 Parameter Problem 参数问题 IPv4： IPv6： 例如：取值超范围，不可辨认下一个头部…… Timestamp Request 时间戳 （request reply） 用于主机间的时钟同步 (IPv4) 1 源时间戳 (发送请求的站点填入)2 接收时间戳 （接收者填入）3 传输时间戳 （接收者填入）（2,3 基本一致， 差异主要在1之间，还要将往返时间包括进去） 参考资料： INTERNETWORKING WITH TCP/IP PRINCIPLES, PROTOCOLS, AND ARCHITECTURE Vol1 (6th Edition). DOUGLASE E. COMER]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
        <tag>ICMP</tag>
        <tag>Echo</tag>
        <tag>DU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP IP转发]]></title>
    <url>%2F2020%2F07%2F03%2FTCP-IP-IP%E8%BD%AC%E5%8F%91%2F</url>
    <content type="text"><![CDATA[IP协议：转发IP数据报 因特网中的转发 routing 和 forwarding 的区别 routing指整个从源到目标转发的过程，路由选择forwarding指转发，是路由器本地的操作 IP的目标 对用户而言，构建成一个概念上的虚拟网 转发信息库（FIB） 称为：转发表、路由表一个路由节点在发送IP分组的时候的依据 一些转发难度 进行转发决策时依据的参数处理分组首部服务质量的需求 直接传递和非直接传递 转发过程中的两种形式 直接：节点发送的目标（不一定是最终目标）与自己在同一个物理网络 间接：不在同一个物理网络，转发给下一跳的路由器 1 直接传递（单一网络的传输） 12341 将IP数据报封装在链路层帧中2 目标IP地址映射成对应的物理地址3 由网卡传输出去4 比较网络前缀来确定连在一个网络上，然后与目标之间进行直接传递 2 间接传递 121 发送方必须指出下一跳路由器，2 下一跳路由器继续指定，直到到达目标所在网连接的路由器 表驱动的IP转发 1包含：目标IP与目标主机地址，到达目标的下一跳 默认路由 转发表中的一个重要路由 功能：在转发表中没有找到对应的路由表项，那么任何目标地址都会与默认路由匹配 作用： 12341 合并多个路由的具体表项为一个2 使得转发表变小3 残羹网络中减少大部分表项 残羹网络：与因特网只有一条链接 特定主机路由 表项对应一个特定主机 作用：本地管理网络控制1 便于网络管理2 允许网络测试3 出于安全的控制 IP转发算法 12345678910收到上层的IP分组，需要将其转发1 先从分组首部将目标IP地址抽取出来2 查找转发表 有特定主机路由：转发出去 无特定主机路由：计算出网络前缀，接3、4 目标地址与子网掩码按位与得到网络前缀，将此网络前缀与表项中目标网络地址作比较3 本地网络？-&gt; 本地递交4 非本地网络？-&gt; 查找有无表项与此网络前缀匹配 找到了-&gt; 发往下一跳路由器 找不到-&gt; 转发网默认路由的下一跳（若无默认路由，无法转发，报错） 转发表表项匹配方法 最长前缀匹配： 表项中的子网掩码长的优先匹配 IP地址和转发表 对于分组中字段的修改情况： 1 大部分字段不改动，例如：不改动源地址和目标地址 2 改变TTL，若TTL减一为零则丢弃，首部校验和会改变 下一跳的IP地址如何存放？ （IP地址首部不存储下一跳节点的IP地址） 存储在帧的首部目标物理地址字段 12341 即将被处理的IP地址交到网络接口上进行处理，2 IP地址通过ARP映射到物理地址，此物理地址是帧首部目标的IP地址（下一跳）3 将IP地址放到帧的数据区，构造完整的帧再将其发送出去4 丢弃下一跳地址 节点处理到来的IP分组 链路层将分组交给IP模块 对于一个主机节点：1 检查目标IP地址，匹配（转交高层2 差错情况，丢弃 对于一个路由器节点：IP分组首部的目标地址是否和路由器接口地址匹配？1 匹配，转交处理（一般用于测试的环境2 不匹配则转发，TTL-1，若TTL大于0重新计算首部和然后封装在帧中转发出去，否则丢弃 转发表的获取、初始化、更新 1…… 参考资料： INTERNETWORKING WITH TCP/IP PRINCIPLES, PROTOCOLS, AND ARCHITECTURE Vol1 (6th Edition). DOUGLASE E. COMER]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
        <tag>forwarding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP IP协议]]></title>
    <url>%2F2020%2F07%2F03%2FTCP-IP-IP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[IP协议 无连接的协议 为上层通讯应用提供了最基本的服务 因特网设计的思想 对用户而言 抽象成为一个单一的网络与底层的物理网络无关，运行在任何物理网络之上 从概念上划分层次 应用层要求可靠传输服务 传输层提供增强的传输服务 网际层提供无连接的分组传递服务 IP的目的（主要功能） 1 定义了报文的基本单位2 定义了分组的转发3 定义传输中遵循的一些规则（处理主机、路由器…… ICMP辅助处理差错 因特网数据报（IP分组）格式 帧格式：包含一个首部、数据区、尾部。IP数据报（datagram）格式：包含首部（Header）和数据区（Payload） IPv4报文格式 字段含义 VERS:版本，4个bit HLEN:首部长度，4个bit，以四个字节为一个单位(4*15) Service Type: 12345678910111213141516服务类型 , 8bit,0-2:Precedence 3:D（低延迟） T:4（高吞吐量） R:5（高可靠性）改进：（补充 -&gt; 适应媒体流的传输IPv4 ToSIPv6 Traffic classService Type：0-5 CODEPOINT(DSCP)区分服务代码点：DSCP 对流量进行分类，给不同类别的流量以不同的优先级 低两位为未使用，高三位定义优先级 将高六位进行划分，管理池： pool1: xxxxx0 可以定义32个类别，IETF来定义 pool2: xxxx11 用于本地或实验 pool3: xxxx01 用于本地或实验，可以用于扩充第一个组 Total Length:总长度 Identification:分组分片 Flags: DF（不允许分片）, MF（有更多分片）… Fragment Offset:分片的偏移（重装的时候的偏移量），13bit，分片的长度取8的整数倍 &gt; offset的数值是除以 8的数值，因为8的倍数可以向左偏移三位，与Flags的3位错开 TTL:分组的生命期，8bit（实际用途用于跳数的限制 Protocol:上层协议的编号 Header Checksum:首部校验（求16进制反码和的反码） Source IP Address Destination IP Address Payload IPv6 报文格式 IPv6特点 相比IPv4去掉了很多字段 基本首部固定长度 字段含义 Next Header字段基本首部和扩展首部都包含这样的字段 基本首部 ​ 扩展首部通过Next Header将这些首部链在一起，例如1 基本首部 + TCP报文段2 基本首部 + 路由首部 + TCP报文段3 基本首部 + 路由首部 + 认证首部 + TCP报文段 40个8位长度的IPv6固定长度基本首部格式 VERS TRAFFIC CLASS : 对应v4的ToS FLOW LABEL： 流的标识号，用于取代目标IP，中间转发是根据流的ID进行转发 PAYLOAD LENGTH： 不包括首部的40字节基本长度 NEXT HEADER ： 将首部串到一起（也可以用来指定上层的协议 HOP LIMIT：对应IPv4中的TTL SOURCE ADDRESS 128bit DST ADD 128bit ​ 物理网的最大传输单位 MTU 123太小：降低效率太大：分片问题例如：以太网 MTU&#x3D;1500 IP 分片 IPv4分片 IPv4分片的大小是8的整数倍IPv4在目标节点负责重装，中间路由器不负责重装 IPv6 分片 对于v6不允许中间的路由器分片，所以源站会先找出到目标站路径上的最小MTU 分片功能放到 扩展首部规定只能在源主机进行分片，源到目标主机路径上的路由器不允许分片 Path MTU： 从源到目标所经过的所有链路上MTU中最小的MTU 1234找到 path MTU （PMTUD）, 主机同时周期性进行查询查询过程：二分试探，如果中间传输报文过大，则返回ICMPv6：Packet Too Big 报文ICMPv4：Dest Unreach 报错，（DF 设为 1） IPv6 分片扩展首部 格式 FRAGMENT OFFSET 13bit MF 1bit IDENTIFICATION: 标识号，32bit IPv6 分片的重装 在目标进行重装，中间节点不进行重装 123456缺点： 1 若MTU较大，引起效率低 2 分片数量多后丢失的可能性较大优点： 1 每个分片进行独立路由传输 2 中间节点不需要进行存储 选项 源IP 和 目标IPIPv4选项部分是可变长度的，需要进行填充，填到32bit为止 IPv4选项定义在首部：可变长，一般用来进行测试、调试IPv6首部不包含选项：这些功能被移到了扩展首部 IPv4 选项 （在实际通信中使用较少 选项的组成： option code：定义选项的类型 length：选项总长度 data：数据 选项 Option code字段 8bit 123456780 ： copy copy &#x3D; 0：只有第一个带上原来分组的选项 copy &#x3D; 1：在分片的时候所有分片需要带上选项1-2：Option Class 分成了4类，0、2有定义，1、3保留 option class &#x3D; 0：进行控制 option class &#x3D; 1：调试与测试3-7：Option number IPv4选项举例 记录路由选项： 源站发出分组，初始化一个空地址列表，中间路由器在转发分组时依次加入IP地址 源路由选项 ： 用于吞吐量测试 时间戳选项 IPv6 选项扩展 参考资料： INTERNETWORKING WITH TCP/IP PRINCIPLES, PROTOCOLS, AND ARCHITECTURE Vol1 (6th Edition). DOUGLASE E. COMER]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
        <tag>IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP ARP协议]]></title>
    <url>%2F2020%2F07%2F03%2FTCP-IP-ARP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[ARP 协议 — 将IP地址映射成物理地址 分组带上发送者和接收者地址在帧的首部填上物理地址 问题描述，A和B进行通信A —- BIa —- IbPa —- Pb 一般问题 1 源和目标在同一网段 2 源和目标由路由器相连（跨多个网络） 物理地址/硬件地址 类型 1234567891011121314151617IPv4 总空间32位，无法容纳一个MAC地址在IPv4上的地址映射举例：1 proNET &#x3D;&gt; 接口卡上的开关可以拨动，只有8bit --&gt; 直接地址映射 例如，在IPv4&#x2F;IPv6中可以直接映射实现 配置方案：在IP地址的主机号部分进行一一对应 2 Ethernet &#x3D;&gt; 48位物理地址，无法装载 --&gt; 动态绑定法： ARP协议：先向地址广播一个ARP请求，目标匹配自身IP地址响应ARP请求 跨网发生在每一个子网内 不直接广播IP地址方式的原因： 1 广播不会跨网 2 浪费资源 ARP采用广播方式开销大 ARP Cache：改善ARP性能 先保存目标IP的物理地址，可以使得下一次不需要发起一次ARP请求表项： -&gt; IP , MAC -&gt; TTY维护：使用定时器（典型的生命期是20min，超时删去） 软状态：匿名（当信息发生改变/过时的时候，不会告知相关的节点）缺点：延迟时间较长，例如在出现节点崩溃的情况需要等到节点不活跃时期（到生命期） 改进ARP： 被查询的机器若收到请求则添加到自己的Cache中，所有的本网的节点都收到ARP请求，发送者的地址信息则在本网站点中都更新 同时，机器在崩溃重启的时候向外发送一个ARP请求，此时原先的节点会对自己的表项做一个更新 关于地址映射： ​ 1 ARP只是其中的一种方案，并非所有网络都需要此过程​ 2 ARP的解析属于底层技术，属于底层物理网络有关的部分 ARP 实现 ARP功能的分类 地址的映射 响应ARP请求 ARP过程中的一些分析 1234567891 当用户发送一个报文的时候，需要对地址进行映射；ARP使用cache技术，如果在cache中能够找到地址对，就直接使用；如果找不到，则发送ARP请求。（在发送ARP请求后可能得不到响应，1 请求丢失，2 目标主机处于关机状态）2 发送分组后，在地址解析成功之前分组先被存储到缓冲队列当中（即一个应用还在运行的过程中），如果系统上同时有多个应用都需要解析这样的地址，底层ARP模块要确保不能产生多个这样的请求。3 当ARP响应返回的时候 3.1 需要对ARP Cache进行更新 3.2 上层等待传输的分组得到地址解析结果后，从队列中移除4 收到ARP请求后，进行响应 4.1 从请求报文抽取发送方信息（发送方的IP地址和物理地址），更新本地Cache 4.2 处理分组（响应&#x2F;丢弃） ARP的封装关系 12封装在链路层 帧的数据区中报文TYPE ： 0806H ARP 报文格式 非定长格式因为不同的物理网络报文的长度，格式不一样；网络层上的地址也有多种不同类型的地址，格式也可能不一样 在以太网中的报文格式 Sender HA 6字节（物理地址）Sender IP 4字节（IP地址）Target HA （目标物理地址）Target IP （目标IP地址） HARDWARE TYPE：以太网MAC地址，类型值为1PROTOCOL TYPE：表示网络层的协议类型，以太网0x0800OPERATION：报文类型 1 ：ARP请求 2 ：ARP响应 3 ：RARP请求 4 ：RARP响应 自动缓存再检验 Jitter 抖动现象 123指连续传输的分组从一个站传输到另一个站，接受分组的延迟时间有变化当传输延迟很大时，对某些应用（多媒体应用）造成很大影响所以，需要避免这种抖动。 ARP造成的抖动： 1cache表项中包含和cache表项中映射由于定时器超时失效；当失效时需要重新发起一次ARP请求需要额外的时间解析。 解决方法：early revalidation（早期再检验） 解决思路：减少分组传输中的抖动：延迟时间的变化值 方案：另外设置一个定时器（每个表项都设置一个）：重新验证定时器，超时间隔比原先计时器小一些，如果响应还存在，则重新复位计时器 RARP | RARP -&gt; BOOTP -&gt; DHCP 123456789已知物理地址，求对应的IP地址（是一个反向的地址映射） 针对无硬盘系统: 本地的局域网安装一个RARP服务器，包含一个地址对的数据库，有管理员人工配置绑定表以太网： ARP 0x0806 RARP 0x8035应用场景：虚拟机从一个IP迁移到另一个IP ARP Cache 在3层交换机上的实现 目标：减少ARP的流量 实现举例：A向B发送一个ARP请求交换机先收到A发的ARP请求，查询自己的Cache，若有B的物理地址则向A发送响应（相当于一个代理，一个节流的过程） 代理ARP 作用：将一个IP网络映射到两个物理的网络地址（两个或多个不同的物理子网） 使用范围：应用于使用ARP的网络环境中 分析：运行代理ARP的路由采用了一种说谎的方式1 利用了ARP协议之间的信任2 需要在地址绑定表中插入，在安装的时候合法性与一致性都存在问题3 具体实现上的安全问题，例如Spoofing欺骗 spoofing欺骗：例如：三台机器A，B，C连在一个网络中，A和B通信，C是入侵者，C要截取A和B间的通信。C监听ARP请求，获取到A和B的IP地址和MAC地址，那么此时C可以向B发送ARP请求：IP地址是A的，MAC地址是C的；同样，发给A时IP地址是B，MAC地址是C的；（发送多次才能奏效）；此时，促使了A和B修改了它们的ARP表项。所以A和B中的通信都经过C。 不同的IP地址对应一个同一个物理地址优点：加进一个单独的路由器不会影响网络中的其他节点缺点：1只用于ARP地址解析的场景下 2不适用于复杂的网络 3不支持合理的路由表（受控管理的规模有限） IPv6 邻居发现协议 1234561 IP地址是邻居发现协议（NDP）中的一项功能2 在传输的时候封装在 ICMPv6中3 一般在系统启动过程中执行NDP协议4 一个节点需要周期性的连续的检测邻居的状态5 使用多播6 NDP使用solicited-node（被恳求节点）多播地址 参考资料： INTERNETWORKING WITH TCP/IP PRINCIPLES, PROTOCOLS, AND ARCHITECTURE Vol1 (6th Edition). DOUGLASE E. COMER]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
        <tag>ARP</tag>
        <tag>RARP</tag>
        <tag>ARP Proxy</tag>
        <tag>NDP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP 因特网的寻址方案]]></title>
    <url>%2F2020%2F07%2F03%2FTCP-IP-%E5%9B%A0%E7%89%B9%E7%BD%91%E7%9A%84%E5%AF%BB%E5%9D%80%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[因特网的寻址方案 1 标识一台主机 ​ 名字 -&gt; 对象是什么​ 地址 -&gt; 对象在哪里​ 路径 -&gt; 如何到达对象​ （通过IP地址来进行标识） 2 早期的IP地址方案 有类别的地址方案 长度 32bit -&gt; 对应一个32位的整数 （网络号+主机号） 地址分类：ABCDE，D类为广播地址，E类为保留地址 定义的是主机和一个网络的连接，（例如多接口主机需要多个IP地址） IP地址不是指定具体一台地址，而是连接到网卡的一条路径 具体表示：点分十进制，类别 低地址 高地址A 1.0.0.0 127.0.0.0B 128.0.0.0 191.255.0.0C 192.0.0.0 223.255.255.0D 224.0.0.0 239.255.255.255E 240.0.0.0 255.255.255.254 地址的特殊类别： ​ 1 单播：（不能作为目标地址来使用）​ hostid全为零：本网的网络地址​ 2 广播：（不能作为源地址来使用）​ netid确定情况下hostid全为1：定向广播地址​ 32位全为1：本网有限广播。（在系统启动时若还没得到网络号可以使用此地址进行广播，若得到网络号则用定向广播地址）​ 32位全为0：保留地址（在初始化时节点还未获取IP地址则如此表示）​ 3 多播：（多播是将分组传送到一个指定的主机集合​ loopback（不能上线，逻辑分配的地址，仅在主机内部做测试） 地址方案缺陷： ​ 一台主机从一个网络移动到另一个网络，则它的地址需要重新分配。​ 网络地址数量太多。​ 分类地址规模固定。​ 主机由多个接口时，通信报文传输路径由多条 3 网络字节顺序 ​ 大端存储和小端存储​ 因特网中的传输规则：​ 多个字节的整数，采用大端的形式 4 IPv4子网地址 子网划分（将原来两部分的地址划分成了三部分的地址，是一个分层的结构） 网络号：因特网部分主机号：本地部分 取其中一部分bit出来 来区分本地的不同的物理网络，可以将这一部分看成网络的子网号，剩余部分为主机号 可变长的子网划分 VLSM ​ 背景问题：一个机构内部的网络规模不一样，不同局域网中的主机数量不同。此时，固定长度的子网划分的方法不适用。所以使用可变长的子网划分方法，大的网络的主机号多一些子网号部分少一些，小的网络号反之。​ 缺点：管理员设计不当可能导致地址重复使用​ 优点：可以支持大小网络混合的环境，可以提高地址的利用率 注：VLSM中全0全1地址是可用的，区别于单纯的子网划分 子网掩码（用于指定子网划分） 长度：32bit设定规则：对应IP地址子网部分的bit取1，对应主机地址的部分取0说明：子网掩码和IP地址的类别无关 记法：（两种表示方法） 1 三元组（网络号，子网号，主机号） 缺点：无法得知子网号与主机号的位数 优点：屏蔽底层细节 2 as/24 (CIDR)：整数值为网络号与子网号的位数 5 目标：最小化网络数量 1 对于一个路由表，网络数量增加路由表项也会增加，当增加到一定数量之后路由器无法承受2 地址的消耗问题，尤其是B类地址 解决方案： ​ 无类别的寻址方案：CIDR -&gt; 无类别域间路由​ 1 减少路由表的表项数量​ 2 分配不均​ CIDR的最初应用： ​ 超网分配方案：以多个连续用的C类地址的块来连成一块B类​​ CIDR记法： ​ 斜杠记法，例如 128.211.168.0/21，其中/21表示掩码的21位​ CIDR和VLSM的区别 在使用CIDR聚合地址时，将原来有类IP地址中的网络位划出一部分作为主机位使用。在使用VLSM划分子网时，将原来有类IP地址中的主机位按照需要划出一部分作为网络位使用。CIDR是把几个有类网络合成一个大的网络（超网），用于路由地址聚合。VLSM是把一个有类网络分成几个小型网络（子网），用于更高效划分子网。 IPv6寻址方案 IPv6记法： 采用冒号分十六进制记法将128位地址平均分成8组，每组16位全为零的一组可以直接记成0零压缩记法： 连续全零组记为 :: ，在一个地址中最多只能出现1次CIDR表示：例如 FF05::03/60 IPv6地址空间 前缀 地址类型 地址空间分片010 全局单播地址 1/81111111010 本地链路单播地址 1/102411111111 多播地址 1/256 从IPv4到IPv6的迁移 ​ 高64位全零，中间两个16位为0000和FFFF，低32位是IPv4地址 IPv6单播地址 ​ 高N位为全球路由前缀，中间（64-N）位是子网号，最后64位是接口号 IPv6接口标识和MAC地址 将MAC地址映射成64位接口ID：格式命名为EUI-64 将48位MAC地址映射成EUI-64： （MAC地址： 高24位代表厂家，表示一个机构的唯一标识符，低24位为厂家分配，是接口地址） 1 在MAC地址的高24位和低24位之间插入一个16位的，15个1和1个0（FFFE） 2 将Bit6从原来的0改成1 Bit1：G/L位，表示地址是local的还是global的，一般情况下使用的是global地址为0，所以将此0改为1 Bit0：I/G位，用来表示地址是单播地址还是组播地址全局地址：48位地址局部地址：16位地址 IPv6多播和任播地址 IPv6中没有广播，通过多播的方式来解决 广播的缺点： 1 浪费的资源多 2 广播一般情况下不跨网所以IPv6采用多播来取代广播 协议中预先定义的一些保留的多播组： all routers ： 网上的所有路由器节点 all hosts ： 网段上的所有主机节点 all nodes ： 所有节点 IPv6 Anycast地址 本质上是一个单播地址作用：处理多服务器的情况（handle server replication） 这些服务器以一个逻辑的整体对外提供服务；服务器所有的配置、提供的功能和对外提供的任播地址都是一样的。当用户在访问这些服务器的时候，使用Anycast地址去访问，最后解析出来的地理位置上距离最近的服务器上进行通信。 典型应用例如：DNS服务器 IPv6 Link-Local 地址 用于本地局部使用，不是一个全局地址节点在初始启动时，自动得到一个Link-Local地址 Link-Local地址的类别： 由最高的10位来决定： 1111 1110 10 分组中带有Link-Local地址，报文不会被转发到不同的网络上去。Link-Local地址只局限在接口所在的网段中。 IPv6中接口自动获取地址 1 OS启动激活接口2 构造Link-Local地址3 从48位转换为EUI-64得到接口ID，作为低64位，高10位是Link-Local地址，中间54位全为04 得到此接口上的linklocal地址，接口可以通过此地址与本地链路上的其他节点进行通信5 本地链路中的路由器向外发送一条路由恳求，路由器返回通告包括：全局单播地址的前缀6 全局前缀加上接口ID最终得到全局单播地址 参考资料： INTERNETWORKING WITH TCP/IP PRINCIPLES, PROTOCOLS, AND ARCHITECTURE Vol1 (6th Edition). DOUGLASE E. COMER Understanding IPv6 ,Your Essential Guide to IPv6 on Windows Networks 3rd(2012) . Joseph Davies.]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
        <tag>因特网寻址方案</tag>
        <tag>子网划分</tag>
        <tag>VLSM</tag>
        <tag>CIDR</tag>
        <tag>IPv6寻址方案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP 协议分层]]></title>
    <url>%2F2020%2F07%2F03%2FTCP-IP-%E5%8D%8F%E8%AE%AE%E5%88%86%E5%B1%82%2F</url>
    <content type="text"><![CDATA[协议分层 节点（主机、路由器）上的软件结构 分层的基本原理 IP的实现软件通过分层后便于理解 在此协议架构上，分组传递的路径 1 分层的原因 协议需要解决的问题： 1 硬件故障 2 网络拥塞 3 分组丢失 4 延迟 5 数据污染 6 数据包重复、乱序 ……所以需要分成子问题，再分别对子问题进行解决 2 分层的基本原理 ISO 7-layer (没有具体的实现) - X.25 - （数字通信，非模拟） ​ 物理层： 主机需要与分组交换机连接，（串形线​ 数据链路层： 主机与分组交换机之间传输数据（帧，校验与确认​ 网络层： 定义传输的基本单位（分组 -&gt; 分成几个帧进行传输，处理拥塞问题）​ 传输层： 提供端到端的可靠传输 double check​ 会话层： 处理远程终端接入​ 表示层： 为应用层提供服务（语法转换、数据压缩加密、格式转换等​ 应用层： 用户使用的最终目标 （复杂功能定义在网络核心上） TCP/IP 5-layer（层与层之间的接口 -&gt; 消息，传输分组，IP数据报，帧） ​ 应用层： 应用，（根据自身需求选择传输服务，提供报文的序号，确保传输顺序或是连续的流（流服务）​ 传输层： 端到端的可靠通信​ 网络层： 主机到主机间的通信（传递IP分组，使用路由算法转发）​ （一个节点收到IP分组后：检查IP分组的合法性，选择路由输出接口，ICMP协议报文交换）​ 网络接口层： 将网络层交付来的IP分组在具体的物理网络上传输 （例如在局域网使用MAC协议） （网络的核心功能相对较弱，主要智能部分在传输层以上部分） TCPIP分层传输的两种模型： 1 端到端 （分层原理：接收方收到的东西与发送方收到的东西完全一致） 高层协议（网际层以上的部分 2 机器到机器 网际层（IP分组在进过路由转发TTL时，会减1，发生的数据的改变，所以也是机器到机器 低层（网际层以下 分层的缺点： 效率降低（解决效率问题是跨层优化问题的解决方案） 多路复用 和 解多路复用 上层向下层递交的时候会添加信息，是用来解多路复用的依据 说明： ​ 1 链路层上的传输基本单位为帧，帧的TYPE字段是作为解多路复用的依据。 ​ 例如，TYPE=0x800-&gt;IP, TYPE=0x806-&gt;ARP, TYPE=0x8035-&gt;RARP ​ 2 网络层上传输的IP报文中，首部Protocol字段作为解多路复用的依据。 ​ 例如，protocol=1-&gt;ICMP, protocol=17-&gt;UDP, protocol=6-&gt;TCP ​ 3 传输层上的TCP/UDP报文根据目标端口号来解多路复用，对应到特定的应用。 参考资料： INTERNETWORKING WITH TCP/IP PRINCIPLES, PROTOCOLS, AND ARCHITECTURE Vol1 (6th Edition). DOUGLASE E. COMER]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
        <tag>协议分层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP 底层网络技术概述]]></title>
    <url>%2F2020%2F07%2F03%2FTCP-IP-%E5%BA%95%E5%B1%82%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[底层网络技术概述 分组交换技术 底层硬件技术 网络通信的两种解决方法 ​ 1 面向连接 ： 电路交换 circuit switch，（永久性连接，是专用连接​ 优点：保证网络的带宽​ 缺点：代价高 ​ 2 无连接 ： 分组交换网络 packet switch​ 优点：代价低​ 缺点：无法保证网络带宽，但是可以通过构建高带宽的分组交换网络 网络分类（覆盖范围 ​ WAN​ LAN 网络硬件地址 ​ 不同网络类型的地址格式有差别​ 四种应用的网络​ 以太网 Ethernet​ 无线局域网 Wi-Fi​ ZigBee​ 同步光纤网 SONET 以太网 ​ 分组交换式的局域网​ DIX -&gt; IEEE802.3 以太网不同的媒体方案： 1 粗同轴电缆：10Base5 （10Mbps 500m）收发器transceiver连在电缆上，网卡（网络接口卡）连在主机上，二者间需要一根专门的电缆连接 2 细同轴电缆：10Base2 （10Mbps 185m）收发器集成在接口卡中 3 双绞线：10Base-T有4对双绞线 高速以太网 100Base-T 4 光纤：10Base-F抗干扰强，用于远距离的连接 以太网使用的MAC层协议 ： CSMA/CD，碰撞检测功能接口卡中的收发器：侦听信号的功能 （区分信号空闲或忙碌状态CSMA/CD 要求站点在传输数据帧之前，先要侦听信道的状态 以太网使用PoE技术：Power of Ethernet 小型设备供电支持加载双绞线电缆上对设备进行供电 以太网的特点： 121 带宽的不同种类2 自动协商，例如以双方都能支持的最高速率来进行工作 以太网的重要属性： 1231 广播策略：通信是以广播的方式2 尽最大努力交付3 CSMA&#x2F;CD：媒体访问控制所使用的协议 以太网物理地址（MAC地址 48位 以太网帧格式（单位字节） 12345678目标地址 6原地址 6帧类型&#x2F;数据区长度 2 （但是padding不算在内，数据区长度为0那padding即为46）数据 46 - 1500 （最小46padding）帧校验序列 4 （CRC，由硬件产生）区分类型与长度的方法： 将类型值都取成比1500大的值 无线局域网 Wi-Fi （IEEE802.11） ​ AP + STAs​ Ad Hoc：点对点​ WiMax 802.16 ZigBee 802.15.4 ​ 个域网​ 低功耗的无线网络技术​ 分组长度：127字节​ payload（有效负荷长度）：102字节​ 两种MAC地址格式（长、短）：16位、64位 点对点网络 peer to peer ，无须物理地址来区分 VLAN：虚拟局域网 ​ 配置交换机 -&gt; 将一个交换机看成对个更小交换机的集合​ 每一个VLAN定义一个独立的广播域 底层网络设备 中继器 ​ 工作在物理层​ 延伸电缆长度​ 最多经过四个中继器（12345原则 桥 ​ 工作在链路层，识别帧的格式​ 桥收到一个完整的帧然后转发。整个过程对主机来说是透明的（透明桥） 链路层目的： ​ 1 为IP模块发送和接收IP数据报​ 2 为ARP模块发送ARP请求和接收ARP应答​ 3 为RARP发送RARP请求和接收RARP应答 参考资料： INTERNETWORKING WITH TCP/IP PRINCIPLES, PROTOCOLS, AND ARCHITECTURE Vol1 (6th Edition). DOUGLASE E. COMER]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
        <tag>MAC</tag>
        <tag>以太网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP 概览]]></title>
    <url>%2F2020%2F07%2F03%2FTCP-IP-%E6%A6%82%E8%A7%88%2F</url>
    <content type="text"><![CDATA[概览 Internet ​ 特指网络环境 IP -&gt; 分组传递 -&gt; 无连接传输TCP -&gt; 可靠的流传输 (针对TCP协议提供的服务，是一种面向连接的服务) 作为标准的RFC在系统中都有实现 Internetworking ​ 互联异构的（完全不同类型的）物理网络 TCP/IP 的发展： ​ ARPA -&gt; DARPA ：定义了体系结构与相关协议 Internet Services：因特网提供的服务 ​ 是一个协议簇，一系列的协议​ 1 定义报文格式​ 2 收到响应的动作​ 3 差错的处理​ 优点：隐藏底层网络的细节 如何看待因特网提供的服务： 1 从用户视角： ​ 一系列的应用程序（常用的如www，云访问，远程桌面，电子邮件，文件传输，流媒体等 2 从网络层视角：因特网提供两种服务 ​ 1 无连接的分组传递服务​ 2 可靠的流传送服务 因特网服务的一些特点： ​ 1 网络技术的独立性，协议独立于任何类型的网络硬件​ 2 通用的互联，网络中的任意两台计算机都能进行通信​ 3 端到端的确认，可靠的流传输，主机到主机与中间路由无关​ 4 应用协议标准 因特网的历史： ​ 1979 APRA​ 1980s 从第一代协议迁移到第二代协议（相关操作系统支持的代表：BSD Unix​ 1983 APRA -&gt;1 (MILNET)民用 -&gt;2 (ARPANET)军用​ 1986 NSFNET 加入到APRA，成为APRA的主干 因特网的管理机构： ​ IAB​ 1989 IAB重新组着成IRTF和IETF 因特网协议文档 RFC ​ 从IETF上获取：www.ietf.org 从IPv4到IPv6的转换 ​ IPv6：​ 1 更大的地址空间​ 2 地址分层的层次结构上分的更多更细​ 3 首部格式是一个全新的格式，做了一定的简化​ 4 选项作为扩展首部​ 5 扩展性上适应新的网络硬件和应用​ 6 支持自动的配置和分配IP地址​ 7 支持资源的分配 IPv6 支持 自动配置 （配置TCPIP参数等 支持 QoS 概览中涉及的一些概念 12345678910111213141516171819202122231 分层 TCP&#x2F;IP是一组不同层次上的多个协议的组合 TCP&#x2F;IP 四层协议系统 1）链路层：OS中的设备驱动程序、网卡 2）网络层：处理分组在网络中的活动（例如分组选路 IP、ICMP、ICMP 3）运输层：为两台主机上的应用程序提供端到端的通信 TCP 可靠数据通信 UDP 任何必需的可靠性必须由应用层来提供 4）应用层：负责处理特定的应用程序细节 Telnet，FTP，SMTP，SNMP，……2 互联网地址3 域名系统4 封装5 分用6 端口号7 RFC 参考资料： INTERNETWORKING WITH TCP/IP PRINCIPLES, PROTOCOLS, AND ARCHITECTURE Vol1 (6th Edition). DOUGLASE E. COMER]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[特征点提取与匹配]]></title>
    <url>%2F2019%2F10%2F27%2F%E7%89%B9%E5%BE%81%E7%82%B9%E6%8F%90%E5%8F%96%E4%B8%8E%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[视觉里程计：根据相邻图像的信息估计相机的运动，作为后端的初值 特征点法、直接法 在相机运动过程中观测到的路标点，在某一个位姿，相机观测到物体的像素坐标为$(u,v)$，则对应满足相机模型关系： Z P_{uv}=Z\begin{bmatrix}u\\v\\1\end{bmatrix}=K(RP_w+t)=KTP_w 特征点提取与匹配 特征点概念 ​ 1）路标：有代表性的点 ​ 2）特征：图像信息的另一种数字表达形式，角点&gt;特征&gt;区块 特征点 = 关键点 + 描述子 关键点 特征点在图像中的位置 描述子 描述关键点周围像素信息的向量，例如对关键点周围亮度的表现。 在ORB中，在关键点周围随机选择128对或256对点（对于每张相机图像里的每个关键点，都可以使用相同的随机选择模板），以每一对的亮度相似程度按二进制赋值，生成一个128或256位的二进制数，以此数来表述描述子。 同时，在ORB-BRIEF描述子中，考虑到图像的旋转，针对每张图像以灰度质心法计算图像中每个特征点方向，或者计算整体图像旋转的向量，以此旋转向量调整随机选择模板（对随机选择的点也进行旋转），再生成描述子。 最后，对描述子进行特征匹配。在ORB中，描述子的匹配以汉明匹配方式进行匹配。但是在ORB中，BRIEF描述子没有涉及到尺度这一特征。 ​ 特征提取算法 SIFT：尺度不变特征变换（计算量大） FAST关键点：没有描述子（计算快） ORB：FAST特征点 + BRIEF描述子 ORB特征提取和匹配 FAST关键点 目的是对图像的 平移、旋转、尺度 进行特征提取。 图像金字塔： 用于提取图像的尺度特征，描述相机前后运动的过程 ​ 1 塔底为原始图像，每往上一层对图像进行固定倍率（例：1.2，1.5，2倍等）缩放，得到不同分辨率图像（小远大近） ​ 2 两图像间，匹配不同层上的图像 Oriented FAST关键点中没有涉及到这一特性 特征旋转：计算图像灰度质心（以图像块灰度值作为权重的中心 ） ​ 1 图像块的矩：其中，I(x, y)为f(x, y)的二值图像，取值0或1 m_{pq}=\sum\limits_{x,y\in B}x^py^qI(x,y),\;p,q=\{0,1\}​ 2 图像块的质心：$ C=(m{10}/m{00},m{01}/m{00}) $ ​ 3 特征方向：表示为 $ \theta=\arctan(m{01}/m{10}) $，连接几何中心O和质心C得到的方向向量 BRIEF描述子 在关键点附近随机选取K对点，以K位二进制的形式反映他们的大小关系，以此作为对一个特征点的描述。又由于在FAST关键点中计算了关键点的方向，利用方向信息计算旋转后的特征。 ORB特征匹配 数据关联问题：确定前后看到的路标间的对应关系 问题：1 误匹配 2 匹配方法 描述点的距离表示了两个特征之间的相似程度 注：（SIFT……）快速近似邻近（FLANN），但不适用于计算汉明距离 参考资料： 视觉SLAM十四讲：从理论到实践（第2版）. 高翔.]]></content>
      <categories>
        <category>SLAM</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>Math</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[状态估计中的最小二乘]]></title>
    <url>%2F2019%2F10%2F16%2F%E7%8A%B6%E6%80%81%E4%BC%B0%E8%AE%A1%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%2F</url>
    <content type="text"><![CDATA[状态估计 状态估计，是根据系统的先验模型和测量序列，对系统内在状态进行重构的问题 背景 \left\{\begin{matrix} 运动方程（相机位姿）：x_k = f(x_{k-1},u_k,w_k) \\ 观测方程（针孔模型）：z_{k,j}=h(y_j,x_k,v_{k,j}) \end{matrix}\right.$x_k = T_k = \exp({\xi_k}^\wedge)$：x_k是一个六自由度的位姿，可以由一个变换矩阵来描述，也可以用李代数的指数来描述。 $sz_{k,j}=K\exp(\xi^\wedge)y_j$：内参×外参×路标点 = 像素点距离×像素 考察问题 当已知观测方程和运动方程的具体形式，如何对估计值进行优化？ 即：如何通过 观测量z 和 输入量u 去优化 机器人的轨迹、位置x 和 路标点的位置y （SLAM过程）？ 这是一个状态估计问题：通过已知的带有噪声的数据 去推断出无法直接获得的状态 该问题下的状态估计 状态变量： $x={x_1,…,x_N,y_1,…y_M}$：所有时刻的位姿x 和 所有时刻的路标（地图）y 所以状态估计等同于求解条件分布： P(x | z, u) x在z，u条件下的概率分布（x, z, u都表示所有时刻的统称） 状态估计问题分类： 1 线性系统 ：若f和h是线性方程（有几个线性量，加和，数乘组成） 2 高斯噪声：噪声属于高斯分布 3 非线性系统 4 非高斯噪声 此处的状态估计具有 马尔科夫性（下一个时刻的状态依赖于上一个时刻的状态） 状态估计描述 在k个时间点上，基于初始状态信息、一系列观测数据、一系列输入，以及系统的运动模型和观测模型，来计算系统的真实状态估计值。 从概率学角度求状态估计 在不知道输入控制u，只有图像时，忽略u并只考虑观测数据 P(x|z)：已知图像，推断x的分布：称为后验概率 贝叶斯： 似然概率：p(z|x)：在某一个状态x下观测图像（确定图像与当前图像的相似程度） 先验概率：P(x)：x自己的状态 对于p(x|z)：x的维度很高，难以写出其分布，但是可以求： 1）最大后验估计 ​ 使得 p(x|z)最大的 x 的估计 (${x^*}_{MAP}$)，即在某一种分布下 x 的最优估计，此时是一个估计出的量 ​ ${x^*}_{M A P} = \arg \max P(x|z) = \arg \max P(z|x)P(x)$ ​ 注释：寻求一个x使得p(x|z)达到最大，此时称为x为最大后验估计，表示：在怎样的x下拿到的相机数据和现在数据（已有的）是最像的 2）最大似然估计 ​ 当最大后验估计中无法得知 x时（不知道 机器人轨迹 的先验是什么样子的时候），则直接最大化似然 ​ ${x^*}_{MLE} = \arg \max P(z|x)$ ​ 注释：当不知道先验概率时（x原本应该是什么样子，或者x就是一个随机的运动）即没有先验时，则此时最大化似然就可以了。表示：最大化x，使得在此状态下看到的数据最像我们看到的数据，P(z|x) 即“在哪种状态下，最容易产生当前的观测” 求解最大似然估计 某次观测：$z{k,j}=h(y_j, x _k)+v{k, j}$，噪声服从0均值高斯分布$vk\sim \mathcal{N}(0,Q{k,j})$ 所以观测数据条件概率（将h加到噪声分布上） P(z_{j,k}|x_k,y_j)=N(h(y_j, x _k), Q_{k,j})对于N维高斯分布 $x\sim \mathcal{N}(\mu,\Sigma)$的概率密度展开式： p(x)=\frac{1}{\sqrt{(2\pi)^N\det(\Sigma)} }\exp(-\frac{1}{2}(x-\mu)^T\Sigma^{-1}(x-\mu))它的右侧指数部分为一个二次型，若$\Sigma=I$，则指数部分就是一个二范数（误差的平方） 将展开式两边取对数并添加负号，得到p(x)只与马氏距离$-\frac{1}{2}(x-\mu)^T\Sigma^{-1}(x-\mu)$有关。 所以要求最大似然估计，就是求最小$-\ln(p(x))$ 最小二乘 代入SLAM观测模型， (x_k, y_j)^*=\arg\min( \;(z-h(x,y))^T Q^{-1} (z-h(x,y))\;)等式右侧为一个最小二乘，即最小化噪声项（误差）的一个二次型（马氏距离） 其中，$Q^{-1}$为信息矩阵（协方差矩阵的逆，协方差反映两个变量相向的程度），用于噪声的控制调整 P(z,u|x,y)=\prod_kP(u_k|x_{k-1},x_k)\prod_{k,j}P(z_{k,j}|x_k, y_j)定义运动误差和观测误差：$e{u, k}，e{z, j, k}$，最小化估值和真实值之间的误差（即马氏距离）时，每一个误差对应一个最小二乘，所以得到一个最小二乘问题 $\min J(x, y)$ ，它等于所有时刻运动误差和观测误差的总和。 此最小二乘问题等价于状态的最大似然估计 非线性最小二乘 探讨通用的无约束非线性最小二乘问题的求解 一阶梯度 最速下降法，取增量为反向梯度 $\Delta x^*=-J(x_k)$ 二阶梯度 牛顿法，保留了二阶梯度，$\Delta x = -H^{-1}J$ 高斯牛顿法 将误差一阶展开，代入最小二乘，求梯度求解 J(x)J^T(x)\Delta x=-J(x)f(x) \; \Rightarrow\;H(x)\Delta x=g(x)称为高斯牛顿方程（正规方程）$H\Delta x=g$ . 其中：J(x)为f(x)关于x的导数，是一个1×n的向量 缺陷： 1）$H = JJ^T$可能不正定，无法求$H^{-1}$ 2）不考虑步长的取值造成误差 求解过程： 1 最小二乘式，确定待估计的变量 2 误差式 3 计算雅克比矩阵J 和 误差e 4 求解增量方程 Hx=g 5 迭代 LM 增加指标 \rho = \frac{f(x + \Delta x) - f(x)}{ J(x)^T\Delta x}以该指标为 $\Delta x$ 添加一个信赖区域，以$\rho$值的大小来控制信赖区域的半径，使得在此区域内取得的$JJ^T \sim H$，从而用雅克比矩阵运算代替海塞矩阵的运算，同时，在约束项的控制下，保证了求解项左边矩阵可逆。 将约束项加入到最小二乘中： \mathcal{L}(\Delta x_k,\lambda)=\frac{1}{2}\left \| f(x_k) + J(x_k)^T\Delta x_k \right \|^2+\frac{\lambda}{2}(\left \| D\Delta x_k \right \|^2-\mu)其中，D为非负数对角阵，表示了对空间的约束。 对$\Delta x$求导后得：$(H+\lambda D^TD)\Delta x_k=g$ 矩阵微分 先使用微分法则展开复合微分项，再通过迹技巧，结合下式求解 df=tr(\frac{\partial f}{\partial X}^TdX) 参考资料： 视觉SLAM十四讲：从理论到实践（第2版）. 高翔.]]></content>
      <categories>
        <category>SLAM</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[相机标定]]></title>
    <url>%2F2019%2F10%2F04%2F%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[坐标系 世界坐标系 $(x_w,y_w,z_w)$ 相机坐标系 $(x_c,y_c,z_c)$ 图像坐标系 $(x,y)$ $x_p=f\frac{x_c}{z_c},y_p=f\frac{y_c}{z_c}$ 像素坐标系 $(u,v)$ $u=\frac{x_c}{d_x}+u_0,v=\frac{y_c}{d_y}+v_0$ 坐标系转换 1 世界坐标系到相机坐标系（旋转矩阵） 2 相机坐标系到图像坐标系（透视投影矩阵 3X4矩阵） 3 图像坐标系到像素坐标系（K 内参矩阵） K=\begin{bmatrix} f_x & 0 & u_0\\ 0 & f_y & v_0\\ 0 & 0 & 1 \end{bmatrix}，f_x=\frac{f}{d_x},f_y=\frac{f}{d_y} Z P_{uv}=Z\begin{bmatrix}u\\v\\1\end{bmatrix}=K(RP_w+t)=KTP_w 张正友标定法 在不考虑透镜畸变情况下求解内参和外参 相机内参： fx,fy,u0,v0(,r=K12) ​ 相机外参：$T_x,T_y,T_z,\omega,\delta,\theta$ 单应性矩阵：单应性矩阵用于表示投射图像间的透视变换，变换图像的视图 单应性：从一个平面到另一个平面的投影映射，例如 \tilde{Q}=\begin{bmatrix}X\\Y\\Z\\1\end{bmatrix}\;\rightarrow\;\tilde{q}=\begin{bmatrix}x\\y\\1\end{bmatrix}\;\Rightarrow\;\tilde{q}=sH\tilde{Q}定义标定板平面为世界坐标系中 Z=0 的平面 s\begin{bmatrix}u\\v\\1\end{bmatrix}=K\begin{bmatrix}R & t\end{bmatrix}\begin{bmatrix}x\\y\\z\\1\end{bmatrix}=K\begin{bmatrix}r_1 & r_2 & r_3 & t\end{bmatrix}\begin{bmatrix}x\\y\\0\\1\end{bmatrix}=K\begin{bmatrix}r_1 & r_2\end{bmatrix}\begin{bmatrix}x\\y\\1\end{bmatrix}其中，$s$为尺度因数（使得单应性定义到该尺度的比例），$H=K\begin{bmatrix}r_1 &amp; r_2 &amp; t\end{bmatrix}$为成像平面和标定平面之间的单应矩阵（由变换和相机内参两部分组成，$r_1,r_2,t$ 分别为旋转矩阵的前两个列向量和平移向量），$\begin{bmatrix}R&amp;t\end{bmatrix}$是一个3X4的矩阵（前3X3是旋转矩阵，后3X1是一个平移向量t） 图像平面(src)的点集与目标平面(dst)上的点集 间的关系（由单应性矩阵确定）： \begin{align} & p_{dst}=Hp_{src} , p_{src}=H^{-1}p_{dst}\\\\ &p_{dst}=\begin{bmatrix}x_{dst}\\y_{dst}\\1\end{bmatrix},p_{src}=\begin{bmatrix}x_{src}\\y_{src}\\1\end{bmatrix} \end{align}记：$H=\begin{bmatrix}h_1&amp;h_2&amp;h_3\end{bmatrix}$ 求内参矩阵 由 H=s^{-1}K\begin{bmatrix}r_1 & r_2&t\end{bmatrix}\tag{1} r_1r_2=0\tag{2},|r_i|=1（1）（2）可推导出两等式， \begin{align} &h_1^TK^{-T}K^{-1}h_2=0\\ &h_1^TK^{-T}K^{-1}h_1=h_2^TK^{-T}K^{-1}h_2 \end{align}通过两张不同位置的图片，可以标定后求解出相机内参矩阵K（四个未知数四个方程） 求外参矩阵 在求得内参矩阵后，则可以估算外参矩阵： \begin{align} &H=s^{-1}K\begin{bmatrix}r_1 & r_2&t\end{bmatrix}\\ \Rightarrow&\left\{\begin{matrix} r_1=s^{-1}A^{-1}h_1\\ r_2=s^{-1}A^{-1}h_2\\ r_3=r_1\times r_2\\ t = s^{-1}A^{-1}h_3 \end{matrix}\right.,s^{-1}=\frac{1}{||K^{-1}h_1||}=\frac{1}{||K^{-1}h_2||} \end{align} 考虑畸变，求解畸变系数 径向畸变处理 参数最优化 非线性最小二乘法，极大似然估计 12345// image creatorif(!((i+j)%2)) rectangle(ChessImage, Point(Start.x+i*SingleSize, Start.y+j*SingleSize), Point(Start.x+(i+1)*SingleSize-1, Start.y+(j+1)*SingleSize-1), Scalar(0, 0, 0), -1); 12345// image captureVideoCapture capture;Mat frame;capture.open( [filename] )while(true) capture &gt;&gt; frame 123// opencv/samples/cpp/calibration.cppcv::findChessboardCorners() //绘制交点cv::calibrationCamera() //校准 123456// cv::undistort() //校正畸变double x = (u - cx)/fx, y = (v - cy)/fy; // X/Z , Y/Z -&gt; 归一化坐标 （X/Z Y/Z 1）-&gt; 映射到二维 -&gt; (x y) -&gt; 写成极坐标形式 （r theta）double r = sqrt(x*x + y*y); // 极坐标 长度double u_distort = fx * x * (1 + k1*pow(r, 2) + k2*pow(r, 4) + k3*pow(r, 6) ) + 2*p1*x*y + p2*(pow(r, 2) + 2*pow(x, 2) ) + cx;double v_distort = fy * y * (1 + k1*pow(r, 2) + k2*pow(r, 4) + k3*pow(r, 6) ) + p1*(pow(r, 2) + 2*pow(y, 2) ) + 2*p2*x*y + cy; 畸变方程 \left\{\begin{matrix} x_{distorted}= x(1+k_1r^2+k_2r^4+k_3r^6)+2p_1xy+p_2(r^2+2x^2)\\ y_{distorted}= y(1+k_1r^2+k_2r^4+k_3r^6)+p_1(r^2+2y^2)+2p_2xy \end{matrix}\right. \Rightarrow \left\{\begin{matrix} u=f_xx_{distorted} + c_x\\ v=f_yy_{distorted} + c_y\end{matrix}\right. 12./imagelist_creator imagelist.yaml [path].jpg./calibration -w=[num] -h=[num] [-op] [-oe] [...] imagelist.yaml 123# out_camera_data.ymlcamera_matrix: //相机内参distortion_coefficients: //畸变系数 参考： 1 视觉SLAM十四讲：从理论到实践（第2版）]]></content>
      <categories>
        <category>CV</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[李代数求导]]></title>
    <url>%2F2019%2F09%2F22%2FVSLAM-4-2-%E6%9D%8E%E4%BB%A3%E6%95%B0%E6%B1%82%E5%AF%BC%2F</url>
    <content type="text"><![CDATA[1） SLAM的过程就是不断的估计相机的位姿和建立地图，在此过程中会出现一定的误差，所以目的是寻找一个最佳位姿（通过优化方法，一般采用迭代优化方法，每次迭代都更新一个位姿的增量delta，使得目标函数最小。这个delta就是通过误差函数对T微分得到的。也就是说我们需要对变换矩阵T求微分），使得整体误差最小。 为此，可以列出关于变换矩阵T的目标函数，要求解方程需要对变换矩阵求导。 2） 就旋转矩阵而言，其矩阵加法不封闭，为此不满足导数定义中“加一个极小量”。所以，要使得矩阵满足求导运算，引出李群和李代数。 李群是具有连续性质的群，群上定义了某种矩阵的集合。对于旋转矩阵、变换矩阵都是满足李群的定义，例如旋转矩阵在旋转矩阵的集合中关于乘法运算满足李群。李群运算不满足求导，但与李群对应的李代数满足加法后保持性质。至此，将变换矩阵求导的问题转化为了求李代数的导数问题。 在讨论李代数的物理意义时，so(3)就代表了旋转向量组成的空间。实际上，so(3)是三维向量phi的集合，每个向量phi^表达了这个李代数对应的李群SO(3)上旋转矩阵R的导数。其中，R与phi是一个指数映射关系。 关于李代数和李群在几何意义上的关系：李代数对应李群的正切空间，描述了李群的局部导数。 李代数求导 BCH公式 \ln(\exp(A)\exp(B))=A+B+\frac{1}{2}[A,B]+\frac{1}{12}[A,[A,B]]-\frac{1}{12}[B[A,B]]+...其中“[ , ]”为李括号。 考虑SO(3)上的李代数： \ln(\exp(\phi_1^\wedge)\exp(\phi_2^\wedge))^\vee=\left\{\begin{matrix} {J_l(\phi_2)}^{-1}\phi_1+\phi_2\;\;当\phi_1为小量\\ {J_r(\phi_1)}^{-1}\phi_2+\phi_1\;\;当\phi_2为小量 \end{matrix}\right.\tag{*}第一个近似描述了：对一个旋转矩阵$R2$（李代数$\phi_2$），左乘一个微小旋转$R_1$，近似看作：在李代数$\phi_2$上加了一项${J_l(\phi_2)}^{-1}\phi_1$. J_l=J=\frac{\sin\theta}{\theta}I+(1-\frac{\sin\theta}{\theta})\alpha\alpha^T+\frac{1-\cos\theta}{\theta}\alpha^\wedge\tag{**} J^{-1}=\frac{\theta}{2}\cot\frac{\theta}{2}I+(1-\frac{\theta}{2}\cot\frac{\theta}{2})\alpha\alpha^T-\frac{\theta}{2}\alpha^\wedge\tag{**}右乘：$J_r(\phi)=J_l(-\phi)$ 至此，得到李群乘法和李代数加法的关系 BCH近似 $旋转矩阵R，其李代数\phi，微小旋转\Delta R，其李代数\Delta\phi$，李群乘法$\rightarrow$李代数加法 \exp(\Delta\phi^\wedge)\exp(\phi^\wedge)=\exp((\phi+J_l^{-1}(\phi)\Delta\phi)^\wedge)\tag{***}李代数加法$\rightarrow$李群乘法 \exp((\phi+\Delta\phi)^\wedge)=\exp((J_l\Delta\phi)^\wedge)\exp(\phi^\wedge)=\exp(\phi^\wedge)\exp((J_r\Delta\phi)^\wedge)\tag{***} 李代数求导 两种思路： 1 导数模型 ， 2 扰动模型 SO(3)上的李代数求导 $位姿T，观察点的世界坐标p，产生的观测数据z，随即噪声w$，对于N个观测误差$e=z-Tp$，（寻找一个最优T，使误差最小） \underset{T}{\min}J(T)=\sum_{i=1}^N||z_i-Tp_i||_2^2 李代数求导 1）按照导数模型，（根据李代数的加法结合导数的定义来求旋转后点的坐标对于旋转的导数，或者说是求旋转很小时偏移的变化率），可以求得： \begin{align} & \frac{\partial (\exp(\phi^\wedge)p)}{\partial \phi}\approx-(Rp)^\wedge J_l\\&\\ \Rightarrow &\frac{\partial (Rp)}{\partial \phi}=(-Rp)^\wedge J_l \tag{旋转后的点对于李代数的导数} \end{align}2）扰动模型，对旋转矩阵R进行一次扰动$\Delta R$（对应的李代数为$\varphi $），看结果相对于扰动的变化率。 \frac{\partial (Rp)}{\partial \phi}=(-Rp)^\wedge SE(3)上的李代数求导 空间点p，变换T（对应的李代数为$\xi$），扰动变换$\Delta T=\exp(\delta\xi^\wedge)$，其李代数为$\delta\xi=[\delta\rho,\delta\phi]^T$： \frac{\partial (Tp)}{\partial \delta\xi}=\begin{bmatrix}I & -(Rp+t)^\wedge\\ 0^T & 0^T\end{bmatrix}git 参考资料： 视觉SLAM十四讲：从理论到实践（第2版）. 高翔.]]></content>
      <categories>
        <category>SLAM</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[李群李代数及其转换的映射]]></title>
    <url>%2F2019%2F09%2F21%2FVSLAM-4-1-%E6%9D%8E%E7%BE%A4%E6%9D%8E%E4%BB%A3%E6%95%B0%E5%8F%8A%E5%85%B6%E8%BD%AC%E6%8D%A2%E7%9A%84%E6%98%A0%E5%B0%84%2F</url>
    <content type="text"><![CDATA[李群与李代数 （1）群 代数结构：一种集合+集合上的一种运算 满足性质：封闭性、结合率、幺元、逆 李群：具有连续（光滑）性质的群 （2）李代数 与李群对应的一种数据结构 引出李代数 旋转矩阵$R$是某个相机的旋转，并随时间连续地变化 \begin{align} & R(t)R(t)^T=I\tag{两边对t求导} \\ \Rightarrow\;& \dot{R}(t)R(t)^T+R(t)\dot{R}(t)^T=0\\ \Rightarrow\;& \dot{R}(t)R(t)^T = -(\dot{R}(t)R(t)^T)^T\\&\\ \rightarrow\;&\dot{R}(t)R(t)^T是一个反对称矩阵 \end{align}所以，找到一个三维向量$\phi(t)\in\mathbb{R^3}$记： \begin{align} & \phi(t)\text{^}=\dot{R}(t)R(t)^T \tag{1}\\&\\ \Rightarrow\;&\dot{R}(t)=\phi(t)\text{^}R(t)\tag{2} \end{align}考虑：$t_0=0时，R(0)=I$，在0处泰勒展开： R(t)\approx R(t_0)+\dot{R}(t_0)(t-t_0)=I+\phi(t_0)\text{^}t在$t_0$附近，$\phi(t_0)=\phi_0$为常数，所以得到关于R的微分方程，得： R(t)=e^{\phi\text{^}t} \tag{3} 李代数的定义 每个李群对应一个李代数。李代数描述了李群的局部性质，是单位元附近的正切空间（tangent Space切线空间，是一种三维空间） 集合$\mathbb{V}$ + 数域$\mathbb{F}$ + 二元运算（李括号）[ , ] = 李代数 \mathfrak{g}=(\mathbb{V},\mathbb{F},[,])性质：封闭性、双线性、自反性（与自身运算结果为零）、雅可比等价 李代数$\mathfrak{so}(3)$ 定义$\Phi=\phi^\wedge$，得 李括号为： [\phi_1,\phi_2]=(\Phi_1\Phi_2-\Phi_2\Phi_1)^\vee \mathfrak{so}(3)=\begin{Bmatrix} \phi=\mathbb{R^3},\Phi=\phi^\wedge\in\mathbb{R^{3\times3} } \end{Bmatrix}\tag{*}所以，so(3)是一个由三维向量组成的集合，每个向量对应一个反对称矩阵，表达旋转矩阵的导数 对应SO(3)，$ R(t)=e^{\phi\text{^}t} $ SO(3)=\{R\in\mathbb{R}^{3\times 3}|RR^T=I,det(R)=1\}\tag{*} 李代数$\mathfrak{se}(3)$ \mathfrak{se}(3)=\begin{Bmatrix} \xi =\begin{bmatrix} \rho \\ \phi \end{bmatrix}\in\mathbb{R}^6,\rho\in\mathbb{R}^3,\phi\in\mathfrak{so}(3),\xi^\wedge =\begin{bmatrix} \phi^\wedge & \rho\\ 0^T & 0 \end{bmatrix}\in\mathbb{R}^{4\times4} \end{Bmatrix}$\mathfrak{se}(3) $：由一个平移+一个$\mathfrak{so}(3)$构成的向量 $\mathfrak{se}(3)$对应的李括号： [\xi_1,\xi_2]=(\xi_1^\wedge\xi_2^\wedge-\xi_2^\wedge\xi_1^\wedge)^\vee 指数与对数映射 （1）SO(3)上的指数映射 1 指数映射：在李群李代数中，一个矩阵的指数 2 通过泰勒展开，得$\mathfrak{so}(3)中的任意元素\phi的指数映射$： \text{exp}(\phi^\wedge)=\sum_{n=0}^\infty \frac{1}{n!}(\phi^\wedge)^n3 关于上述定义的计算： 定义$\phi$的 模长$\theta$，方向$\alpha$，$\phi=\theta\alpha$，其中$||a||=1$ 关于$\alpha$的性质：$\alpha^\wedge\alpha^\wedge=\alpha\alpha^T-I$，$\alpha^\wedge\alpha^\wedge\alpha^\wedge=-\alpha^\wedge$，将$\theta\alpha$代入指数映射： \begin{align} \text{exp}(\phi^\wedge)&=\text{exp}(\theta^\wedge\alpha)\\ &=\cos{\theta I}+(1-\cos\theta)\alpha\alpha^T+\sin\theta\alpha^\wedge \end{align}【注】 罗德里格斯公式：R=cos\theta I+(1-cos\theta )nn^T+sin\theta n\text{^}由此表明，$\mathfrak{so}(3)$实际上就是旋转向量组成的空间（李代数$\rightarrow$李群）其物理意义就是旋转向量，指数映射就是罗德里格斯公式（旋转向量$\rightarrow$旋转矩阵）（旋转矩阵的导数可以由旋转向量指定） 所以 \Rightarrow\;\phi =ln(R)^\vee=(\sum_{n=0}^\infty\frac{(-1)^n}{n+1}(R-I)^{n+1})^\vee但是，可以通过求解转角和转轴，可以更加简便的得到 $\theta$ 和 $\alpha$ \theta=arccos\frac{tr(R)-1}{2},Rn=n综上所述，得到李群SO(3)和李代数so(3)的对应关系，将旋转角控制在$（-\pi,\pi）$之间，二者成一一对应关系 （2）SE(3)上的指数映射 \text{exp}(\xi^\wedge)=\begin{bmatrix} \sum_{n=0}^\infty \frac{1}{n!}(\phi^\wedge)^n & \sum_{n=0}^\infty \frac{1}{()n+1)!}(\phi^\wedge)^n\rho\\ 0^T & 1 \end{bmatrix} \overset{\Delta}{=}\begin{bmatrix} R & J\rho\\ 0^T & 1 \end{bmatrix}=T经求解，得：$J=\frac{\sin\theta}{\theta}I+(1-\frac{\sin\theta}{\theta})\alpha\alpha^T+\frac{1-\cos\theta}{\theta}\alpha^\wedge$（雅可比矩阵） SE(3)右上角的平移向量t，结合$t=J\rho$，$J可由\phi求得$，可以求得 $\rho$ 由此，确定SE(3)和se(3)的转换关系 参考资料： 视觉SLAM十四讲：从理论到实践（第2版）. 高翔.]]></content>
      <categories>
        <category>SLAM</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[旋转向量 欧拉角 四元数]]></title>
    <url>%2F2019%2F09%2F17%2FVSALM-3-2-%E6%97%8B%E8%BD%AC%E5%90%91%E9%87%8F-%E6%AC%A7%E6%8B%89%E8%A7%92-%E5%9B%9B%E5%85%83%E6%95%B0%2F</url>
    <content type="text"><![CDATA[旋转向量 表现形式 旋转向量/轴角：用一个旋转轴和一人个旋转角来刻画任意一个旋转，方向和旋转轴一致，长度等于旋转角 所以，对于变换矩阵T，可以使用一个旋转向量和一个平移变量来表示，总共6个变量 旋转向量转化为旋转矩阵 罗德里格斯公式： ​ 长度为$\theta$，轴角为$n$（单位长度的向量），用向量$\theta n$表示旋转。 R=cos\theta I+(1-cos\theta )nn^T+sin\theta n\text{^}​ 根据 迹 的性质，对该公式两边取迹，求得转角和旋转矩阵的关系。 \Rightarrow \theta=arccos\frac{tr(R)-1}{2} 转轴 转轴$n$上的旋转向量在旋转后不发生改变， Rn=n \;\Leftarrow\left\{\begin{matrix} Rn=\lambda n\\ \lambda = 1 \end{matrix}\right.所以，可以推导出$n$为旋转矩阵$R$特征值为1对应的特征向量。因此，已知旋转矩阵，即可求得旋转轴。 欧拉角 将三个轴的旋转方向作定义，更加直观的表示旋转的过程。 但是在使用欧拉角时，会出现“万向锁问题”，例如可能导致三个轴的旋转实际只表示了两次旋转等情况。 四元数 定义 \begin{align} & q=[s,v]^T,\;s=q_0 \in \mathbb{R},\;v=[q_1, q_2, q_3]^T \in \mathbb{R} . \\ &q = q_0+q_1i+q_2j+q_3k .\\ & s为实部，v为虚部 \end{align} 运算 1）自身三个虚部满足的乘法运算关系 2）两四元数加减法 3）两四元数的乘法 \begin{align} & q_a\: [s_a, v_a]^T,\;q_a=s_a+x_ai+y_aj+z_ak\\& q_b\:[s_b,v_b]^T,q_b=s_b+x_bi+y_bj+z_bk\\\rightarrow\\ &q_aq_b=[s_as_b-v_a^Tv_b, s_av_b+s_bv_a+v_a\times v_b]^T \end{align}4）模长 $||q||$ 5）共轭 $q^*$ q^*q=qq^*=[s_a^2+v^Tv, 0]^T.6）逆 $q^{-1}$ \begin{align} &q^{-1}=q^*/||q||^2\\ &q^{-1}q=qq^{-1}=1 \end{align}7）数乘 用四元数表示旋转 在二维平面中，旋转数可以写为 $q=cos\theta+i*sin\theta$ 引申到三维旋转中，四元数向量表示为 $q\;[cos\theta, v*sin\theta]$ 三维空间点的旋转 空间三维点：$p=[x,y,z]\in \mathbb{R^3}$ 单位四元数：$q$ ,用于指定旋转 1）将三维空间点用虚四元数表示： p=[0, x,y,z]^T=[0,v]^T2）旋转 p'=extend(R)p \Rightarrow p'=qpq^{-1}通过先乘q再作q逆乘法，相当与先用右手坐标系将空间点旋转二分之一的旋转角，再用左手坐标系逆向旋转二分之一旋转角，以此使得最终得到的四元数时纯虚四元数，从而直接表示三维空间坐标。（从几何意义上是将三维向量转化为四维后再回到三维） 四元数到其他旋转表示的转换 定义：（将四元数的乘法写成矩阵乘法） q^+=\begin{bmatrix} s & -v^T\\ v & sI+v\text{^} \end{bmatrix},q^\oplus=\begin{bmatrix} s & -v^T\\ v & sI-v\text{^} \end{bmatrix} \Rightarrow q_1q_2=q_1^+q_2=q_2^\oplus q_1 \Rightarrow p'=qpq^{-1}=q^+p^+q^{-1}=q^+{q^{-1}}^\oplus p即$q^+{q^{-1}}^\oplus=extend(R)$，所以 四元数转换到旋转矩阵 q^+{q^{-1}}^\oplus=\begin{bmatrix} s & -v^T\\ v & sI+v\text{^} \end{bmatrix}\begin{bmatrix} s & v^T\\ -v & sI+v\text{^} \end{bmatrix}=\begin{bmatrix} 1 & 0\\ 0^T & vv^T+s^2I+2sv\text{^}+(v\text{^})^2 \end{bmatrix} \Rightarrow R=vv^T+s^2I+2sv\text{^}+(v\text{^})^2 \tag{*} 四元数转换到旋转向量 对两边取迹，得： tr(R)=4s^2-1其中，关于 $v(v_1,v_2,v_3)$，$v\text{^}$是向量$v$的反对称矩阵形式 tr((v\text{^})^2)=2(v_1^2+v_2^2+v_3^2) \tag{1}又由罗德里斯公式中： \Rightarrow \theta=arccos\frac{tr(R)-1}{2}\tag{2}最终得到四元数与旋转向量的转换关系 \Rightarrow \theta=2\arccos{s}综上，四元数到旋转向量的转换公式： \left\{\begin{matrix}\theta=2\arccos{q_0}\\ [n_x,n_y,n_z]^T=[q_1,q_2,q_3]^T/\sin{\frac{\theta}{2}}\end{matrix}\right. \tag{*} 参考资料： 视觉SLAM十四讲：从理论到实践（第2版）. 高翔.]]></content>
      <categories>
        <category>SLAM</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[旋转矩阵]]></title>
    <url>%2F2019%2F09%2F12%2FVSLAM-3-1%20%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[旋转矩阵 点，向量，坐标系 $\mathbb{R}^3$ $\mathbb{R}^3$描述三维空间中的某个坐标点，$(e_1, e_2, e_3)$：为空间中的一组基 \begin{align} 向量&\textbf{a}在基(e_1,e_2,e_3)下的坐标：\\ & \textbf{a} = [e_1,e_2,e_3]\begin{bmatrix} a_1\\ a_2\\ a_3 \end{bmatrix}=a_1e_1+a_2e_2+a_3e_3.\\ &(a_1,a_2,a_3)^T为\textbf{a}在基下的坐标 \end{align} 外积 将叉乘转化为矩阵和向量相乘的线性运算 \begin{align} a\times b& = \begin{Vmatrix} e_1 & e_2 & e_3\\ a_1 & a_2 & a_3\\ b_1 & b_2 & b_3 \end{Vmatrix}=(a_2b_3-a_3b_2)e_1+(a_3b_1-a_1b_3)e_2+(a_1b_2-b_2a_1)e_3\\ &=e\begin{bmatrix} a_2b_3-a_3b_2\\ a_3b_1-a_1b_3\\ a_1b_2-b_2a_1 \end{bmatrix}\\ &=\begin{bmatrix} 0 & -a_3 & a_2\\ a_3 & 0 & -a_1\\ -a_2 & a_1 & 0 \end{bmatrix}\begin{bmatrix} b_1\\ b_2\\ b_3 \end{bmatrix} \overset{\text{def}}{=}\textbf{a^b} \end{align}符号 ^ ：反对称符号 $\Rightarrow$ a^ ：是反对称矩阵，将一个向量变成矩阵形式 a = $\begin{bmatrix}0 &amp; -a_3 &amp; a_2\a_3 &amp; 0 &amp; -a_1\-a_2 &amp; a_1 &amp; 0\end{bmatrix}$ ，任意向量对应唯一一个反对称矩阵. 欧式变换 刚体运动：一个旋转+一个平移（坐标系变换 旋转 向量本身不变但是坐标系变动，向量a在由基e转变为基e’后，再基e’中表示为a’ \begin{align} &[e_1,e_2,e_3]\begin{bmatrix} a_1\\ a_2\\ a_3 \end{bmatrix}=[{e}'_1,{e}'_2,{e}'_3]\begin{bmatrix} {a}'_1\\ {a}'_2\\ {a}'_3 \end{bmatrix}\\ &等式两边同时左乘[e_1^T,e_2^T,e_3^T]^T，设\:R\:为旋转矩阵：\\ &\begin{bmatrix} a_1\\ a_2\\ a_3 \end{bmatrix}=\begin{bmatrix} e^T_1{e}'_1 & e^T_1{e}'_2 & e^T_1{e}'_3\\ e^T_2{e}'_1 & e^T_2{e}'_2 & e^T_2{e}'_3\\ e^T_3{e}'_1 & e^T_3{e}'_2 & e^T_3{e}'_3 \end{bmatrix}\begin{bmatrix} {a}'_1\\ {a}'_2\\ {a}'_3 \end{bmatrix}\overset{\text{def}}{=}R{a}' \end{align}旋转矩阵 R（方向余弦矩阵）行列式为1，行列式为1的正交矩阵也是一个旋转矩阵。因为行列式为1的正交矩阵的几何意义为旋转但不改变向量长度。 由此，定义n维旋转矩阵： \begin{align}\textbf{特殊正交群}:\\ &SO(n)=\{R\in\mathbb{R}^{n\times n}|RR^T=I,det(R)=1\}. \end{align}其中，I为单位矩阵 关于${a}’=R^{-1}a=R^Ta$ ，同样地，正交矩阵R的逆矩阵在几何上表示一个相反的旋转，因此R的转置刻画了一个相反的旋转。 旋转 + 平移 刚体运动（由向量a变换到向量a’），旋转Ra和平移向量t \textbf{a'=Ra+t} 变换矩阵 1）前置问题： 假设进行多次欧式变换，表达式之间的关系并非是线性关系（带有多项式项），所以为方便描述，设置变换矩阵（T矩阵） 2）定义形式 将三维坐标写成齐次坐标： \begin{align}&\begin{bmatrix} {a}'\\ 1 \end{bmatrix}=\begin{bmatrix} R & t\\ 0^T & 1 \end{bmatrix}\begin{bmatrix} a\\ 1 \end{bmatrix}\overset{\text{def}}{=}T\begin{bmatrix} a\\ 1 \end{bmatrix}\\&\\&矩阵\:T\:为变换矩阵 \end{align}由此，多次变换可以写为如下形式： c=T_1T_2a3）特殊欧式群 SE(3)=\begin{Bmatrix} T=\begin{bmatrix} R & t\\ 0^T & 1 \end{bmatrix}\in \mathbb{R}^{4\times4}|R \in SO(3),t\in\mathbb{R}^{3} \end{Bmatrix}反向变换： T^{-1}=\begin{bmatrix} R^T & -R^Tt\\ 0^T & 1 \end{bmatrix}（可由$A^*=A|A|$求得） [ 注 ] 1）SO(3) 的旋转矩阵有9个量，但一次旋转只有3个自由度： ​ 矩阵由九个元素，却只表示了 x，y，z 三个坐标的位置变化（只有三个自由度） 2）变换矩阵T用16个量（4阶T矩阵16个元素）表达了6自由度的变换，分别是三个坐标轴以及每个坐标轴的旋转变量（3个） 参考资料： 视觉SLAM十四讲：从理论到实践（第2版）. 高翔.]]></content>
      <categories>
        <category>SLAM</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CMake 学习笔记]]></title>
    <url>%2F2019%2F09%2F10%2FCMake-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[cmake 基本使用 1）初始文件：hello.c，CMakeList.txt 2）CMakeList.txt 12345678# CMake最低版本要求cmake_minimum_required(VERSION 2.8)# 工程名project(HelloProject)# 最终要生成的elf文件名为hello，源文件为：hello.cadd_executable(hello hello.c) 3）cmake编译 1cmake . 得到：CMakeFiles文件夹，CMakeCache.txt，cmake_install.cmake，Makefile 1make 得到目标文件 hello 同目录多源文件编译 添加文件 test.c ，test.h ，test.h中的方法是对test.c中的函数方法的声明，hello.c引入test.h头文件，并调用头文件中的方法。 则，调整 CMakeList.txt 文件： 12# 在参数表中增加testFunc.cadd_executable(hello hello.c testFunc.c) 当需要编译的文件很多时，使用命令 aux_source_directory(&lt; dir &gt; &lt; variable &gt;) 将指定目录下所有源文件存储到一个变量中进行操作，可以避免大量手动罗列 1234# 将当前所在目录下的所有源文件 . ，添加到 变量SRC_LIST中aux_source_directory(. SRC_LIST)# 调用变量SRC_LIST，语法类似Makefileadd_executable(hello $&#123;SRC_LIST&#125;) 不同目录多源文件编译 要编译的文件在不同目录下时，使用命令 include_directories([AFTER|BEFORE] [SYSTEM] dir1 [dir2 ...]) 向工程添加多个指定头文件的搜索路径 12345678# 将头文件包含进工程# 等价于包含头文件 include "xx.h"include_directories (test_func test_func1)# 添加源文件到变量中aux_source_directory (test_func SRC_LIST)aux_source_directory (test_func1 SRC_LIST1)# 添加构成执行文件的所有文件add_executable (hello hello.c $&#123;SRC_LIST&#125; $&#123;SRC_LIST1&#125;) 工程目录编译 include目录中是所有的.h头文件，src目录中是所有的.c源文件，build文件夹时编译文件夹 [ ] 使用命令 add_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL]) 来增加一个子目录进行编译，该文件夹下的CMakeLists.txt 负责编译该文件夹下的源码。source_dir选项指定了CMakeLists.txt源文件和代码文件的位置，binary_dir选项指定了输出文件的路径 12# 在build目录下增加src子目录进行编译，src中的CMakeLists.txt编译src中的源文件add_subdirectory (src) 在src目录下CMakeLists.txt中： 12345aux_source_directory (. SRC_LIST)include_directories (../include)add_executable (hello $&#123;SRC_LIST&#125;)# 位置变量 EXECUTABLE_OUTPUT_PATH 设置为 PROJECT_SOURCE_DIR/bin（工程根目录下的bin目录） set (EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/bin) 在build目录下 cmake 函数 find_package() ​ 在一些目录中查找（按照CMake规则）文件，例如OpenCV，将找到的头文件目录设置到变量${OpenCV_INCLUDE_DIES}中，将链接库设置到 ${OpenCV_LIBS}中 ​ 查找方式：模块模式 / 配置模式 1. 模块模式：查找Find&lt;package&gt;.cmake文件（由CMAKE_MODULE_PATH 指定） 2. 配置模式：查找一个由待查找的包提供的配置文件的位置。包含该文件的路径被存储到 &lt;package&gt;_DIR的cache的条目里。 不管哪一种模式，只要找到包，就会定义变量 _ FOUND INCLUDE DIRS 或者 _ INCLUDES LIBRARIES 或者 LIBS _ DEFINITIONS ​ find_package() + add_library() 得到库文件的绝对路径 link_directories() ​ 指定第三方库所在路径，使得cmake搜索到动态库 target_link_libraries() ​ 将目标文件与库文件进行连接 find_path() / find_library() ​ 寻找头文件和库文件 CMake预定义的变量 CMAKE_CURRENT_SOURCE_DIR 当前处理的CMakeLists.txt所在的目录 CMAKE_CURRENT_LIST_DIR 当前正在处理的列表文件的目录]]></content>
      <tags>
        <tag>CMake</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SLAM概览]]></title>
    <url>%2F2019%2F09%2F10%2FVSLAM-2%20SLAM%E6%A6%82%E8%A7%88%2F</url>
    <content type="text"><![CDATA[尺度（Scale）：单目SLAM估计的轨迹和地图相比真实的相差一个因子 基线（Baseline）：组成双目相机的两个单目相机之间的已知距离 视觉SLAM流程： ​ 1）传感器信息读取 ​ 2）前段视觉里程计：估算相邻图像间相机的运动，以及局部地图的样子 ​ 3）后端（非线性）优化：优化前段输出和回环检测信息 ​ 4）回环检测 ​ 5）建图 视觉里程计： 度量地图（稀疏地图，稠密地图 拓扑地图（连通性 SLAM问题的数学表达： ​ 1）运动：k-1 =&gt; k时刻，位置x 的变化： ​ 运动方程： \begin{align} & x_k=f(x_{k-1},u_k,w_k)\\ & u_k:运动传感器的读数或者输入\\ & w_k:该运动过程中加入的噪声\\ & f\:抽象指代运动过程方式 \end{align}​ 2）观测：在k时刻，在 xk 处探测到某一个路标 y_j ，产生观测数据z{k,j} ​ 观测方程： \begin{align} & z_{k,j}=h(y_i,x_k,v_{k,j})\\ & v_{k,j}:这次观测的噪声\\ &观测数据z和观测方程h与运动方程中的x和f一样，有许多种不同的形式 \end{align}运动方程的解释举例： \begin{align} & x_k=\begin{bmatrix} x_1\\ x_2\\ \theta \end{bmatrix}_k \rightarrow x_k：位姿；x_1,x_2:运动机器人两个轴上的位置；\theta为转角\\ &\\& u_k=\begin{bmatrix} \Delta x_1\\ \Delta x_2\\ \Delta\theta \end{bmatrix}_k \rightarrow u_k:输入指令；\Delta x_1,\Delta x_2:两个时间间隔位置变化量；\Delta\theta为转角变化量\\ &\\& \Rightarrow\begin{bmatrix} x_1\\ x_2\\ \theta \end{bmatrix}_k=\begin{bmatrix} x_1\\ x_2\\ \theta \end{bmatrix}_{k-1}+\begin{bmatrix} \Delta x_1\\ \Delta x_2\\ \Delta\theta \end{bmatrix}_k+w_k \end{align}观测方程的解释举例： \begin{align} & 机器人携带的二维激光传感器，观测一个2D路标点，可得：\\ &r\rightarrow路标点和机器人本体间的距离\\ &\phi\rightarrow路标点和机器人本体间的夹角\\ &路标点：y_j=\begin{bmatrix} y_1\\ y_2 \end{bmatrix}_j ,位姿：x_k=\begin{bmatrix} x_1\\ x_2 \end{bmatrix}_k,观测数据：z_{k,j}=\begin{bmatrix} r_{k,j}\\ \phi_{k,j} \end{bmatrix},\\&\\ &观测方程\Rightarrow\begin{bmatrix} r_{k,j}\\ \phi_{k,j} \end{bmatrix}=\begin{bmatrix} \sqrt{(y_{1,j}-x_{1,j})^2+(y_{2,j}-x_{2,j})^2}\\ arctan(\frac{y_{2,j}-x_{2,k}}{y_{1,j}-x_{1,k}}) \end{bmatrix}+v \end{align}所以SLAM过程总结为两个基本方程： \begin{align} &\left\{\begin{matrix} x_k=f(x_{k-1},u_k,w_k),\;k=1,...,K\\ z_{k,j}=h(y_i,x_k,v_{k,j}),\;(k,j)\in O \end{matrix}\right.\\ &已知运动测量读数u，传感器读数z，求解定位问题（估计x）和建图问题（估计y）\\ &\Rightarrow建模为一个\textbf{状态估计问题}:如何通过带有噪声的测量数据，估计内部的隐藏着的状态变量？ \end{align}『声波、温度……』 参考资料： 视觉SLAM十四讲：从理论到实践（第2版）. 高翔.]]></content>
      <categories>
        <category>SLAM</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Makefile 学习笔记]]></title>
    <url>%2F2019%2F09%2F08%2FMakefile-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Makefile 格式 表明输出的目标，输出目标的依赖对象和生成目标需要执行的命令 目标 ： 前提依赖 『TAB』执行命令 组成 显式规则 隐式规则 ​ make推导出的规则 变量定义 文件指示 注释 执行 读取makefile文件 读入关联文件 初始化变量 递归式执行（执行依赖链上的目标 显式规则 依赖关系 发生依赖关系，执行命令 伪目标 使用.PHONY来标识，可以避免和工作目录下的实际文件名发生冲突 123.PHONYclean: rm -f *.c 隐含规则 通配符 12%.o : %.c $(CC) -c %.c -o %.o 文件目录 在链接不同目录下的文件时，需要告知make寻找路径： 使用VPATYH变量 12# make依次按序搜索文件VPATH = /src : ../inc #不同目录中间用冒号分隔 使用vpath关键字 12345678# 使用 % 来指定特定文件# 1 寻找指定目录下的特定文件vpath %.c dir1 # 寻找dir1下的.c文件# 2 清除符合特定文件的搜索目录vapth %.c# 3 清除所有（由vpath命令）已被设置好的文件搜索目录vpath 变量 变量声明与使用 在变量声明时，需要对变量进行赋值；在使用时需要使用$(VARNAME)的形式 123var = a.c b.ctarget : $(var) # command 变量中的变量 = 替换 := 恒等与（常量），按序声明 ?= 定义未定义过的变量 += 给一个变量追加一个值 自动化变量 $@ 目标文件 $&lt; 第一个依赖文件 $% $? $^ 所有的依赖文件 $+ $* 文件指示 函数]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识SALM]]></title>
    <url>%2F2019%2F09%2F07%2FVSLAM-1%20%E5%88%9D%E8%AF%86SLAM%2F</url>
    <content type="text"><![CDATA[SLAM [1] Ax = b 1）矩阵相乘关系 m*n·n*s = m*s2）讨论齐次方程组『Ax = 0』的解 \begin{align}定义：& \eta_1,\eta_2,...\eta_t是方程 Ax = 0 的解，如果\\（1）& \eta_1,\eta_2,...\eta_t线性无关；\\（2）&方程 Ax = 0 的任一解都可由\eta_1,\eta_2,...\eta_t线性表示，\\那么&\eta_1,\eta_2,...\eta_t叫做方程Ax=0的一个基础解系。\end{align} \Rightarrow可得通解：x = k_1\eta_1+k_2\eta_2+...k_t\eta_t​ ​ 非其次方程有解的充要条件是 系数矩阵（A）与增广矩阵（在A的右侧加一列b）的秩r相等。当r=A的未知数个数n，方程组有一解，当r&lt;n时，有无穷多解 3）非其次方程组的解的结构 ​ Ax=b若有解，则解x为他的一个解与导出组(Ax=0)解之和 即 x = k_1\xi_1+k_2\xi_2+...k_{n-r}\xi_{n-r}+\eta^*4）所以要求Ax=b的解，首先A和b要满足系数矩阵和增广矩阵的秩要相等（有解条件），再通过初等变换（高斯消元）来求解其次方程的解，再求得非其次的一个特解（代入基） [2] 高斯分布 \frac{1}{ \sqrt{2\pi}\sigma}{e}^{-\frac{(x-\mu)^2 }{2\sigma^2} }μ为均值，σ为方差 1 当μ=0，σ=1时，为标准高斯分布 2 当μ改变，σ不变时，分布图像平移 3 当μ不变，σ改变时，分布图像随σ增大而变扁 μ决定对称轴，σ决定扩散程度 https://www.cnblogs.com/lvchaoshun/p/7115460.html ​ 1）最大似然估计 ​ 似然函数：关于统计模型参数的函数，给定模型参数的情况下观测值出现的概率。定义为条件概率： p(\{x_i\}|\mu,\sigma)​ 最大似然估计是利用已知的样本结果，在使用某个模型的基础上，反推有可能导致这样结果的模型参数值 \begin{align} & \Rightarrow 给定观测值\{x_i\}，求\mu和\sigma，是的似然函数最大\\ & \Rightarrow p({\{x_i\} }|\mu,\sigma)=\prod_1^Np({x_i}|\mu,\sigma)\\ & \Rightarrow \hat{\mu},\hat{\sigma}=arg\: max\prod_1^Np({x_i}|\mu,\sigma)\\ 求得：&\hat{\mu}=\frac{1}{N}\sum_{i=1}^Nx_i\\ &\hat{\sigma}=\frac{1}{N}\sum_{i=1}^N(x_i-\hat{\mu})^2 \end{align}​ 即求得一元高斯分布 ​ 2）多元高斯分布 ​ 标准的二元高斯分布： \begin{align}& D=2\\&x=\begin{bmatrix}x & y\end{bmatrix}^T\\&\mu=\begin{bmatrix}0 & 0\end{bmatrix}^T\\&\Sigma=\begin{bmatrix}1 & 0\\ 0 & 1\end{bmatrix}\end{align}​ 三元高斯分布： \begin{align} & D = 3 \\ & x = [x_R\;x_G\;x_B]\\ & \mu = [\mu_R\;\mu_G\;\mu_B]\\ &\Sigma=\begin{bmatrix} \sigma_{x_R}^2 & \sigma_{x_R}\sigma_{x_G} & \sigma_{x_R}\sigma_{x_B}\\ \sigma_{x_R}\sigma_{x_G} & \sigma_{x_G}^2 & \sigma_{x_G}\sigma_{x_B}\\ \sigma_{x_R}\sigma_{x_B} & \sigma_{x_G}\sigma_{x_B} & \sigma_{x_B}^2 \end{bmatrix} \end{align} [3] STL标准模板库 [4] [5] C++11 关键字和新的for循环语法，新的STL容器，多线程，智能指针内存管理 [6] [7] 在 Linux 或 Unix 操作系统中，所有的文件和目录都被组织成以一个根节点开始的倒置的树状结构。 ​ /bin命令，/boot启动时的核心文件，/etc系统配置文件，/home用户主目录，/usr应用程序和文件 类似于program files ​ 当前目录：. 上级目录：.. [8] 安装方式 ​ 1）deb包安装：下载deb格式的软件后，sudo dpkg -i [name].deb ​ 2） tar.gz软件编译安装：解压后，./configure，make，sudo make install ​ 3） apt-get 安装：sudo apt-get install [software-name] ​ 4）脚本安装：例如./clion.sh [9] 参考资料： 视觉SLAM十四讲：从理论到实践（第2版）. 高翔.]]></content>
      <categories>
        <category>SLAM</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令总结]]></title>
    <url>%2F2019%2F09%2F01%2FGit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[git Commit 创建一个提交：1git commit Branch Git分支是指向某个提交记录，不会造成内存上的开销，按逻辑分解工作到不同的分支，星号（ * ）标识表示当前所在分支 创建分支： 1git branch newbranch 切换分支：（从master分支切换到newbranch分支） 1git checkout newbranch 简洁方式： 创建一个分支并且切换到新的分支上 1git checkout -b &lt;branch_name&gt; 1cpp git branch xx master^^2^ Merge 将两个或两个以上的开发历史合并到一起 1git pull &#x3D; git fetch + git merge Merge模拟： 12345git checkout -b newbranchgit commit -m &quot;newbranch提交&quot;git checkout mastergit commit -m “master提交”git merge newbranch &#x2F;&#x2F;将newbranch合并到master Rebase 1 合并多个commit为一个完整commit 2 将某一段commit粘贴到另一个分支上 将newbranch分支的工作移到master分支上，实现并行开发：123456git checkout -b newbranchgit commit -m &quot;newbranch更新&quot;git checkout mastergit commit -m &quot;master更新&quot;git checkout newbranchgit rebase newbranch HEAD HEAD 是一个对当前检出记录的符号引用 —— 也就是指向你正在其基础上进行工作的提交记录，常情况下指向分支名 C0 → C1（ master* ）：HEAD → master → C1 然后执行1git checkout C1，变成 HEAD → C1 分离出HEAD并使其指向一个提交记录1git checkout &lt;hash-value&gt; 相对引用（ ^/~ ） 使用 ^ 向上移动 1 个提交记录 使用 ~&lt;num&gt; 向上移动多个提交记录，如 ~3 1git checkout xxx^ 1cpp git checkout xxx~3 强制修改分支位置： 1git branch -f master HEAD^ 将master分支强制移动到HEAD的上一个分支 撤销变更 git reset git reset 向上移动分支，原来指向的提交记录就跟从来没有提交过一样 对共享远程分支无效 1git reset HEAD~1 git revert 撤销更改并支持分享给别人 1git revert HEAD 创建一个新的提交，该提交与HEAD的前一条提交相同 自由修改提交树 git Cherry-pick （知道提交的哈希值 git cherry-pick &lt;提交号&gt;… 将一些提交复制到当前所在的位置（HEAD）下面 12git cherry-pick C3 C4 C5 交互式rebase 参数 —interactive ，简写为 -i 12git rebase -i HEAD~3 调整提交记录的顺序 删除提交 合并提交 标签 可以永久将某个特定的提交命名为里程碑，不会随着新的提交而移动，它表示了某个特定位置 1git tag version1 C1 锚点 描述最近的标签，1git describe &lt;ref&gt;，得到例ref最近的标签、二者间相差多少个提交记录 远程仓库 Clone 在本地创建一个远程仓库的拷贝 远程分支 反映了远程仓库的状态，在检出时自动进入分离 HEAD 状态。 远程分支命名规范： [remote name] / [branch name] 例如：origin/master，分支为 master ，远程仓库为 origin 在使用 git clone 时，git将远程仓库命名为 origin（默认命名） 1git checkout origin&#x2F;master（head分离） Fetch 从远程仓库下载本地仓库缺失的提交记录 更新远程分支指针 （实际上将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态） （为下载操作，不改变本地仓库状态） Pull 从远程仓库获取更新并合并到本地的分支当中 Push git push将变更上传到远程仓库，并在其上合并提交记录 偏离的提交历史 对于提交已更新的旧版本的更改，需要先合并新版本在提交更改 git commit//对于旧版本的更改 git pull --rebase//合并新版本并提交更改 git push//提交到远程分支]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[19-07-08]]></title>
    <url>%2F2019%2F07%2F10%2F19-07-08%2F</url>
    <content type="text"><![CDATA[Enter password to read. Incorrect Password! No content to display! U2FsdGVkX182vKHtaQug8cWhnrVMfDh8SGaMDjpMM+Fxfk2si3QZWryA6nng9M6AXK8b3x74OTtyAzrCTzHawRu2M9iEm8pWuiD+sWuGUzdRggdNMtEYsdoqs6oTQokx]]></content>
  </entry>
  <entry>
    <title><![CDATA[测试]]></title>
    <url>%2F2019%2F06%2F23%2F%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[Hello World Test Welcome 测试 quote test … Testtest Every interaction is both precious and an opportunity to delight. Seth GodinWelcome 1alert('Hello World!');]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F06%2F22%2Fhello-world%2F</url>
    <content type="text"><![CDATA[INIT Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new "My New Post" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
