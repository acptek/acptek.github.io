<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[特征点提取与匹配]]></title>
    <url>%2F2019%2F10%2F27%2F%E7%89%B9%E5%BE%81%E7%82%B9%E6%8F%90%E5%8F%96%E4%B8%8E%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[视觉里程计：根据相邻图像的信息估计相机的运动，作为后端的初值 特征点法、直接法 在相机运动过程中观测到的路标点，在某一个位姿，相机观测到物体的像素坐标为$(u,v)$，则对应满足相机模型关系： Z P_{uv}=Z\begin{bmatrix}u\\v\\1\end{bmatrix}=K(RP_w+t)=KTP_w特征点提取与匹配特征点概念​ 1）路标：有代表性的点 ​ 2）特征：图像信息的另一种数字表达形式，角点&gt;特征&gt;区块 特征点 = 关键点 + 描述子 关键点特征点在图像中的位置 描述子描述关键点周围像素信息的向量，例如对关键点周围亮度的表现。 在ORB中，在关键点周围随机选择128对或256对点（对于每张相机图像里的每个关键点，都可以使用相同的随机选择模板），以每一对的亮度相似程度按二进制赋值，生成一个128或256位的二进制数，以此数来表述描述子。 同时，在ORB-BRIEF描述子中，考虑到图像的旋转，针对每张图像以灰度质心法计算图像中每个特征点方向，或者计算整体图像旋转的向量，以此旋转向量调整随机选择模板（对随机选择的点也进行旋转），再生成描述子。 最后，对描述子进行特征匹配。在ORB中，描述子的匹配以汉明匹配方式进行匹配。但是在ORB中，BRIEF描述子没有涉及到尺度这一特征。 ​ 特征提取算法SIFT：尺度不变特征变换（计算量大） FAST关键点：没有描述子（计算快） ORB：FAST特征点 + BRIEF描述子 ORB特征提取和匹配 FAST关键点目的是对图像的 平移、旋转、尺度 进行特征提取。 图像金字塔：用于提取图像的尺度特征，描述相机前后运动的过程 ​ 1 塔底为原始图像，每往上一层对图像进行固定倍率（例：1.2，1.5，2倍等）缩放，得到不同分辨率图像（小远大近） ​ 2 两图像间，匹配不同层上的图像 Oriented FAST关键点中没有涉及到这一特性 特征旋转：计算图像灰度质心（以图像块灰度值作为权重的中心 ）​ 1 图像块的矩：其中，I(x, y)为f(x, y)的二值图像，取值0或1 m_{pq}=\sum\limits_{x,y\in B}x^py^qI(x,y),\;p,q=\{0,1\}​ 2 图像块的质心：$ C=(m{10}/m{00},m{01}/m{00}) $ ​ 3 特征方向：表示为 $ \theta=\arctan(m{01}/m{10}) $，连接几何中心O和质心C得到的方向向量 BRIEF描述子在关键点附近随机选取K对点，以K位二进制的形式反映他们的大小关系，以此作为对一个特征点的描述。又由于在FAST关键点中计算了关键点的方向，利用方向信息计算旋转后的特征。 ORB特征匹配数据关联问题：确定前后看到的路标间的对应关系 问题：1 误匹配 2 匹配方法 描述点的距离表示了两个特征之间的相似程度 注：（SIFT……）快速近似邻近（FLANN），但不适用于计算汉明距离]]></content>
      <categories>
        <category>SLAM</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>Math</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[状态估计中的最小二乘]]></title>
    <url>%2F2019%2F10%2F16%2F%E7%8A%B6%E6%80%81%E4%BC%B0%E8%AE%A1%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%2F</url>
    <content type="text"><![CDATA[状态估计 状态估计，是根据系统的先验模型和测量序列，对系统内在状态进行重构的问题 背景 \left\{\begin{matrix} 运动方程（相机位姿）：x_k = f(x_{k-1},u_k,w_k) \\ 观测方程（针孔模型）：z_{k,j}=h(y_j,x_k,v_{k,j}) \end{matrix}\right.$x_k = T_k = \exp({\xi_k}^\wedge)$：x_k是一个六自由度的位姿，可以由一个变换矩阵来描述，也可以用李代数的指数来描述。 $sz_{k,j}=K\exp(\xi^\wedge)y_j$：内参×外参×路标点 = 像素点距离×像素 考察问题当已知观测方程和运动方程的具体形式，如何对估计值进行优化？ 即：如何通过 观测量z 和 输入量u 去优化 机器人的轨迹、位置x 和 路标点的位置y （SLAM过程）？ 这是一个状态估计问题：通过已知的带有噪声的数据 去推断出无法直接获得的状态 该问题下的状态估计状态变量：$x={x_1,…,x_N,y_1,…y_M}$：所有时刻的位姿x 和 所有时刻的路标（地图）y 所以状态估计等同于求解条件分布： P(x | z, u) x在z，u条件下的概率分布（x, z, u都表示所有时刻的统称） 状态估计问题分类：1 线性系统 ：若f和h是线性方程（有几个线性量，加和，数乘组成） 2 高斯噪声：噪声属于高斯分布 3 非线性系统 4 非高斯噪声 此处的状态估计具有 马尔科夫性（下一个时刻的状态依赖于上一个时刻的状态） 状态估计描述在k个时间点上，基于初始状态信息、一系列观测数据、一系列输入，以及系统的运动模型和观测模型，来计算系统的真实状态估计值。 从概率学角度求状态估计在不知道输入控制u，只有图像时，忽略u并只考虑观测数据 P(x|z)：已知图像，推断x的分布：称为后验概率 贝叶斯： 似然概率：p(z|x)：在某一个状态x下观测图像（确定图像与当前图像的相似程度） 先验概率：P(x)：x自己的状态 对于p(x|z)：x的维度很高，难以写出其分布，但是可以求： 1）最大后验估计​ 使得 p(x|z)最大的 x 的估计 (${x^*}_{MAP}$)，即在某一种分布下 x 的最优估计，此时是一个估计出的量 ​ ${x^*}_{M A P} = \arg \max P(x|z) = \arg \max P(z|x)P(x)$ ​ 注释：寻求一个x使得p(x|z)达到最大，此时称为x为最大后验估计，表示：在怎样的x下拿到的相机数据和现在数据（已有的）是最像的 2）最大似然估计​ 当最大后验估计中无法得知 x时（不知道 机器人轨迹 的先验是什么样子的时候），则直接最大化似然 ​ ${x^*}_{MLE} = \arg \max P(z|x)$ ​ 注释：当不知道先验概率时（x原本应该是什么样子，或者x就是一个随机的运动）即没有先验时，则此时最大化似然就可以了。表示：最大化x，使得在此状态下看到的数据最像我们看到的数据，P(z|x) 即“在哪种状态下，最容易产生当前的观测” 求解最大似然估计某次观测：$z{k,j}=h(y_j, x _k)+v{k, j}$，噪声服从0均值高斯分布$vk\sim \mathcal{N}(0,Q{k,j})$ 所以观测数据条件概率（将h加到噪声分布上） P(z_{j,k}|x_k,y_j)=N(h(y_j, x _k), Q_{k,j})对于N维高斯分布 $x\sim \mathcal{N}(\mu,\Sigma)$的概率密度展开式： p(x)=\frac{1}{\sqrt{(2\pi)^N\det(\Sigma)} }\exp(-\frac{1}{2}(x-\mu)^T\Sigma^{-1}(x-\mu))它的右侧指数部分为一个二次型，若$\Sigma=I$，则指数部分就是一个二范数（误差的平方） 将展开式两边取对数并添加负号，得到p(x)只与马氏距离$-\frac{1}{2}(x-\mu)^T\Sigma^{-1}(x-\mu)$有关。 所以要求最大似然估计，就是求最小$-\ln(p(x))$ 最小二乘代入SLAM观测模型， (x_k, y_j)^*=\arg\min( \;(z-h(x,y))^T Q^{-1} (z-h(x,y))\;)等式右侧为一个最小二乘，即最小化噪声项（误差）的一个二次型（马氏距离） 其中，$Q^{-1}$为信息矩阵（协方差矩阵的逆，协方差反映两个变量相向的程度），用于噪声的控制调整 P(z,u|x,y)=\prod_kP(u_k|x_{k-1},x_k)\prod_{k,j}P(z_{k,j}|x_k, y_j)定义运动误差和观测误差：$e{u, k}，e{z, j, k}$，最小化估值和真实值之间的误差（即马氏距离）时，每一个误差对应一个最小二乘，所以得到一个最小二乘问题 $\min J(x, y)$ ，它等于所有时刻运动误差和观测误差的总和。 此最小二乘问题等价于状态的最大似然估计 非线性最小二乘探讨通用的无约束非线性最小二乘问题的求解 一阶梯度最速下降法，取增量为反向梯度 $\Delta x^*=-J(x_k)$ 二阶梯度牛顿法，保留了二阶梯度，$\Delta x = -H^{-1}J$ 高斯牛顿法将误差一阶展开，代入最小二乘，求梯度求解 J(x)J^T(x)\Delta x=-J(x)f(x) \; \Rightarrow\;H(x)\Delta x=g(x)称为高斯牛顿方程（正规方程）$H\Delta x=g$ . 其中：J(x)为f(x)关于x的导数，是一个1×n的向量 缺陷： 1）$H = JJ^T$可能不正定，无法求$H^{-1}$ 2）不考虑步长的取值造成误差 求解过程： 1 最小二乘式，确定待估计的变量 2 误差式 3 计算雅克比矩阵J 和 误差e 4 求解增量方程 Hx=g 5 迭代 LM增加指标 \rho = \frac{f(x + \Delta x) - f(x)}{ J(x)^T\Delta x}以该指标为 $\Delta x$ 添加一个信赖区域，以$\rho$值的大小来控制信赖区域的半径，使得在此区域内取得的$JJ^T \sim H$，从而用雅克比矩阵运算代替海塞矩阵的运算，同时，在约束项的控制下，保证了求解项左边矩阵可逆。 将约束项加入到最小二乘中： \mathcal{L}(\Delta x_k,\lambda)=\frac{1}{2}\left \| f(x_k) + J(x_k)^T\Delta x_k \right \|^2+\frac{\lambda}{2}(\left \| D\Delta x_k \right \|^2-\mu)其中，D为非负数对角阵，表示了对空间的约束。 对$\Delta x$求导后得：$(H+\lambda D^TD)\Delta x_k=g$ 矩阵微分 先使用微分法则展开复合微分项，再通过迹技巧，结合下式求解 df=tr(\frac{\partial f}{\partial X}^TdX)]]></content>
      <categories>
        <category>SLAM</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[相机标定]]></title>
    <url>%2F2019%2F10%2F04%2F%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[坐标系 世界坐标系 $(x_w,y_w,z_w)$ 相机坐标系 $(x_c,y_c,z_c)$ 图像坐标系 $(x,y)$ $x_p=f\frac{x_c}{z_c},y_p=f\frac{y_c}{z_c}$ 像素坐标系 $(u,v)$ $u=\frac{x_c}{d_x}+u_0,v=\frac{y_c}{d_y}+v_0$ 坐标系转换 1 世界坐标系到相机坐标系（旋转矩阵） 2 相机坐标系到图像坐标系（透视投影矩阵 3X4矩阵） 3 图像坐标系到像素坐标系（K 内参矩阵） K=\begin{bmatrix} f_x & 0 & u_0\\ 0 & f_y & v_0\\ 0 & 0 & 1 \end{bmatrix}，f_x=\frac{f}{d_x},f_y=\frac{f}{d_y} Z P_{uv}=Z\begin{bmatrix}u\\v\\1\end{bmatrix}=K(RP_w+t)=KTP_w张正友标定法在不考虑透镜畸变情况下求解内参和外参相机内参： fx,fy,u0,v0(,r=K12) ​ 相机外参：$T_x,T_y,T_z,\omega,\delta,\theta$ 单应性矩阵：单应性矩阵用于表示投射图像间的透视变换，变换图像的视图 单应性：从一个平面到另一个平面的投影映射，例如 \tilde{Q}=\begin{bmatrix}X\\Y\\Z\\1\end{bmatrix}\;\rightarrow\;\tilde{q}=\begin{bmatrix}x\\y\\1\end{bmatrix}\;\Rightarrow\;\tilde{q}=sH\tilde{Q}定义标定板平面为世界坐标系中 Z=0 的平面 s\begin{bmatrix}u\\v\\1\end{bmatrix}=K\begin{bmatrix}R & t\end{bmatrix}\begin{bmatrix}x\\y\\z\\1\end{bmatrix}=K\begin{bmatrix}r_1 & r_2 & r_3 & t\end{bmatrix}\begin{bmatrix}x\\y\\0\\1\end{bmatrix}=K\begin{bmatrix}r_1 & r_2\end{bmatrix}\begin{bmatrix}x\\y\\1\end{bmatrix}其中，$s$为尺度因数（使得单应性定义到该尺度的比例），$H=K\begin{bmatrix}r_1 &amp; r_2 &amp; t\end{bmatrix}$为成像平面和标定平面之间的单应矩阵（由变换和相机内参两部分组成，$r_1,r_2,t$ 分别为旋转矩阵的前两个列向量和平移向量），$\begin{bmatrix}R&amp;t\end{bmatrix}$是一个3X4的矩阵（前3X3是旋转矩阵，后3X1是一个平移向量t） 图像平面(src)的点集与目标平面(dst)上的点集 间的关系（由单应性矩阵确定）： \begin{align} & p_{dst}=Hp_{src} , p_{src}=H^{-1}p_{dst}\\\\ &p_{dst}=\begin{bmatrix}x_{dst}\\y_{dst}\\1\end{bmatrix},p_{src}=\begin{bmatrix}x_{src}\\y_{src}\\1\end{bmatrix} \end{align}记：$H=\begin{bmatrix}h_1&amp;h_2&amp;h_3\end{bmatrix}$ 求内参矩阵由 H=s^{-1}K\begin{bmatrix}r_1 & r_2&t\end{bmatrix}\tag{1} r_1r_2=0\tag{2},|r_i|=1（1）（2）可推导出两等式， \begin{align} &h_1^TK^{-T}K^{-1}h_2=0\\ &h_1^TK^{-T}K^{-1}h_1=h_2^TK^{-T}K^{-1}h_2 \end{align}通过两张不同位置的图片，可以标定后求解出相机内参矩阵K（四个未知数四个方程） 求外参矩阵在求得内参矩阵后，则可以估算外参矩阵： \begin{align} &H=s^{-1}K\begin{bmatrix}r_1 & r_2&t\end{bmatrix}\\ \Rightarrow&\left\{\begin{matrix} r_1=s^{-1}A^{-1}h_1\\ r_2=s^{-1}A^{-1}h_2\\ r_3=r_1\times r_2\\ t = s^{-1}A^{-1}h_3 \end{matrix}\right.,s^{-1}=\frac{1}{||K^{-1}h_1||}=\frac{1}{||K^{-1}h_2||} \end{align}考虑畸变，求解畸变系数径向畸变处理 参数最优化非线性最小二乘法，极大似然估计 12345// image creatorif(!((i+j)%2)) rectangle(ChessImage, Point(Start.x+i*SingleSize, Start.y+j*SingleSize), Point(Start.x+(i+1)*SingleSize-1, Start.y+(j+1)*SingleSize-1), Scalar(0, 0, 0), -1); 12345// image captureVideoCapture capture;Mat frame;capture.open( [filename] )while(true) capture &gt;&gt; frame 123// opencv/samples/cpp/calibration.cppcv::findChessboardCorners() //绘制交点cv::calibrationCamera() //校准 123456// cv::undistort() //校正畸变double x = (u - cx)/fx, y = (v - cy)/fy; // X/Z , Y/Z -&gt; 归一化坐标 （X/Z Y/Z 1）-&gt; 映射到二维 -&gt; (x y) -&gt; 写成极坐标形式 （r theta）double r = sqrt(x*x + y*y); // 极坐标 长度double u_distort = fx * x * (1 + k1*pow(r, 2) + k2*pow(r, 4) + k3*pow(r, 6) ) + 2*p1*x*y + p2*(pow(r, 2) + 2*pow(x, 2) ) + cx;double v_distort = fy * y * (1 + k1*pow(r, 2) + k2*pow(r, 4) + k3*pow(r, 6) ) + p1*(pow(r, 2) + 2*pow(y, 2) ) + 2*p2*x*y + cy; 畸变方程 \left\{\begin{matrix} x_{distorted}= x(1+k_1r^2+k_2r^4+k_3r^6)+2p_1xy+p_2(r^2+2x^2)\\ y_{distorted}= y(1+k_1r^2+k_2r^4+k_3r^6)+p_1(r^2+2y^2)+2p_2xy \end{matrix}\right. \Rightarrow \left\{\begin{matrix} u=f_xx_{distorted} + c_x\\ v=f_yy_{distorted} + c_y\end{matrix}\right. 12./imagelist_creator imagelist.yaml [path].jpg./calibration -w=[num] -h=[num] [-op] [-oe] [...] imagelist.yaml 123# out_camera_data.ymlcamera_matrix: //相机内参distortion_coefficients: //畸变系数]]></content>
      <categories>
        <category>CV</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VSLAM-4.2 李代数求导]]></title>
    <url>%2F2019%2F09%2F22%2FVSLAM-4-2-%E6%9D%8E%E4%BB%A3%E6%95%B0%E6%B1%82%E5%AF%BC%2F</url>
    <content type="text"><![CDATA[1） SLAM的过程就是不断的估计相机的位姿和建立地图，在此过程中会出现一定的误差，所以目的是寻找一个最佳位姿（通过优化方法，一般采用迭代优化方法，每次迭代都更新一个位姿的增量delta，使得目标函数最小。这个delta就是通过误差函数对T微分得到的。也就是说我们需要对变换矩阵T求微分），使得整体误差最小。 为此，可以列出关于变换矩阵T的目标函数，要求解方程需要对变换矩阵求导。 2） 就旋转矩阵而言，其矩阵加法不封闭，为此不满足导数定义中“加一个极小量”。所以，要使得矩阵满足求导运算，引出李群和李代数。 李群是具有连续性质的群，群上定义了某种矩阵的集合。对于旋转矩阵、变换矩阵都是满足李群的定义，例如旋转矩阵在旋转矩阵的集合中关于乘法运算满足李群。李群运算不满足求导，但与李群对应的李代数满足加法后保持性质。至此，将变换矩阵求导的问题转化为了求李代数的导数问题。 在讨论李代数的物理意义时，so(3)就代表了旋转向量组成的空间。实际上，so(3)是三维向量phi的集合，每个向量phi^表达了这个李代数对应的李群SO(3)上旋转矩阵R的导数。其中，R与phi是一个指数映射关系。 关于李代数和李群在几何意义上的关系：李代数对应李群的正切空间，描述了李群的局部导数。 李代数求导BCH公式 \ln(\exp(A)\exp(B))=A+B+\frac{1}{2}[A,B]+\frac{1}{12}[A,[A,B]]-\frac{1}{12}[B[A,B]]+...其中“[ , ]”为李括号。 考虑SO(3)上的李代数： \ln(\exp(\phi_1^\wedge)\exp(\phi_2^\wedge))^\vee=\left\{\begin{matrix} {J_l(\phi_2)}^{-1}\phi_1+\phi_2\;\;当\phi_1为小量\\ {J_r(\phi_1)}^{-1}\phi_2+\phi_1\;\;当\phi_2为小量 \end{matrix}\right.\tag{*}第一个近似描述了：对一个旋转矩阵$R2$（李代数$\phi_2$），左乘一个微小旋转$R_1$，近似看作：在李代数$\phi_2$上加了一项${J_l(\phi_2)}^{-1}\phi_1$. J_l=J=\frac{\sin\theta}{\theta}I+(1-\frac{\sin\theta}{\theta})\alpha\alpha^T+\frac{1-\cos\theta}{\theta}\alpha^\wedge\tag{**} J^{-1}=\frac{\theta}{2}\cot\frac{\theta}{2}I+(1-\frac{\theta}{2}\cot\frac{\theta}{2})\alpha\alpha^T-\frac{\theta}{2}\alpha^\wedge\tag{**}右乘：$J_r(\phi)=J_l(-\phi)$ 至此，得到李群乘法和李代数加法的关系 BCH近似$旋转矩阵R，其李代数\phi，微小旋转\Delta R，其李代数\Delta\phi$，李群乘法$\rightarrow$李代数加法 \exp(\Delta\phi^\wedge)\exp(\phi^\wedge)=\exp((\phi+J_l^{-1}(\phi)\Delta\phi)^\wedge)\tag{***}李代数加法$\rightarrow$李群乘法 \exp((\phi+\Delta\phi)^\wedge)=\exp((J_l\Delta\phi)^\wedge)\exp(\phi^\wedge)=\exp(\phi^\wedge)\exp((J_r\Delta\phi)^\wedge)\tag{***}李代数求导两种思路： 1 导数模型 ， 2 扰动模型 SO(3)上的李代数求导$位姿T，观察点的世界坐标p，产生的观测数据z，随即噪声w$，对于N个观测误差$e=z-Tp$，（寻找一个最优T，使误差最小） \underset{T}{\min}J(T)=\sum_{i=1}^N||z_i-Tp_i||_2^2李代数求导1）按照导数模型，（根据李代数的加法结合导数的定义来求旋转后点的坐标对于旋转的导数，或者说是求旋转很小时偏移的变化率），可以求得： \begin{align} & \frac{\partial (\exp(\phi^\wedge)p)}{\partial \phi}\approx-(Rp)^\wedge J_l\\&\\ \Rightarrow &\frac{\partial (Rp)}{\partial \phi}=(-Rp)^\wedge J_l \tag{旋转后的点对于李代数的导数} \end{align}2）扰动模型，对旋转矩阵R进行一次扰动$\Delta R$（对应的李代数为$\varphi $），看结果相对于扰动的变化率。 \frac{\partial (Rp)}{\partial \phi}=(-Rp)^\wedgeSE(3)上的李代数求导空间点p，变换T（对应的李代数为$\xi$），扰动变换$\Delta T=\exp(\delta\xi^\wedge)$，其李代数为$\delta\xi=[\delta\rho,\delta\phi]^T$： \frac{\partial (Tp)}{\partial \delta\xi}=\begin{bmatrix}I & -(Rp+t)^\wedge\\ 0^T & 0^T\end{bmatrix}git]]></content>
      <categories>
        <category>SLAM</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VSLAM-4.1 李群李代数及其转换的映射]]></title>
    <url>%2F2019%2F09%2F21%2FVSLAM-4-1-%E6%9D%8E%E7%BE%A4%E6%9D%8E%E4%BB%A3%E6%95%B0%E5%8F%8A%E5%85%B6%E8%BD%AC%E6%8D%A2%E7%9A%84%E6%98%A0%E5%B0%84%2F</url>
    <content type="text"><![CDATA[李群与李代数（1）群代数结构：一种集合+集合上的一种运算 满足性质：封闭性、结合率、幺元、逆 李群：具有连续（光滑）性质的群 （2）李代数与李群对应的一种数据结构 引出李代数旋转矩阵$R$是某个相机的旋转，并随时间连续地变化 \begin{align} & R(t)R(t)^T=I\tag{两边对t求导} \\ \Rightarrow\;& \dot{R}(t)R(t)^T+R(t)\dot{R}(t)^T=0\\ \Rightarrow\;& \dot{R}(t)R(t)^T = -(\dot{R}(t)R(t)^T)^T\\&\\ \rightarrow\;&\dot{R}(t)R(t)^T是一个反对称矩阵 \end{align}所以，找到一个三维向量$\phi(t)\in\mathbb{R^3}$记： \begin{align} & \phi(t)\text{^}=\dot{R}(t)R(t)^T \tag{1}\\&\\ \Rightarrow\;&\dot{R}(t)=\phi(t)\text{^}R(t)\tag{2} \end{align}考虑：$t_0=0时，R(0)=I$，在0处泰勒展开： R(t)\approx R(t_0)+\dot{R}(t_0)(t-t_0)=I+\phi(t_0)\text{^}t在$t_0$附近，$\phi(t_0)=\phi_0$为常数，所以得到关于R的微分方程，得： R(t)=e^{\phi\text{^}t} \tag{3}李代数的定义每个李群对应一个李代数。李代数描述了李群的局部性质，是单位元附近的正切空间（tangent Space切线空间，是一种三维空间） 集合$\mathbb{V}$ + 数域$\mathbb{F}$ + 二元运算（李括号）[ , ] = 李代数 \mathfrak{g}=(\mathbb{V},\mathbb{F},[,])性质：封闭性、双线性、自反性（与自身运算结果为零）、雅可比等价 李代数$\mathfrak{so}(3)$定义$\Phi=\phi^\wedge$，得 李括号为： [\phi_1,\phi_2]=(\Phi_1\Phi_2-\Phi_2\Phi_1)^\vee \mathfrak{so}(3)=\begin{Bmatrix} \phi=\mathbb{R^3},\Phi=\phi^\wedge\in\mathbb{R^{3\times3} } \end{Bmatrix}\tag{*}所以，so(3)是一个由三维向量组成的集合，每个向量对应一个反对称矩阵，表达旋转矩阵的导数 对应SO(3)，$ R(t)=e^{\phi\text{^}t} $ SO(3)=\{R\in\mathbb{R}^{3\times 3}|RR^T=I,det(R)=1\}\tag{*}李代数$\mathfrak{se}(3)$ \mathfrak{se}(3)=\begin{Bmatrix} \xi =\begin{bmatrix} \rho \\ \phi \end{bmatrix}\in\mathbb{R}^6,\rho\in\mathbb{R}^3,\phi\in\mathfrak{so}(3),\xi^\wedge =\begin{bmatrix} \phi^\wedge & \rho\\ 0^T & 0 \end{bmatrix}\in\mathbb{R}^{4\times4} \end{Bmatrix}$\mathfrak{se}(3) $：由一个平移+一个$\mathfrak{so}(3)$构成的向量 $\mathfrak{se}(3)$对应的李括号： [\xi_1,\xi_2]=(\xi_1^\wedge\xi_2^\wedge-\xi_2^\wedge\xi_1^\wedge)^\vee指数与对数映射（1）SO(3)上的指数映射1 指数映射：在李群李代数中，一个矩阵的指数 2 通过泰勒展开，得$\mathfrak{so}(3)中的任意元素\phi的指数映射$： \text{exp}(\phi^\wedge)=\sum_{n=0}^\infty \frac{1}{n!}(\phi^\wedge)^n3 关于上述定义的计算： 定义$\phi$的 模长$\theta$，方向$\alpha$，$\phi=\theta\alpha$，其中$||a||=1$ 关于$\alpha$的性质：$\alpha^\wedge\alpha^\wedge=\alpha\alpha^T-I$，$\alpha^\wedge\alpha^\wedge\alpha^\wedge=-\alpha^\wedge$，将$\theta\alpha$代入指数映射： \begin{align} \text{exp}(\phi^\wedge)&=\text{exp}(\theta^\wedge\alpha)\\ &=\cos{\theta I}+(1-\cos\theta)\alpha\alpha^T+\sin\theta\alpha^\wedge \end{align}【注】 罗德里格斯公式：R=cos\theta I+(1-cos\theta )nn^T+sin\theta n\text{^}由此表明，$\mathfrak{so}(3)$实际上就是旋转向量组成的空间（李代数$\rightarrow$李群）其物理意义就是旋转向量，指数映射就是罗德里格斯公式（旋转向量$\rightarrow$旋转矩阵）（旋转矩阵的导数可以由旋转向量指定） 所以 \Rightarrow\;\phi =ln(R)^\vee=(\sum_{n=0}^\infty\frac{(-1)^n}{n+1}(R-I)^{n+1})^\vee但是，可以通过求解转角和转轴，可以更加简便的得到 $\theta$ 和 $\alpha$ \theta=arccos\frac{tr(R)-1}{2},Rn=n综上所述，得到李群SO(3)和李代数so(3)的对应关系，将旋转角控制在$（-\pi,\pi）$之间，二者成一一对应关系 （2）SE(3)上的指数映射 \text{exp}(\xi^\wedge)=\begin{bmatrix} \sum_{n=0}^\infty \frac{1}{n!}(\phi^\wedge)^n & \sum_{n=0}^\infty \frac{1}{()n+1)!}(\phi^\wedge)^n\rho\\ 0^T & 1 \end{bmatrix} \overset{\Delta}{=}\begin{bmatrix} R & J\rho\\ 0^T & 1 \end{bmatrix}=T经求解，得：$J=\frac{\sin\theta}{\theta}I+(1-\frac{\sin\theta}{\theta})\alpha\alpha^T+\frac{1-\cos\theta}{\theta}\alpha^\wedge$（雅可比矩阵） SE(3)右上角的平移向量t，结合$t=J\rho$，$J可由\phi求得$，可以求得 $\rho$ 由此，确定SE(3)和se(3)的转换关系]]></content>
      <categories>
        <category>SLAM</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VSALM-3.2 旋转向量 欧拉角 四元数]]></title>
    <url>%2F2019%2F09%2F17%2FVSALM-3-2-%E6%97%8B%E8%BD%AC%E5%90%91%E9%87%8F-%E6%AC%A7%E6%8B%89%E8%A7%92-%E5%9B%9B%E5%85%83%E6%95%B0%2F</url>
    <content type="text"><![CDATA[旋转向量表现形式旋转向量/轴角：用一个旋转轴和一人个旋转角来刻画任意一个旋转，方向和旋转轴一致，长度等于旋转角 所以，对于变换矩阵T，可以使用一个旋转向量和一个平移变量来表示，总共6个变量 旋转向量转化为旋转矩阵罗德里格斯公式： ​ 长度为$\theta$，轴角为$n$（单位长度的向量），用向量$\theta n$表示旋转。 R=cos\theta I+(1-cos\theta )nn^T+sin\theta n\text{^}​ 根据 迹 的性质，对该公式两边取迹，求得转角和旋转矩阵的关系。 \Rightarrow \theta=arccos\frac{tr(R)-1}{2}转轴转轴$n$上的旋转向量在旋转后不发生改变， Rn=n \;\Leftarrow\left\{\begin{matrix} Rn=\lambda n\\ \lambda = 1 \end{matrix}\right.所以，可以推导出$n$为旋转矩阵$R$特征值为1对应的特征向量。因此，已知旋转矩阵，即可求得旋转轴。 欧拉角将三个轴的旋转方向作定义，更加直观的表示旋转的过程。 但是在使用欧拉角时，会出现“万向锁问题”，例如可能导致三个轴的旋转实际只表示了两次旋转等情况。 四元数定义 \begin{align} & q=[s,v]^T,\;s=q_0 \in \mathbb{R},\;v=[q_1, q_2, q_3]^T \in \mathbb{R} . \\ &q = q_0+q_1i+q_2j+q_3k .\\ & s为实部，v为虚部 \end{align}运算1）自身三个虚部满足的乘法运算关系 2）两四元数加减法 3）两四元数的乘法 \begin{align} & q_a\: [s_a, v_a]^T,\;q_a=s_a+x_ai+y_aj+z_ak\\& q_b\:[s_b,v_b]^T,q_b=s_b+x_bi+y_bj+z_bk\\\rightarrow\\ &q_aq_b=[s_as_b-v_a^Tv_b, s_av_b+s_bv_a+v_a\times v_b]^T \end{align}4）模长 $||q||$ 5）共轭 $q^*$ q^*q=qq^*=[s_a^2+v^Tv, 0]^T.6）逆 $q^{-1}$ \begin{align} &q^{-1}=q^*/||q||^2\\ &q^{-1}q=qq^{-1}=1 \end{align}7）数乘 用四元数表示旋转在二维平面中，旋转数可以写为 $q=cos\theta+i*sin\theta$ 引申到三维旋转中，四元数向量表示为 $q\;[cos\theta, v*sin\theta]$ 三维空间点的旋转空间三维点：$p=[x,y,z]\in \mathbb{R^3}$ 单位四元数：$q$ ,用于指定旋转 1）将三维空间点用虚四元数表示： p=[0, x,y,z]^T=[0,v]^T2）旋转 p'=extend(R)p \Rightarrow p'=qpq^{-1}通过先乘q再作q逆乘法，相当与先用右手坐标系将空间点旋转二分之一的旋转角，再用左手坐标系逆向旋转二分之一旋转角，以此使得最终得到的四元数时纯虚四元数，从而直接表示三维空间坐标。（从几何意义上是将三维向量转化为四维后再回到三维） 四元数到其他旋转表示的转换定义：（将四元数的乘法写成矩阵乘法） q^+=\begin{bmatrix} s & -v^T\\ v & sI+v\text{^} \end{bmatrix},q^\oplus=\begin{bmatrix} s & -v^T\\ v & sI-v\text{^} \end{bmatrix} \Rightarrow q_1q_2=q_1^+q_2=q_2^\oplus q_1 \Rightarrow p'=qpq^{-1}=q^+p^+q^{-1}=q^+{q^{-1}}^\oplus p即$q^+{q^{-1}}^\oplus=extend(R)$，所以 四元数转换到旋转矩阵 q^+{q^{-1}}^\oplus=\begin{bmatrix} s & -v^T\\ v & sI+v\text{^} \end{bmatrix}\begin{bmatrix} s & v^T\\ -v & sI+v\text{^} \end{bmatrix}=\begin{bmatrix} 1 & 0\\ 0^T & vv^T+s^2I+2sv\text{^}+(v\text{^})^2 \end{bmatrix} \Rightarrow R=vv^T+s^2I+2sv\text{^}+(v\text{^})^2 \tag{*}四元数转换到旋转向量对两边取迹，得： tr(R)=4s^2-1其中，关于 $v(v_1,v_2,v_3)$，$v\text{^}$是向量$v$的反对称矩阵形式 tr((v\text{^})^2)=2(v_1^2+v_2^2+v_3^2) \tag{1}又由罗德里斯公式中： \Rightarrow \theta=arccos\frac{tr(R)-1}{2}\tag{2}最终得到四元数与旋转向量的转换关系 \Rightarrow \theta=2\arccos{s}综上，四元数到旋转向量的转换公式： \left\{\begin{matrix}\theta=2\arccos{q_0}\\ [n_x,n_y,n_z]^T=[q_1,q_2,q_3]^T/\sin{\frac{\theta}{2}}\end{matrix}\right. \tag{*}]]></content>
      <categories>
        <category>SLAM</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VSLAM-3.1 旋转矩阵]]></title>
    <url>%2F2019%2F09%2F12%2FVSLAM-3-1%20%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[旋转矩阵点，向量，坐标系$\mathbb{R}^3$$\mathbb{R}^3$描述三维空间中的某个坐标点，$(e_1, e_2, e_3)$：为空间中的一组基 \begin{align} 向量&\textbf{a}在基(e_1,e_2,e_3)下的坐标：\\ & \textbf{a} = [e_1,e_2,e_3]\begin{bmatrix} a_1\\ a_2\\ a_3 \end{bmatrix}=a_1e_1+a_2e_2+a_3e_3.\\ &(a_1,a_2,a_3)^T为\textbf{a}在基下的坐标 \end{align}外积将叉乘转化为矩阵和向量相乘的线性运算 \begin{align} a\times b& = \begin{Vmatrix} e_1 & e_2 & e_3\\ a_1 & a_2 & a_3\\ b_1 & b_2 & b_3 \end{Vmatrix}=(a_2b_3-a_3b_2)e_1+(a_3b_1-a_1b_3)e_2+(a_1b_2-b_2a_1)e_3\\ &=e\begin{bmatrix} a_2b_3-a_3b_2\\ a_3b_1-a_1b_3\\ a_1b_2-b_2a_1 \end{bmatrix}\\ &=\begin{bmatrix} 0 & -a_3 & a_2\\ a_3 & 0 & -a_1\\ -a_2 & a_1 & 0 \end{bmatrix}\begin{bmatrix} b_1\\ b_2\\ b_3 \end{bmatrix} \overset{\text{def}}{=}\textbf{a^b} \end{align}符号 ^ ：反对称符号 $\Rightarrow$ a^ ：是反对称矩阵，将一个向量变成矩阵形式 a = $\begin{bmatrix}0 &amp; -a_3 &amp; a_2\a_3 &amp; 0 &amp; -a_1\-a_2 &amp; a_1 &amp; 0\end{bmatrix}$ ，任意向量对应唯一一个反对称矩阵. 欧式变换刚体运动：一个旋转+一个平移（坐标系变换 旋转向量本身不变但是坐标系变动，向量a在由基e转变为基e’后，再基e’中表示为a’ \begin{align} &[e_1,e_2,e_3]\begin{bmatrix} a_1\\ a_2\\ a_3 \end{bmatrix}=[{e}'_1,{e}'_2,{e}'_3]\begin{bmatrix} {a}'_1\\ {a}'_2\\ {a}'_3 \end{bmatrix}\\ &等式两边同时左乘[e_1^T,e_2^T,e_3^T]^T，设\:R\:为旋转矩阵：\\ &\begin{bmatrix} a_1\\ a_2\\ a_3 \end{bmatrix}=\begin{bmatrix} e^T_1{e}'_1 & e^T_1{e}'_2 & e^T_1{e}'_3\\ e^T_2{e}'_1 & e^T_2{e}'_2 & e^T_2{e}'_3\\ e^T_3{e}'_1 & e^T_3{e}'_2 & e^T_3{e}'_3 \end{bmatrix}\begin{bmatrix} {a}'_1\\ {a}'_2\\ {a}'_3 \end{bmatrix}\overset{\text{def}}{=}R{a}' \end{align}旋转矩阵 R（方向余弦矩阵）行列式为1，行列式为1的正交矩阵也是一个旋转矩阵。因为行列式为1的正交矩阵的几何意义为旋转但不改变向量长度。 由此，定义n维旋转矩阵： \begin{align}\textbf{特殊正交群}:\\ &SO(n)=\{R\in\mathbb{R}^{n\times n}|RR^T=I,det(R)=1\}. \end{align}其中，I为单位矩阵 关于${a}’=R^{-1}a=R^Ta$ ，同样地，正交矩阵R的逆矩阵在几何上表示一个相反的旋转，因此R的转置刻画了一个相反的旋转。 旋转 + 平移刚体运动（由向量a变换到向量a’），旋转Ra和平移向量t \textbf{a'=Ra+t}变换矩阵1）前置问题： 假设进行多次欧式变换，表达式之间的关系并非是线性关系（带有多项式项），所以为方便描述，设置变换矩阵（T矩阵） 2）定义形式 将三维坐标写成齐次坐标： \begin{align}&\begin{bmatrix} {a}'\\ 1 \end{bmatrix}=\begin{bmatrix} R & t\\ 0^T & 1 \end{bmatrix}\begin{bmatrix} a\\ 1 \end{bmatrix}\overset{\text{def}}{=}T\begin{bmatrix} a\\ 1 \end{bmatrix}\\&\\&矩阵\:T\:为变换矩阵 \end{align}由此，多次变换可以写为如下形式： c=T_1T_2a3）特殊欧式群 SE(3)=\begin{Bmatrix} T=\begin{bmatrix} R & t\\ 0^T & 1 \end{bmatrix}\in \mathbb{R}^{4\times4}|R \in SO(3),t\in\mathbb{R}^{3} \end{Bmatrix}反向变换： T^{-1}=\begin{bmatrix} R^T & -R^Tt\\ 0^T & 1 \end{bmatrix}（可由$A^*=A|A|$求得） [ 注 ]1）SO(3) 的旋转矩阵有9个量，但一次旋转只有3个自由度： ​ 矩阵由九个元素，却只表示了 x，y，z 三个坐标的位置变化（只有三个自由度） 2）变换矩阵T用16个量（4阶T矩阵16个元素）表达了6自由度的变换，分别是三个坐标轴以及每个坐标轴的旋转变量（3个）]]></content>
      <categories>
        <category>SLAM</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CMake 学习笔记]]></title>
    <url>%2F2019%2F09%2F10%2FCMake-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[基本使用1）初始文件：hello.c，CMakeList.txt 2）CMakeList.txt 12345678# CMake最低版本要求cmake_minimum_required(VERSION 2.8)# 工程名project(HelloProject)# 最终要生成的elf文件名为hello，源文件为：hello.cadd_executable(hello hello.c) 3）cmake编译 1cmake . 得到：CMakeFiles文件夹，CMakeCache.txt，cmake_install.cmake，Makefile 1make 得到目标文件 hello 同目录多源文件编译添加文件 test.c ，test.h ，test.h中的方法是对test.c中的函数方法的声明，hello.c引入test.h头文件，并调用头文件中的方法。 则，调整 CMakeList.txt 文件： 12# 在参数表中增加testFunc.cadd_executable(hello hello.c testFunc.c) 当需要编译的文件很多时，使用命令 aux_source_directory(&lt; dir &gt; &lt; variable &gt;) 将指定目录下所有源文件存储到一个变量中进行操作，可以避免大量手动罗列 1234# 将当前所在目录下的所有源文件 . ，添加到 变量SRC_LIST中aux_source_directory(. SRC_LIST)# 调用变量SRC_LIST，语法类似Makefileadd_executable(hello $&#123;SRC_LIST&#125;) 不同目录多源文件编译要编译的文件在不同目录下时，使用命令 include_directories([AFTER|BEFORE] [SYSTEM] dir1 [dir2 ...]) 向工程添加多个指定头文件的搜索路径 12345678# 将头文件包含进工程# 等价于包含头文件 include "xx.h"include_directories (test_func test_func1)# 添加源文件到变量中aux_source_directory (test_func SRC_LIST)aux_source_directory (test_func1 SRC_LIST1)# 添加构成执行文件的所有文件add_executable (hello hello.c $&#123;SRC_LIST&#125; $&#123;SRC_LIST1&#125;) 工程目录编译include目录中是所有的.h头文件，src目录中是所有的.c源文件，build文件夹时编译文件夹 [ ] 使用命令 add_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL]) 来增加一个子目录进行编译，该文件夹下的CMakeLists.txt 负责编译该文件夹下的源码。source_dir选项指定了CMakeLists.txt源文件和代码文件的位置，binary_dir选项指定了输出文件的路径 12# 在build目录下增加src子目录进行编译，src中的CMakeLists.txt编译src中的源文件add_subdirectory (src) 在src目录下CMakeLists.txt中： 12345aux_source_directory (. SRC_LIST)include_directories (../include)add_executable (hello $&#123;SRC_LIST&#125;)# 位置变量 EXECUTABLE_OUTPUT_PATH 设置为 PROJECT_SOURCE_DIR/bin（工程根目录下的bin目录） set (EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/bin) 在build目录下 cmake 函数find_package()​ 在一些目录中查找（按照CMake规则）文件，例如OpenCV，将找到的头文件目录设置到变量${OpenCV_INCLUDE_DIES}中，将链接库设置到 ${OpenCV_LIBS}中 ​ 查找方式：模块模式 / 配置模式 1. 模块模式：查找Find&lt;package&gt;.cmake文件（由CMAKE_MODULE_PATH 指定） 2. 配置模式：查找一个由待查找的包提供的配置文件的位置。包含该文件的路径被存储到 &lt;package&gt;_DIR的cache的条目里。 不管哪一种模式，只要找到包，就会定义变量 _ FOUND INCLUDE DIRS 或者 _ INCLUDES LIBRARIES 或者 LIBS _ DEFINITIONS ​ find_package() + add_library() 得到库文件的绝对路径 link_directories()​ 指定第三方库所在路径，使得cmake搜索到动态库 target_link_libraries()​ 将目标文件与库文件进行连接 find_path() / find_library()​ 寻找头文件和库文件 CMake预定义的变量CMAKE_CURRENT_SOURCE_DIR当前处理的CMakeLists.txt所在的目录 CMAKE_CURRENT_LIST_DIR当前正在处理的列表文件的目录]]></content>
      <tags>
        <tag>CMake</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VSLAM-2 SLAM概览]]></title>
    <url>%2F2019%2F09%2F10%2FVSLAM-2%20SLAM%E6%A6%82%E8%A7%88%2F</url>
    <content type="text"><![CDATA[尺度（Scale）：单目SLAM估计的轨迹和地图相比真实的相差一个因子 基线（Baseline）：组成双目相机的两个单目相机之间的已知距离 视觉SLAM流程： ​ 1）传感器信息读取 ​ 2）前段视觉里程计：估算相邻图像间相机的运动，以及局部地图的样子 ​ 3）后端（非线性）优化：优化前段输出和回环检测信息 ​ 4）回环检测 ​ 5）建图 视觉里程计： 度量地图（稀疏地图，稠密地图 拓扑地图（连通性 SLAM问题的数学表达： ​ 1）运动：k-1 =&gt; k时刻，位置x 的变化： ​ 运动方程： \begin{align} & x_k=f(x_{k-1},u_k,w_k)\\ & u_k:运动传感器的读数或者输入\\ & w_k:该运动过程中加入的噪声\\ & f\:抽象指代运动过程方式 \end{align}​ 2）观测：在k时刻，在 xk 处探测到某一个路标 y_j ，产生观测数据z{k,j} ​ 观测方程： \begin{align} & z_{k,j}=h(y_i,x_k,v_{k,j})\\ & v_{k,j}:这次观测的噪声\\ &观测数据z和观测方程h与运动方程中的x和f一样，有许多种不同的形式 \end{align}运动方程的解释举例： \begin{align} & x_k=\begin{bmatrix} x_1\\ x_2\\ \theta \end{bmatrix}_k \rightarrow x_k：位姿；x_1,x_2:运动机器人两个轴上的位置；\theta为转角\\ &\\& u_k=\begin{bmatrix} \Delta x_1\\ \Delta x_2\\ \Delta\theta \end{bmatrix}_k \rightarrow u_k:输入指令；\Delta x_1,\Delta x_2:两个时间间隔位置变化量；\Delta\theta为转角变化量\\ &\\& \Rightarrow\begin{bmatrix} x_1\\ x_2\\ \theta \end{bmatrix}_k=\begin{bmatrix} x_1\\ x_2\\ \theta \end{bmatrix}_{k-1}+\begin{bmatrix} \Delta x_1\\ \Delta x_2\\ \Delta\theta \end{bmatrix}_k+w_k \end{align}观测方程的解释举例： \begin{align} & 机器人携带的二维激光传感器，观测一个2D路标点，可得：\\ &r\rightarrow路标点和机器人本体间的距离\\ &\phi\rightarrow路标点和机器人本体间的夹角\\ &路标点：y_j=\begin{bmatrix} y_1\\ y_2 \end{bmatrix}_j ,位姿：x_k=\begin{bmatrix} x_1\\ x_2 \end{bmatrix}_k,观测数据：z_{k,j}=\begin{bmatrix} r_{k,j}\\ \phi_{k,j} \end{bmatrix},\\&\\ &观测方程\Rightarrow\begin{bmatrix} r_{k,j}\\ \phi_{k,j} \end{bmatrix}=\begin{bmatrix} \sqrt{(y_{1,j}-x_{1,j})^2+(y_{2,j}-x_{2,j})^2}\\ arctan(\frac{y_{2,j}-x_{2,k}}{y_{1,j}-x_{1,k}}) \end{bmatrix}+v \end{align}所以SLAM过程总结为两个基本方程： \begin{align} &\left\{\begin{matrix} x_k=f(x_{k-1},u_k,w_k),\;k=1,...,K\\ z_{k,j}=h(y_i,x_k,v_{k,j}),\;(k,j)\in O \end{matrix}\right.\\ &已知运动测量读数u，传感器读数z，求解定位问题（估计x）和建图问题（估计y）\\ &\Rightarrow建模为一个\textbf{状态估计问题}:如何通过带有噪声的测量数据，估计内部的隐藏着的状态变量？ \end{align}『声波、温度……』]]></content>
      <categories>
        <category>SLAM</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Makefile 学习笔记]]></title>
    <url>%2F2019%2F09%2F08%2FMakefile-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[格式 表明输出的目标，输出目标的依赖对象和生成目标需要执行的命令 目标 ： 前提依赖 『TAB』执行命令 组成 显式规则 隐式规则 ​ make推导出的规则 变量定义 文件指示 注释 执行读取makefile文件 读入关联文件 初始化变量 递归式执行（执行依赖链上的目标 显式规则依赖关系发生依赖关系，执行命令 伪目标使用.PHONY来标识，可以避免和工作目录下的实际文件名发生冲突 123.PHONYclean: rm -f *.c 隐含规则通配符 12%.o : %.c $(CC) -c %.c -o %.o 文件目录在链接不同目录下的文件时，需要告知make寻找路径： 使用VPATYH变量12# make依次按序搜索文件VPATH = /src : ../inc #不同目录中间用冒号分隔 使用vpath关键字12345678# 使用 % 来指定特定文件# 1 寻找指定目录下的特定文件vpath %.c dir1 # 寻找dir1下的.c文件# 2 清除符合特定文件的搜索目录vapth %.c# 3 清除所有（由vpath命令）已被设置好的文件搜索目录vpath 变量变量声明与使用在变量声明时，需要对变量进行赋值；在使用时需要使用$(VARNAME)的形式 123var = a.c b.ctarget : $(var) # command 变量中的变量 = 替换 := 恒等与（常量），按序声明 ?= 定义未定义过的变量 += 给一个变量追加一个值 自动化变量 $@ 目标文件 $&lt; 第一个依赖文件 $% $? $^ 所有的依赖文件 $+ $* 文件指示函数]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Makefile</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VSLAM-1 初识SALM]]></title>
    <url>%2F2019%2F09%2F07%2FVSLAM-1%20%E5%88%9D%E8%AF%86SLAM%2F</url>
    <content type="text"><![CDATA[[1] Ax = b1）矩阵相乘关系 m*n·n*s = m*s2）讨论齐次方程组『Ax = 0』的解 \begin{align}定义：& \eta_1,\eta_2,...\eta_t是方程 Ax = 0 的解，如果\\（1）& \eta_1,\eta_2,...\eta_t线性无关；\\（2）&方程 Ax = 0 的任一解都可由\eta_1,\eta_2,...\eta_t线性表示，\\那么&\eta_1,\eta_2,...\eta_t叫做方程Ax=0的一个基础解系。\end{align} \Rightarrow可得通解：x = k_1\eta_1+k_2\eta_2+...k_t\eta_t​ ​ 非其次方程有解的充要条件是 系数矩阵（A）与增广矩阵（在A的右侧加一列b）的秩r相等。当r=A的未知数个数n，方程组有一解，当r&lt;n时，有无穷多解 3）非其次方程组的解的结构 ​ Ax=b若有解，则解x为他的一个解与导出组(Ax=0)解之和 即 x = k_1\xi_1+k_2\xi_2+...k_{n-r}\xi_{n-r}+\eta^*4）所以要求Ax=b的解，首先A和b要满足系数矩阵和增广矩阵的秩要相等（有解条件），再通过初等变换（高斯消元）来求解其次方程的解，再求得非其次的一个特解（代入基） [2] 高斯分布 \frac{1}{ \sqrt{2\pi}\sigma}{e}^{-\frac{(x-\mu)^2 }{2\sigma^2} }μ为均值，σ为方差 1 当μ=0，σ=1时，为标准高斯分布 2 当μ改变，σ不变时，分布图像平移 3 当μ不变，σ改变时，分布图像随σ增大而变扁 μ决定对称轴，σ决定扩散程度 https://www.cnblogs.com/lvchaoshun/p/7115460.html ​ 1）最大似然估计 ​ 似然函数：关于统计模型参数的函数，给定模型参数的情况下观测值出现的概率。定义为条件概率： p(\{x_i\}|\mu,\sigma)​ 最大似然估计是利用已知的样本结果，在使用某个模型的基础上，反推有可能导致这样结果的模型参数值 \begin{align} & \Rightarrow 给定观测值\{x_i\}，求\mu和\sigma，是的似然函数最大\\ & \Rightarrow p({\{x_i\} }|\mu,\sigma)=\prod_1^Np({x_i}|\mu,\sigma)\\ & \Rightarrow \hat{\mu},\hat{\sigma}=arg\: max\prod_1^Np({x_i}|\mu,\sigma)\\ 求得：&\hat{\mu}=\frac{1}{N}\sum_{i=1}^Nx_i\\ &\hat{\sigma}=\frac{1}{N}\sum_{i=1}^N(x_i-\hat{\mu})^2 \end{align}​ 即求得一元高斯分布 ​ 2）多元高斯分布 ​ 标准的二元高斯分布： \begin{align}& D=2\\&x=\begin{bmatrix}x & y\end{bmatrix}^T\\&\mu=\begin{bmatrix}0 & 0\end{bmatrix}^T\\&\Sigma=\begin{bmatrix}1 & 0\\ 0 & 1\end{bmatrix}\end{align}​ 三元高斯分布： \begin{align} & D = 3 \\ & x = [x_R\;x_G\;x_B]\\ & \mu = [\mu_R\;\mu_G\;\mu_B]\\ &\Sigma=\begin{bmatrix} \sigma_{x_R}^2 & \sigma_{x_R}\sigma_{x_G} & \sigma_{x_R}\sigma_{x_B}\\ \sigma_{x_R}\sigma_{x_G} & \sigma_{x_G}^2 & \sigma_{x_G}\sigma_{x_B}\\ \sigma_{x_R}\sigma_{x_B} & \sigma_{x_G}\sigma_{x_B} & \sigma_{x_B}^2 \end{bmatrix} \end{align}[3] STL标准模板库[4][5] C++11关键字和新的for循环语法，新的STL容器，多线程，智能指针内存管理 [6][7] 在 Linux 或 Unix 操作系统中，所有的文件和目录都被组织成以一个根节点开始的倒置的树状结构。 ​ /bin命令，/boot启动时的核心文件，/etc系统配置文件，/home用户主目录，/usr应用程序和文件 类似于program files ​ 当前目录：. 上级目录：.. [8] 安装方式​ 1）deb包安装：下载deb格式的软件后，sudo dpkg -i [name].deb ​ 2） tar.gz软件编译安装：解压后，./configure，make，sudo make install ​ 3） apt-get 安装：sudo apt-get install [software-name] ​ 4）脚本安装：例如./clion.sh [9]]]></content>
      <categories>
        <category>SLAM</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令总结]]></title>
    <url>%2F2019%2F09%2F01%2FGit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Commit创建一个提交：1git commit Branch Git分支是指向某个提交记录，不会造成内存上的开销，按逻辑分解工作到不同的分支，星号（ * ）标识表示当前所在分支 创建分支： 1git branch newbranch 切换分支：（从master分支切换到newbranch分支） 1git checkout newbranch 简洁方式： 创建一个分支并且切换到新的分支上 1git checkout -b &lt;branch_name&gt; 1cpp git branch xx master^^2^ Merge 将两个或两个以上的开发历史合并到一起 1git pull = git fetch + git merge Merge模拟： 12345git checkout -b newbranchgit commit -m &quot;newbranch提交&quot;git checkout mastergit commit -m “master提交”git merge newbranch //将newbranch合并到master Rebase 1 合并多个commit为一个完整commit 2 将某一段commit粘贴到另一个分支上 将newbranch分支的工作移到master分支上，实现并行开发：123456git checkout -b newbranchgit commit -m &quot;newbranch更新&quot;git checkout mastergit commit -m &quot;master更新&quot;git checkout newbranchgit rebase newbranch HEAD HEAD 是一个对当前检出记录的符号引用 —— 也就是指向你正在其基础上进行工作的提交记录，常情况下指向分支名 C0 → C1（ master* ）：HEAD → master → C1 然后执行1git checkout C1，变成 HEAD → C1 分离出HEAD并使其指向一个提交记录1git checkout &lt;hash-value&gt; 相对引用（ ^/~ ） 使用 ^ 向上移动 1 个提交记录 使用 ~&lt;num&gt; 向上移动多个提交记录，如 ~3 1git checkout xxx^ 1cpp git checkout xxx~3 强制修改分支位置： 1git branch -f master HEAD^ 将master分支强制移动到HEAD的上一个分支 撤销变更 git reset git reset 向上移动分支，原来指向的提交记录就跟从来没有提交过一样 对共享远程分支无效 1git reset HEAD~1 git revert 撤销更改并支持分享给别人 1git revert HEAD 创建一个新的提交，该提交与HEAD的前一条提交相同 自由修改提交树 git Cherry-pick （知道提交的哈希值 git cherry-pick &lt;提交号&gt;… 将一些提交复制到当前所在的位置（HEAD）下面 12git cherry-pick C3 C4 C5 交互式rebase 参数 —interactive ，简写为 -i 12git rebase -i HEAD~3 调整提交记录的顺序 删除提交 合并提交 标签 可以永久将某个特定的提交命名为里程碑，不会随着新的提交而移动，它表示了某个特定位置 1git tag version1 C1 锚点 描述最近的标签，1git describe &lt;ref&gt;，得到例ref最近的标签、二者间相差多少个提交记录 远程仓库Clone 在本地创建一个远程仓库的拷贝 远程分支 反映了远程仓库的状态，在检出时自动进入分离 HEAD 状态。 远程分支命名规范： [remote name] / [branch name] 例如：origin/master，分支为 master ，远程仓库为 origin 在使用 git clone 时，git将远程仓库命名为 origin（默认命名） 1git checkout origin/master（head分离） Fetch 从远程仓库下载本地仓库缺失的提交记录 更新远程分支指针 （实际上将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态） （为下载操作，不改变本地仓库状态） Pull 从远程仓库获取更新并合并到本地的分支当中 Pushgit push将变更上传到远程仓库，并在其上合并提交记录 偏离的提交历史对于提交已更新的旧版本的更改，需要先合并新版本在提交更改 git commit//对于旧版本的更改 git pull --rebase//合并新版本并提交更改 git push//提交到远程分支]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[19-07-08]]></title>
    <url>%2F2019%2F07%2F10%2F19-07-08%2F</url>
    <content type="text"><![CDATA[Enter password to read. Incorrect Password! No content to display! U2FsdGVkX19UxrWtpuur71MVvgLdBGNlroKpHeyS4EMmsOFw8y8iz+ir36HwEuaye0ALk9k46lHCuONhgaOd3g==]]></content>
  </entry>
  <entry>
    <title><![CDATA[测试]]></title>
    <url>%2F2019%2F06%2F23%2F%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[Hello WorldTestWelcome测试quote test … Testtest Every interaction is both precious and an opportunity to delight. Seth GodinWelcome 1alert('Hello World!');]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F06%2F22%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
