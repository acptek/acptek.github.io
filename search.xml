<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[视觉Slam十四讲 学习笔笔记1]]></title>
    <url>%2F2019%2F09%2F07%2F%E8%A7%86%E8%A7%89Slam%E5%8D%81%E5%9B%9B%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[[1] Ax = b1）矩阵相乘关系$$mn·ns = m*s$$2）讨论齐次方程组『Ax = 0』的解$$\begin{align}定义：&amp; \eta_1,\eta_2,…\eta_t是方程 Ax = 0 的解，如果\（1）&amp; \eta_1,\eta_2,…\eta_t线性无关；\（2）&amp;方程 Ax = 0 的任一解都可由\eta_1,\eta_2,…\eta_t线性表示，\那么&amp;\eta_1,\eta_2,…\eta_t叫做方程Ax=0的一个基础解系。\end{align}$$ $$\Rightarrow可得通解：x = k_1\eta_1+k_2\eta_2+…k_t\eta_t$$ ​ ​ 非其次方程有解的充要条件是 系数矩阵（A）与增广矩阵（在A的右侧加一列b）的秩r相等。当r=A的未知数个数n，方程组有一解，当r&lt;n时，有无穷多解 3）非其次方程组的解的结构 ​ Ax=b若有解，则解x为他的一个解与导出组(Ax=0)解之和 即 $$x = k_1\xi_1+k_2\xi_2+…k_{n-r}\xi_{n-r}+\eta^* $$4）所以要求Ax=b的解，首先A和b要满足系数矩阵和增广矩阵的秩要相等（有解条件），再通过初等变换（高斯消元）来求解其次方程的解，再求得非其次的一个特解（代入基） [2] 高斯分布$$\frac{1}{ \sqrt{2\pi}\sigma}{e}^{-\frac{(x-\mu)^2 }{2\sigma^2} }$$μ为均值，σ为方差 1 当μ=0，σ=1时，为标准高斯分布 2 当μ改变，σ不变时，分布图像平移 3 当μ不变，σ改变时，分布图像随σ增大而变扁 μ决定对称轴，σ决定扩散程度 https://www.cnblogs.com/lvchaoshun/p/7115460.html ​ 1）最大似然估计 ​ 似然函数：关于统计模型参数的函数，给定模型参数的情况下观测值出现的概率。定义为条件概率：$$p({x_i}|\mu,\sigma)$$​ 最大似然估计是利用已知的样本结果，在使用某个模型的基础上，反推有可能导致这样结果的模型参数值 $$ \begin{align} & \Rightarrow 给定观测值\{x_i\}，求\mu和\sigma，是的似然函数最大\\ & \Rightarrow p({\{x_i\} }|\mu,\sigma)=\prod_1^Np({x_i}|\mu,\sigma)\\ & \Rightarrow \hat{\mu},\hat{\sigma}=arg\: max\prod_1^Np({x_i}|\mu,\sigma)\\ 求得：&\hat{\mu}=\frac{1}{N}\sum_{i=1}^Nx_i\\ &\hat{\sigma}=\frac{1}{N}\sum_{i=1}^N(x_i-\hat{\mu})^2 \end{align} $$ ​ 即求得一元高斯分布 ​ 2）多元高斯分布 ​ 标准的二元高斯分布：$$\begin{align}&amp; D=2\&amp;x=\begin{bmatrix}x &amp; y\end{bmatrix}^T\&amp;\mu=\begin{bmatrix}0 &amp; 0\end{bmatrix}^T\&amp;\Sigma=\begin{bmatrix}1 &amp; 0\ 0 &amp; 1\end{bmatrix}\end{align}$$​ 三元高斯分布：$$\begin{align}&amp; D = 3 \&amp; x = [x_R;x_G;x_B]\&amp; \mu = [\mu_R;\mu_G;\mu_B]\&amp;\Sigma=\begin{bmatrix}\sigma_{x_R}^2 &amp; \sigma_{x_R}\sigma_{x_G} &amp; \sigma_{x_R}\sigma_{x_B}\\sigma_{x_R}\sigma_{x_G} &amp; \sigma_{x_G}^2 &amp; \sigma_{x_G}\sigma_{x_B}\\sigma_{x_R}\sigma_{x_B} &amp; \sigma_{x_G}\sigma_{x_B} &amp; \sigma_{x_B}^2\end{bmatrix}\end{align}$$ [3] STL标准模板库[4][5] C++11关键字和新的for循环语法，新的STL容器，多线程，智能指针内存管理 [6][7] 在 Linux 或 Unix 操作系统中，所有的文件和目录都被组织成以一个根节点开始的倒置的树状结构。 ​ /bin命令，/boot启动时的核心文件，/etc系统配置文件，/home用户主目录，/usr应用程序和文件 类似于program files ​ 当前目录：. 上级目录：.. [8] 安装方式​ 1）deb包安装：下载deb格式的软件后，sudo dpkg -i [name].deb ​ 2） tar.gz软件编译安装：解压后，./configure，make，sudo make install ​ 3） apt-get 安装：sudo apt-get install [software-name] ​ 4）脚本安装：例如./clion.sh [9]]]></content>
      <tags>
        <tag>SLAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令总结]]></title>
    <url>%2F2019%2F09%2F01%2FGit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Commit创建一个提交： 1git commit Branch Git分支是指向某个提交记录，不会造成内存上的开销，按逻辑分解工作到不同的分支，星号（ * ）标识表示当前所在分支 创建分支： 1git branch newbranch 切换分支：（从master分支切换到newbranch分支） 1git checkout newbranch 简洁方式： 创建一个分支并且切换到新的分支上 1git checkout -b &lt;branch_name&gt; 1cpp git branch xx master^^2^ Merge 将两个或两个以上的开发历史合并到一起 1git pull = git fetch + git merge Merge模拟： 12345git checkout -b newbranchgit commit -m &quot;newbranch提交&quot;git checkout mastergit commit -m “master提交”git merge newbranch //将newbranch合并到master Rebase 1 合并多个commit为一个完整commit 2 将某一段commit粘贴到另一个分支上 将newbranch分支的工作移到master分支上，实现并行开发：123456git checkout -b newbranchgit commit -m &quot;newbranch更新&quot;git checkout mastergit commit -m &quot;master更新&quot;git checkout newbranchgit rebase newbranch HEAD HEAD 是一个对当前检出记录的符号引用 —— 也就是指向你正在其基础上进行工作的提交记录，常情况下指向分支名 C0 → C1（ master* ）：HEAD → master → C1 然后执行 1git checkout C1，变成 HEAD → C1 分离出HEAD并使其指向一个提交记录1git checkout &lt;hash-value&gt; 相对引用（ ^/~ ） 使用 ^ 向上移动 1 个提交记录 使用 ~&lt;num&gt; 向上移动多个提交记录，如 ~3 1git checkout xxx^ 1cpp git checkout xxx~3 强制修改分支位置： 1git branch -f master HEAD^ 将master分支强制移动到HEAD的上一个分支 撤销变更 git reset git reset 向上移动分支，原来指向的提交记录就跟从来没有提交过一样 对共享远程分支无效 1git reset HEAD~1 git revert 撤销更改并支持分享给别人 1git revert HEAD 创建一个新的提交，该提交与HEAD的前一条提交相同 自由修改提交树 git Cherry-pick （知道提交的哈希值 git cherry-pick &lt;提交号&gt;… 将一些提交复制到当前所在的位置（HEAD）下面 12git cherry-pick C3 C4 C5 交互式rebase 参数 –interactive ，简写为 -i 12git rebase -i HEAD~3 调整提交记录的顺序 删除提交 合并提交 标签 可以永久将某个特定的提交命名为里程碑，不会随着新的提交而移动，它表示了某个特定位置 1git tag version1 C1 锚点 描述最近的标签， 1git describe &lt;ref&gt;，得到例ref最近的标签、二者间相差多少个提交记录 远程仓库Clone 在本地创建一个远程仓库的拷贝 远程分支 反映了远程仓库的状态，在检出时自动进入分离 HEAD 状态。 远程分支命名规范： [remote name] / [branch name] 例如：origin/master，分支为 master ，远程仓库为 origin 在使用 git clone 时，git将远程仓库命名为 origin（默认命名） 1git checkout origin/master（head分离） Fetch 从远程仓库下载本地仓库缺失的提交记录 更新远程分支指针 （实际上将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态） （为下载操作，不改变本地仓库状态） Pull 从远程仓库获取更新并合并到本地的分支当中 Pushgit push将变更上传到远程仓库，并在其上合并提交记录 偏离的提交历史对于提交已更新的旧版本的更改，需要先合并新版本在提交更改 git commit//对于旧版本的更改 git pull --rebase//合并新版本并提交更改 git push//提交到远程分支]]></content>
  </entry>
  <entry>
    <title><![CDATA[19-07-08]]></title>
    <url>%2F2019%2F07%2F10%2F19-07-08%2F</url>
    <content type="text"><![CDATA[Enter password to read. Incorrect Password! No content to display! U2FsdGVkX18/DfG6QAev3ntRWRgUmgJLHwGsbc+i9nwRi2yY9RdhXm/enOyZ1z9+3dUWILN8Evy0uqeZLi4TlA==]]></content>
  </entry>
  <entry>
    <title><![CDATA[测试]]></title>
    <url>%2F2019%2F06%2F23%2F%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[Hello WorldTestWelcome测试quote test … Testtest Every interaction is both precious and an opportunity to delight. Seth GodinWelcome 1alert('Hello World!');]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F06%2F22%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
