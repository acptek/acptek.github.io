<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[相机标定]]></title>
    <url>%2F2019%2F10%2F04%2F%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[坐标系 世界坐标系 $(x_w,y_w,z_w)$ 相机坐标系 $(x_c,y_c,z_c)$ 图像坐标系 $(x,y)$ $x_p=f\frac{x_c}{z_c},y_p=f\frac{y_c}{z_c}$ 像素坐标系 $(u,v)$ $u=\frac{x_c}{d_x}+u_0,v=\frac{y_c}{d_y}+v_0$ 坐标系转换 1 世界坐标系到相机坐标系（旋转矩阵） 2 相机坐标系到图像坐标系（透视投影矩阵 3X4矩阵） 3 图像坐标系到像素坐标系（K 内参矩阵） $K=\begin{bmatrix}f_x &amp; 0 &amp; u_0\0 &amp; f_y &amp; v_0\0 &amp; 0 &amp; 1\end{bmatrix}$，$f_x=\frac{f}{d_x},f_y=\frac{f}{d_y}$ $Z P_{uv}=Z\begin{bmatrix}u\v\1\end{bmatrix}=K(RP_w+t)=KTP_w$ 张正友标定法在不考虑透镜畸变情况下求解内参和外参相机内参：$fx,f_y,u_0,v_0(,r=K{12})$ 相机外参：$T_x,T_y,T_z,\omega,\delta,\theta$ 单应性矩阵：单应性矩阵用于表示投射图像间的透视变换，变换图像的视图 单应性：从一个平面到另一个平面的投影映射，例如 $\tilde{Q}=\begin{bmatrix}X\Y\Z\1\end{bmatrix}\;\rightarrow\;\tilde{q}=\begin{bmatrix}x\y\1\end{bmatrix}\;\Rightarrow\;\tilde{q}=sH\tilde{Q}$ 定义标定板平面为世界坐标系中 Z=0 的平面 $s\begin{bmatrix}u\v\1\end{bmatrix}=K\begin{bmatrix}R &amp; t\end{bmatrix}\begin{bmatrix}x\y\z\1\end{bmatrix}=K\begin{bmatrix}r_1 &amp; r_2 &amp; r_3 &amp; t\end{bmatrix}\begin{bmatrix}x\y\0\1\end{bmatrix}=K\begin{bmatrix}r_1 &amp; r_2\end{bmatrix}\begin{bmatrix}x\y\1\end{bmatrix}$ 其中，$s$为尺度因数（使得单应性定义到该尺度的比例），$H=K\begin{bmatrix}r_1 &amp; r_2 &amp; t\end{bmatrix}$为成像平面和标定平面之间的单应矩阵（由变换和相机内参两部分组成，$r_1,r_2,t$ 分别为旋转矩阵的前两个列向量和平移向量），$\begin{bmatrix}R&amp;t\end{bmatrix}$是一个3X4的矩阵（前3X3是旋转矩阵，后3X1是一个平移向量t） 图像平面(src)的点集与目标平面(dst)上的点集 间的关系（由单应性矩阵确定）： \begin{align} & p_{dst}=Hp_{src} , p_{src}=H^{-1}p_{dst}\\\\ &p_{dst}=\begin{bmatrix}x_{dst}\\y_{dst}\\1\end{bmatrix},p_{src}=\begin{bmatrix}x_{src}\\y_{src}\\1\end{bmatrix} \end{align}记：$H=\begin{bmatrix}h_1&amp;h_2&amp;h_3\end{bmatrix}$ 求内参矩阵由 H=s^{-1}K\begin{bmatrix}r_1 & r_2&t\end{bmatrix}\tag{1} r_1r_2=0\tag{2},|r_i|=1（1）（2）可推导出两等式， \begin{align} &h_1^TK^{-T}K^{-1}h_2=0\\ &h_1^TK^{-T}K^{-1}h_1=h_2^TK^{-T}K^{-1}h_2 \end{align}通过两张不同位置的图片，可以标定后求解出相机内参矩阵K（四个未知数四个方程） 求外参矩阵在求得内参矩阵后，则可以估算外参矩阵： \begin{align} &H=s^{-1}K\begin{bmatrix}r_1 & r_2&t\end{bmatrix}\\ \Rightarrow&\left\{\begin{matrix} r_1=s^{-1}A^{-1}h_1\\ r_2=s^{-1}A^{-1}h_2\\ r_3=r_1\times r_2\\ t = s^{-1}A^{-1}h_3 \end{matrix}\right.,s^{-1}=\frac{1}{||K^{-1}h_1||}=\frac{1}{||K^{-1}h_2||} \end{align}考虑畸变，求解畸变系数径向畸变处理 参数最优化非线性最小二乘法，极大似然估计 12345// image creatorif(!((i+j)%2)) rectangle(ChessImage, Point(Start.x+i*SingleSize, Start.y+j*SingleSize), Point(Start.x+(i+1)*SingleSize-1, Start.y+(j+1)*SingleSize-1), Scalar(0, 0, 0), -1); 12345// image captureVideoCapture capture;Mat frame;capture.open( [filename] )while(true) capture &gt;&gt; frame 1234// opencv/samples/cpp/calibration.cppcv::findChessboardCorners() //绘制交点cv::calibrationCamera() //校准cv::undistort() //校正畸变 12./imagelist_creator imagelist.yaml [path].jpg./calibration -w=[num] -h=[num] [-op] [-oe] [...] imagelist.yaml 123# out_camera_data.ymlcamera_matrix: //相机内参distortion_coefficients: //畸变系数]]></content>
      <categories>
        <category>CV</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VSLAM-4.2 李代数求导]]></title>
    <url>%2F2019%2F09%2F22%2FVSLAM-4-2-%E6%9D%8E%E4%BB%A3%E6%95%B0%E6%B1%82%E5%AF%BC%2F</url>
    <content type="text"><![CDATA[1） SLAM的过程就是不断的估计相机的位姿和建立地图，在此过程中会出现一定的误差，所以目的是寻找一个最佳位姿（通过优化方法，一般采用迭代优化方法，每次迭代都更新一个位姿的增量delta，使得目标函数最小。这个delta就是通过误差函数对T微分得到的。也就是说我们需要对变换矩阵T求微分），使得整体误差最小。 为此，可以列出关于变换矩阵T的目标函数，要求解方程需要对变换矩阵求导。 2） 就旋转矩阵而言，其矩阵加法不封闭，为此不满足导数定义中“加一个极小量”。所以，要使得矩阵满足求导运算，引出李群和李代数。 李群是具有连续性质的群，群上定义了某种矩阵的集合。对于旋转矩阵、变换矩阵都是满足李群的定义，例如旋转矩阵在旋转矩阵的集合中关于乘法运算满足李群。李群运算不满足求导，但与李群对应的李代数满足加法后保持性质。至此，将变换矩阵求导的问题转化为了求李代数的导数问题。 在讨论李代数的物理意义时，so(3)就代表了旋转向量组成的空间。实际上，so(3)是三维向量phi的集合，每个向量phi^表达了这个李代数对应的李群SO(3)上旋转矩阵R的导数。其中，R与phi是一个指数映射关系。 关于李代数和李群在几何意义上的关系：李代数对应李群的正切空间，描述了李群的局部导数。 李代数求导BCH公式 \ln(\exp(A)\exp(B))=A+B+\frac{1}{2}[A,B]+\frac{1}{12}[A,[A,B]]-\frac{1}{12}[B[A,B]]+...其中“[ , ]”为李括号。 考虑SO(3)上的李代数： \ln(\exp(\phi_1^\wedge)\exp(\phi_2^\wedge))^\vee=\left\{\begin{matrix} {J_l(\phi_2)}^{-1}\phi_1+\phi_2\;\;当\phi_1为小量\\ {J_r(\phi_1)}^{-1}\phi_2+\phi_1\;\;当\phi_2为小量 \end{matrix}\right.\tag{*}第一个近似描述了：对一个旋转矩阵$R2$（李代数$\phi_2$），左乘一个微小旋转$R_1$，近似看作：在李代数$\phi_2$上加了一项${J_l(\phi_2)}^{-1}\phi_1$. J_l=J=\frac{\sin\theta}{\theta}I+(1-\frac{\sin\theta}{\theta})\alpha\alpha^T+\frac{1-\cos\theta}{\theta}\alpha^\wedge\tag{**} J^{-1}=\frac{\theta}{2}\cot\frac{\theta}{2}I+(1-\frac{\theta}{2}\cot\frac{\theta}{2})\alpha\alpha^T-\frac{\theta}{2}\alpha^\wedge\tag{**}右乘：$J_r(\phi)=J_l(-\phi)$ 至此，得到李群乘法和李代数加法的关系 BCH近似$旋转矩阵R，其李代数\phi，微小旋转\Delta R，其李代数\Delta\phi$，李群乘法$\rightarrow$李代数加法 \exp(\Delta\phi^\wedge)\exp(\phi^\wedge)=\exp((\phi+J_l^{-1}(\phi)\Delta\phi)^\wedge)\tag{***}李代数加法$\rightarrow$李群乘法 \exp((\phi+\Delta\phi)^\wedge)=\exp((J_l\Delta\phi)^\wedge)\exp(\phi^\wedge)=\exp(\phi^\wedge)\exp((J_r\Delta\phi)^\wedge)\tag{***}李代数求导两种思路： 1 导数模型 ， 2 扰动模型 SO(3)上的李代数求导$位姿T，观察点的世界坐标p，产生的观测数据z，随即噪声w$，对于N个观测误差$e=z-Tp$，（寻找一个最优T，使误差最小） \underset{T}{\min}J(T)=\sum_{i=1}^N||z_i-Tp_i||_2^2李代数求导1）按照导数模型，（根据李代数的加法结合导数的定义来求旋转后点的坐标对于旋转的导数，或者说是求旋转很小时偏移的变化率），可以求得： \begin{align} & \frac{\partial (\exp(\phi^\wedge)p)}{\partial \phi}\approx-(Rp)^\wedge J_l\\&\\ \Rightarrow &\frac{\partial (Rp)}{\partial \phi}=(-Rp)^\wedge J_l \tag{旋转后的点对于李代数的导数} \end{align}2）扰动模型，对旋转矩阵R进行一次扰动$\Delta R$（对应的李代数为$\varphi $），看结果相对于扰动的变化率。 \frac{\partial (Rp)}{\partial \phi}=(-Rp)^\wedgeSE(3)上的李代数求导空间点p，变换T（对应的李代数为$\xi$），扰动变换$\Delta T=\exp(\delta\xi^\wedge)$，其李代数为$\delta\xi=[\delta\rho,\delta\phi]^T$： \frac{\partial (Tp)}{\partial \delta\xi}=\begin{bmatrix}I & -(Rp+t)^\wedge\\ 0^T & 0^T\end{bmatrix}git]]></content>
      <categories>
        <category>SLAM</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VSLAM-4.1 李群李代数及其转换的映射]]></title>
    <url>%2F2019%2F09%2F21%2FVSLAM-4-1-%E6%9D%8E%E7%BE%A4%E6%9D%8E%E4%BB%A3%E6%95%B0%E5%8F%8A%E5%85%B6%E8%BD%AC%E6%8D%A2%E7%9A%84%E6%98%A0%E5%B0%84%2F</url>
    <content type="text"><![CDATA[李群与李代数（1）群代数结构：一种集合+集合上的一种运算 满足性质：封闭性、结合率、幺元、逆 李群：具有连续（光滑）性质的群 （2）李代数与李群对应的一种数据结构 引出李代数旋转矩阵$R$是某个相机的旋转，并随时间连续地变化 \begin{align} & R(t)R(t)^T=I\tag{两边对t求导} \\ \Rightarrow\;& \dot{R}(t)R(t)^T+R(t)\dot{R}(t)^T=0\\ \Rightarrow\;& \dot{R}(t)R(t)^T = -(\dot{R}(t)R(t)^T)^T\\&\\ \rightarrow\;&\dot{R}(t)R(t)^T是一个反对称矩阵 \end{align}所以，找到一个三维向量$\phi(t)\in\mathbb{R^3}$记： \begin{align} & \phi(t)\text{^}=\dot{R}(t)R(t)^T \tag{1}\\&\\ \Rightarrow\;&\dot{R}(t)=\phi(t)\text{^}R(t)\tag{2} \end{align}考虑：$t_0=0时，R(0)=I$，在0处泰勒展开： R(t)\approx R(t_0)+\dot{R}(t_0)(t-t_0)=I+\phi(t_0)\text{^}t在$t_0$附近，$\phi(t_0)=\phi_0$为常数，所以得到关于R的微分方程，得： R(t)=e^{\phi\text{^}t} \tag{3}李代数的定义每个李群对应一个李代数。李代数描述了李群的局部性质，是单位元附近的正切空间（tangent Space切线空间，是一种三维空间） 集合$\mathbb{V}$ + 数域$\mathbb{F}$ + 二元运算（李括号）[ , ] = 李代数 \mathfrak{g}=(\mathbb{V},\mathbb{F},[,])性质：封闭性、双线性、自反性（与自身运算结果为零）、雅可比等价 李代数$\mathfrak{so}(3)$定义$\Phi=\phi^\wedge$，得 李括号为： [\phi_1,\phi_2]=(\Phi_1\Phi_2-\Phi_2\Phi_1)^\vee \mathfrak{so}(3)=\begin{Bmatrix} \phi=\mathbb{R^3},\Phi=\phi^\wedge\in\mathbb{R^{3\times3} } \end{Bmatrix}\tag{*}所以，so(3)是一个由三维向量组成的集合，每个向量对应一个反对称矩阵，表达旋转矩阵的导数 对应SO(3)，$ R(t)=e^{\phi\text{^}t} $ SO(3)=\{R\in\mathbb{R}^{3\times 3}|RR^T=I,det(R)=1\}\tag{*}李代数$\mathfrak{se}(3)$ \mathfrak{se}(3)=\begin{Bmatrix} \xi =\begin{bmatrix} \rho \\ \phi \end{bmatrix}\in\mathbb{R}^6,\rho\in\mathbb{R}^3,\phi\in\mathfrak{so}(3),\xi^\wedge =\begin{bmatrix} \phi^\wedge & \rho\\ 0^T & 0 \end{bmatrix}\in\mathbb{R}^{4\times4} \end{Bmatrix}$\mathfrak{se}(3) $：由一个平移+一个$\mathfrak{so}(3)$构成的向量 $\mathfrak{se}(3)$对应的李括号： [\xi_1,\xi_2]=(\xi_1^\wedge\xi_2^\wedge-\xi_2^\wedge\xi_1^\wedge)^\vee指数与对数映射（1）SO(3)上的指数映射1 指数映射：在李群李代数中，一个矩阵的指数 2 通过泰勒展开，得$\mathfrak{so}(3)中的任意元素\phi的指数映射$： \text{exp}(\phi^\wedge)=\sum_{n=0}^\infty \frac{1}{n!}(\phi^\wedge)^n3 关于上述定义的计算： 定义$\phi$的 模长$\theta$，方向$\alpha$，$\phi=\theta\alpha$，其中$||a||=1$ 关于$\alpha$的性质：$\alpha^\wedge\alpha^\wedge=\alpha\alpha^T-I$，$\alpha^\wedge\alpha^\wedge\alpha^\wedge=-\alpha^\wedge$，将$\theta\alpha$代入指数映射： \begin{align} \text{exp}(\phi^\wedge)&=\text{exp}(\theta^\wedge\alpha)\\ &=\cos{\theta I}+(1-\cos\theta)\alpha\alpha^T+\sin\theta\alpha^\wedge \end{align}【注】 罗德里格斯公式：R=cos\theta I+(1-cos\theta )nn^T+sin\theta n\text{^}由此表明，$\mathfrak{so}(3)$实际上就是旋转向量组成的空间（李代数$\rightarrow$李群）其物理意义就是旋转向量，指数映射就是罗德里格斯公式（旋转向量$\rightarrow$旋转矩阵）（旋转矩阵的导数可以由旋转向量指定） 所以 \Rightarrow\;\phi =ln(R)^\vee=(\sum_{n=0}^\infty\frac{(-1)^n}{n+1}(R-I)^{n+1})^\vee但是，可以通过求解转角和转轴，可以更加简便的得到 $\theta$ 和 $\alpha$ \theta=arccos\frac{tr(R)-1}{2},Rn=n综上所述，得到李群SO(3)和李代数so(3)的对应关系，将旋转角控制在$（-\pi,\pi）$之间，二者成一一对应关系 （2）SE(3)上的指数映射 \text{exp}(\xi^\wedge)=\begin{bmatrix} \sum_{n=0}^\infty \frac{1}{n!}(\phi^\wedge)^n & \sum_{n=0}^\infty \frac{1}{()n+1)!}(\phi^\wedge)^n\rho\\ 0^T & 1 \end{bmatrix} \overset{\Delta}{=}\begin{bmatrix} R & J\rho\\ 0^T & 1 \end{bmatrix}=T经求解，得：$J=\frac{\sin\theta}{\theta}I+(1-\frac{\sin\theta}{\theta})\alpha\alpha^T+\frac{1-\cos\theta}{\theta}\alpha^\wedge$（雅可比矩阵） SE(3)右上角的平移向量t，结合$t=J\rho$，$J可由\phi求得$，可以求得 $\rho$ 由此，确定SE(3)和se(3)的转换关系]]></content>
      <categories>
        <category>SLAM</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VSALM-3.2 旋转向量 欧拉角 四元数]]></title>
    <url>%2F2019%2F09%2F17%2FVSALM-3-2-%E6%97%8B%E8%BD%AC%E5%90%91%E9%87%8F-%E6%AC%A7%E6%8B%89%E8%A7%92-%E5%9B%9B%E5%85%83%E6%95%B0%2F</url>
    <content type="text"><![CDATA[旋转向量表现形式旋转向量/轴角：用一个旋转轴和一人个旋转角来刻画任意一个旋转，方向和旋转轴一致，长度等于旋转角 所以，对于变换矩阵T，可以使用一个旋转向量和一个平移变量来表示，总共6个变量 旋转向量转化为旋转矩阵罗德里格斯公式： ​ 长度为$\theta$，轴角为$n$（单位长度的向量），用向量$\theta n$表示旋转。 R=cos\theta I+(1-cos\theta )nn^T+sin\theta n\text{^}​ 根据 迹 的性质，对该公式两边取迹，求得转角和旋转矩阵的关系。 \Rightarrow \theta=arccos\frac{tr(R)-1}{2}转轴转轴$n$上的旋转向量在旋转后不发生改变， Rn=n \;\Leftarrow\left\{\begin{matrix} Rn=\lambda n\\ \lambda = 1 \end{matrix}\right.所以，可以推导出$n$为旋转矩阵$R$特征值为1对应的特征向量。因此，已知旋转矩阵，即可求得旋转轴。 欧拉角将三个轴的旋转方向作定义，更加直观的表示旋转的过程。 但是在使用欧拉角时，会出现“万向锁问题”，例如可能导致三个轴的旋转实际只表示了两次旋转等情况。 四元数定义 \begin{align} & q=[s,v]^T,\;s=q_0 \in \mathbb{R},\;v=[q_1, q_2, q_3]^T \in \mathbb{R} . \\ &q = q_0+q_1i+q_2j+q_3k .\\ & s为实部，v为虚部 \end{align}运算1）自身三个虚部满足的乘法运算关系 2）两四元数加减法 3）两四元数的乘法 \begin{align} & q_a\: [s_a, v_a]^T,\;q_a=s_a+x_ai+y_aj+z_ak\\& q_b\:[s_b,v_b]^T,q_b=s_b+x_bi+y_bj+z_bk\\\rightarrow\\ &q_aq_b=[s_as_b-v_a^Tv_b, s_av_b+s_bv_a+v_a\times v_b]^T \end{align}4）模长 $||q||$ 5）共轭 $q^*$ q^*q=qq^*=[s_a^2+v^Tv, 0]^T.6）逆 $q^{-1}$ \begin{align} &q^{-1}=q^*/||q||^2\\ &q^{-1}q=qq^{-1}=1 \end{align}7）数乘 用四元数表示旋转在二维平面中，旋转数可以写为 $q=cos\theta+i*sin\theta$ 引申到三维旋转中，四元数向量表示为 $q\;[cos\theta, v*sin\theta]$ 三维空间点的旋转空间三维点：$p=[x,y,z]\in \mathbb{R^3}$ 单位四元数：$q$ ,用于指定旋转 1）将三维空间点用虚四元数表示： p=[0, x,y,z]^T=[0,v]^T2）旋转 p'=extend(R)p \Rightarrow p'=qpq^{-1}通过先乘q再作q逆乘法，相当与先用右手坐标系将空间点旋转二分之一的旋转角，再用左手坐标系逆向旋转二分之一旋转角，以此使得最终得到的四元数时纯虚四元数，从而直接表示三维空间坐标。（从几何意义上是将三维向量转化为四维后再回到三维） 四元数到其他旋转表示的转换定义：（将四元数的乘法写成矩阵乘法） q^+=\begin{bmatrix} s & -v^T\\ v & sI+v\text{^} \end{bmatrix},q^\oplus=\begin{bmatrix} s & -v^T\\ v & sI-v\text{^} \end{bmatrix} \Rightarrow q_1q_2=q_1^+q_2=q_2^\oplus q_1 \Rightarrow p'=qpq^{-1}=q^+p^+q^{-1}=q^+{q^{-1}}^\oplus p即$q^+{q^{-1}}^\oplus=extend(R)$，所以 四元数转换到旋转矩阵 q^+{q^{-1}}^\oplus=\begin{bmatrix} s & -v^T\\ v & sI+v\text{^} \end{bmatrix}\begin{bmatrix} s & v^T\\ -v & sI+v\text{^} \end{bmatrix}=\begin{bmatrix} 1 & 0\\ 0^T & vv^T+s^2I+2sv\text{^}+(v\text{^})^2 \end{bmatrix} \Rightarrow R=vv^T+s^2I+2sv\text{^}+(v\text{^})^2 \tag{*}四元数转换到旋转向量对两边取迹，得： tr(R)=4s^2-1其中，关于 $v(v_1,v_2,v_3)$，$v\text{^}$是向量$v$的反对称矩阵形式 tr((v\text{^})^2)=2(v_1^2+v_2^2+v_3^2) \tag{1}又由罗德里斯公式中： \Rightarrow \theta=arccos\frac{tr(R)-1}{2}\tag{2}最终得到四元数与旋转向量的转换关系 \Rightarrow \theta=2\arccos{s}综上，四元数到旋转向量的转换公式： \left\{\begin{matrix}\theta=2\arccos{q_0}\\ [n_x,n_y,n_z]^T=[q_1,q_2,q_3]^T/\sin{\frac{\theta}{2}}\end{matrix}\right. \tag{*}]]></content>
      <categories>
        <category>SLAM</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VSLAM-3.1 旋转矩阵]]></title>
    <url>%2F2019%2F09%2F12%2FVSLAM-3-1%20%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[旋转矩阵点，向量，坐标系$\mathbb{R}^3$$\mathbb{R}^3$描述三维空间中的某个坐标点，$(e_1, e_2, e_3)$：为空间中的一组基 \begin{align} 向量&\textbf{a}在基(e_1,e_2,e_3)下的坐标：\\ & \textbf{a} = [e_1,e_2,e_3]\begin{bmatrix} a_1\\ a_2\\ a_3 \end{bmatrix}=a_1e_1+a_2e_2+a_3e_3.\\ &(a_1,a_2,a_3)^T为\textbf{a}在基下的坐标 \end{align}外积将叉乘转化为矩阵和向量相乘的线性运算 \begin{align} a\times b& = \begin{Vmatrix} e_1 & e_2 & e_3\\ a_1 & a_2 & a_3\\ b_1 & b_2 & b_3 \end{Vmatrix}=(a_2b_3-a_3b_2)e_1+(a_3b_1-a_1b_3)e_2+(a_1b_2-b_2a_1)e_3\\ &=e\begin{bmatrix} a_2b_3-a_3b_2\\ a_3b_1-a_1b_3\\ a_1b_2-b_2a_1 \end{bmatrix}\\ &=\begin{bmatrix} 0 & -a_3 & a_2\\ a_3 & 0 & -a_1\\ -a_2 & a_1 & 0 \end{bmatrix}\begin{bmatrix} b_1\\ b_2\\ b_3 \end{bmatrix} \overset{\text{def}}{=}\textbf{a^b} \end{align}符号 ^ ：反对称符号 $\Rightarrow$ a^ ：是反对称矩阵，将一个向量变成矩阵形式 a = $\begin{bmatrix}0 &amp; -a_3 &amp; a_2\a_3 &amp; 0 &amp; -a_1\-a_2 &amp; a_1 &amp; 0\end{bmatrix}$ ，任意向量对应唯一一个反对称矩阵. 欧式变换刚体运动：一个旋转+一个平移（坐标系变换 旋转向量本身不变但是坐标系变动，向量a在由基e转变为基e’后，再基e’中表示为a’ \begin{align} &[e_1,e_2,e_3]\begin{bmatrix} a_1\\ a_2\\ a_3 \end{bmatrix}=[{e}'_1,{e}'_2,{e}'_3]\begin{bmatrix} {a}'_1\\ {a}'_2\\ {a}'_3 \end{bmatrix}\\ &等式两边同时左乘[e_1^T,e_2^T,e_3^T]^T，设\:R\:为旋转矩阵：\\ &\begin{bmatrix} a_1\\ a_2\\ a_3 \end{bmatrix}=\begin{bmatrix} e^T_1{e}'_1 & e^T_1{e}'_2 & e^T_1{e}'_3\\ e^T_2{e}'_1 & e^T_2{e}'_2 & e^T_2{e}'_3\\ e^T_3{e}'_1 & e^T_3{e}'_2 & e^T_3{e}'_3 \end{bmatrix}\begin{bmatrix} {a}'_1\\ {a}'_2\\ {a}'_3 \end{bmatrix}\overset{\text{def}}{=}R{a}' \end{align}旋转矩阵 R（方向余弦矩阵）行列式为1，行列式为1的正交矩阵也是一个旋转矩阵。因为行列式为1的正交矩阵的几何意义为旋转但不改变向量长度。 由此，定义n维旋转矩阵： \begin{align}\textbf{特殊正交群}:\\ &SO(n)=\{R\in\mathbb{R}^{n\times n}|RR^T=I,det(R)=1\}. \end{align}其中，I为单位矩阵 关于${a}’=R^{-1}a=R^Ta$ ，同样地，正交矩阵R的逆矩阵在几何上表示一个相反的旋转，因此R的转置刻画了一个相反的旋转。 旋转 + 平移刚体运动（由向量a变换到向量a’），旋转Ra和平移向量t \textbf{a'=Ra+t}变换矩阵1）前置问题： 假设进行多次欧式变换，表达式之间的关系并非是线性关系（带有多项式项），所以为方便描述，设置变换矩阵（T矩阵） 2）定义形式 将三维坐标写成齐次坐标： \begin{align}&\begin{bmatrix} {a}'\\ 1 \end{bmatrix}=\begin{bmatrix} R & t\\ 0^T & 1 \end{bmatrix}\begin{bmatrix} a\\ 1 \end{bmatrix}\overset{\text{def}}{=}T\begin{bmatrix} a\\ 1 \end{bmatrix}\\&\\&矩阵\:T\:为变换矩阵 \end{align}由此，多次变换可以写为如下形式： c=T_1T_2a3）特殊欧式群 SE(3)=\begin{Bmatrix} T=\begin{bmatrix} R & t\\ 0^T & 1 \end{bmatrix}\in \mathbb{R}^{4\times4}|R \in SO(3),t\in\mathbb{R}^{3} \end{Bmatrix}反向变换： T^{-1}=\begin{bmatrix} R^T & -R^Tt\\ 0^T & 1 \end{bmatrix}（可由$A^*=A|A|$求得） [ 注 ]1）SO(3) 的旋转矩阵有9个量，但一次旋转只有3个自由度： ​ 矩阵由九个元素，却只表示了 x，y，z 三个坐标的位置变化（只有三个自由度） 2）变换矩阵T用16个量（4阶T矩阵16个元素）表达了6自由度的变换，分别是三个坐标轴以及每个坐标轴的旋转变量（3个）]]></content>
      <categories>
        <category>SLAM</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CMake 学习笔记]]></title>
    <url>%2F2019%2F09%2F10%2FCMake-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[基本使用1）初始文件：hello.c，CMakeList.txt 2）CMakeList.txt 12345678# CMake最低版本要求cmake_minimum_required(VERSION 2.8)# 工程名project(HelloProject)# 最终要生成的elf文件名为hello，源文件为：hello.cadd_executable(hello hello.c) 3）cmake编译 1cmake . 得到：CMakeFiles文件夹，CMakeCache.txt，cmake_install.cmake，Makefile 1make 得到目标文件 hello 同目录多源文件编译添加文件 test.c ，test.h ，test.h中的方法是对test.c中的函数方法的声明，hello.c引入test.h头文件，并调用头文件中的方法。 则，调整 CMakeList.txt 文件： 12# 在参数表中增加testFunc.cadd_executable(hello hello.c testFunc.c) 当需要编译的文件很多时，使用命令 aux_source_directory(&lt; dir &gt; &lt; variable &gt;) 将指定目录下所有源文件存储到一个变量中进行操作，可以避免大量手动罗列 1234# 将当前所在目录下的所有源文件 . ，添加到 变量SRC_LIST中aux_source_directory(. SRC_LIST)# 调用变量SRC_LIST，语法类似Makefileadd_executable(hello $&#123;SRC_LIST&#125;) 不同目录多源文件编译要编译的文件在不同目录下时，使用命令 include_directories([AFTER|BEFORE] [SYSTEM] dir1 [dir2 ...]) 向工程添加多个指定头文件的搜索路径 12345678# 将头文件包含进工程# 等价于包含头文件 include "xx.h"include_directories (test_func test_func1)# 添加源文件到变量中aux_source_directory (test_func SRC_LIST)aux_source_directory (test_func1 SRC_LIST1)# 添加构成执行文件的所有文件add_executable (hello hello.c $&#123;SRC_LIST&#125; $&#123;SRC_LIST1&#125;) 工程目录编译include目录中是所有的.h头文件，src目录中是所有的.c源文件，build文件夹时编译文件夹 [ ] 使用命令 add_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL]) 来增加一个子目录进行编译，该文件夹下的CMakeLists.txt 负责编译该文件夹下的源码。source_dir选项指定了CMakeLists.txt源文件和代码文件的位置，binary_dir选项指定了输出文件的路径 12# 在build目录下增加src子目录进行编译，src中的CMakeLists.txt编译src中的源文件add_subdirectory (src) 在src目录下CMakeLists.txt中： 12345aux_source_directory (. SRC_LIST)include_directories (../include)add_executable (hello $&#123;SRC_LIST&#125;)# 位置变量 EXECUTABLE_OUTPUT_PATH 设置为 PROJECT_SOURCE_DIR/bin（工程根目录下的bin目录） set (EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/bin) 在build目录下 cmake 函数find_package()​ 在一些目录中查找（按照CMake规则）文件，例如OpenCV，将找到的头文件目录设置到变量${OpenCV_INCLUDE_DIES}中，将链接库设置到 ${OpenCV_LIBS}中 ​ find_package() + add_library() 得到库文件的绝对路径 link_directories()​ 指定第三方库所在路径，使得cmake搜索到动态库 target_link_libraries()​ 将目标文件与库文件进行连接 ​]]></content>
      <tags>
        <tag>CMake</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VSLAM-2 SLAM概览]]></title>
    <url>%2F2019%2F09%2F10%2FVSLAM-2%20SLAM%E6%A6%82%E8%A7%88%2F</url>
    <content type="text"><![CDATA[尺度（Scale）：单目SLAM估计的轨迹和地图相比真实的相差一个因子 基线（Baseline）：组成双目相机的两个单目相机之间的已知距离 视觉SLAM流程： ​ 1）传感器信息读取 ​ 2）前段视觉里程计：估算相邻图像间相机的运动，以及局部地图的样子 ​ 3）后端（非线性）优化：优化前段输出和回环检测信息 ​ 4）回环检测 ​ 5）建图 视觉里程计： 度量地图（稀疏地图，稠密地图 拓扑地图（连通性 SLAM问题的数学表达： ​ 1）运动：k-1 =&gt; k时刻，位置x 的变化： ​ 运动方程： \begin{align} & x_k=f(x_{k-1},u_k,w_k)\\ & u_k:运动传感器的读数或者输入\\ & w_k:该运动过程中加入的噪声\\ & f\:抽象指代运动过程方式 \end{align}​ 2）观测：在k时刻，在 xk 处探测到某一个路标 y_j ，产生观测数据z{k,j} ​ 观测方程： \begin{align} & z_{k,j}=h(y_i,x_k,v_{k,j})\\ & v_{k,j}:这次观测的噪声\\ &观测数据z和观测方程h与运动方程中的x和f一样，有许多种不同的形式 \end{align}运动方程的解释举例： \begin{align} & x_k=\begin{bmatrix} x_1\\ x_2\\ \theta \end{bmatrix}_k \rightarrow x_k：位姿；x_1,x_2:运动机器人两个轴上的位置；\theta为转角\\ &\\& u_k=\begin{bmatrix} \Delta x_1\\ \Delta x_2\\ \Delta\theta \end{bmatrix}_k \rightarrow u_k:输入指令；\Delta x_1,\Delta x_2:两个时间间隔位置变化量；\Delta\theta为转角变化量\\ &\\& \Rightarrow\begin{bmatrix} x_1\\ x_2\\ \theta \end{bmatrix}_k=\begin{bmatrix} x_1\\ x_2\\ \theta \end{bmatrix}_{k-1}+\begin{bmatrix} \Delta x_1\\ \Delta x_2\\ \Delta\theta \end{bmatrix}_k+w_k \end{align}观测方程的解释举例： \begin{align} & 机器人携带的二维激光传感器，观测一个2D路标点，可得：\\ &r\rightarrow路标点和机器人本体间的距离\\ &\phi\rightarrow路标点和机器人本体间的夹角\\ &路标点：y_j=\begin{bmatrix} y_1\\ y_2 \end{bmatrix}_j ,位姿：x_k=\begin{bmatrix} x_1\\ x_2 \end{bmatrix}_k,观测数据：z_{k,j}=\begin{bmatrix} r_{k,j}\\ \phi_{k,j} \end{bmatrix},\\&\\ &观测方程\Rightarrow\begin{bmatrix} r_{k,j}\\ \phi_{k,j} \end{bmatrix}=\begin{bmatrix} \sqrt{(y_{1,j}-x_{1,j})^2+(y_{2,j}-x_{2,j})^2}\\ arctan(\frac{y_{2,j}-x_{2,k}}{y_{1,j}-x_{1,k}}) \end{bmatrix}+v \end{align}所以SLAM过程总结为两个基本方程： \begin{align} &\left\{\begin{matrix} x_k=f(x_{k-1},u_k,w_k),\;k=1,...,K\\ z_{k,j}=h(y_i,x_k,v_{k,j}),\;(k,j)\in O \end{matrix}\right.\\ &已知运动测量读数u，传感器读数z，求解定位问题（估计x）和建图问题（估计y）\\ &\Rightarrow建模为一个\textbf{状态估计问题}:如何通过带有噪声的测量数据，估计内部的隐藏着的状态变量？ \end{align}『声波、温度……』]]></content>
      <categories>
        <category>SLAM</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Makefile 学习笔记]]></title>
    <url>%2F2019%2F09%2F08%2FMakefile-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[格式 表明输出的目标，输出目标的依赖对象和生成目标需要执行的命令 目标 ： 前提依赖 『TAB』执行命令 组成 显式规则 隐式规则 ​ make推导出的规则 变量定义 文件指示 注释 执行读取makefile文件 读入关联文件 初始化变量 递归式执行（执行依赖链上的目标 显式规则依赖关系发生依赖关系，执行命令 伪目标使用.PHONY来标识，可以避免和工作目录下的实际文件名发生冲突 123.PHONYclean: rm -f *.c 隐含规则通配符 12%.o : %.c $(CC) -c %.c -o %.o 文件目录在链接不同目录下的文件时，需要告知make寻找路径： 使用VPATYH变量12# make依次按序搜索文件VPATH = /src : ../inc #不同目录中间用冒号分隔 使用vpath关键字12345678# 使用 % 来指定特定文件# 1 寻找指定目录下的特定文件vpath %.c dir1 # 寻找dir1下的.c文件# 2 清除符合特定文件的搜索目录vapth %.c# 3 清除所有（由vpath命令）已被设置好的文件搜索目录vpath 变量变量声明与使用在变量声明时，需要对变量进行赋值；在使用时需要使用$(VARNAME)的形式 123var = a.c b.ctarget : $(var) # command 变量中的变量 = 替换 := 恒等与（常量），按序声明 ?= 定义未定义过的变量 += 给一个变量追加一个值 自动化变量 $@ 目标文件 $&lt; 第一个依赖文件 $% $? $^ 所有的依赖文件 $+ $* 文件指示函数]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Makefile</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VSLAM-1 初识SALM]]></title>
    <url>%2F2019%2F09%2F07%2FVSLAM-1%20%E5%88%9D%E8%AF%86SLAM%2F</url>
    <content type="text"><![CDATA[[1] Ax = b1）矩阵相乘关系 m*n·n*s = m*s2）讨论齐次方程组『Ax = 0』的解 \begin{align}定义：& \eta_1,\eta_2,...\eta_t是方程 Ax = 0 的解，如果\\（1）& \eta_1,\eta_2,...\eta_t线性无关；\\（2）&方程 Ax = 0 的任一解都可由\eta_1,\eta_2,...\eta_t线性表示，\\那么&\eta_1,\eta_2,...\eta_t叫做方程Ax=0的一个基础解系。\end{align} \Rightarrow可得通解：x = k_1\eta_1+k_2\eta_2+...k_t\eta_t​ ​ 非其次方程有解的充要条件是 系数矩阵（A）与增广矩阵（在A的右侧加一列b）的秩r相等。当r=A的未知数个数n，方程组有一解，当r&lt;n时，有无穷多解 3）非其次方程组的解的结构 ​ Ax=b若有解，则解x为他的一个解与导出组(Ax=0)解之和 即 x = k_1\xi_1+k_2\xi_2+...k_{n-r}\xi_{n-r}+\eta^*4）所以要求Ax=b的解，首先A和b要满足系数矩阵和增广矩阵的秩要相等（有解条件），再通过初等变换（高斯消元）来求解其次方程的解，再求得非其次的一个特解（代入基） [2] 高斯分布 \frac{1}{ \sqrt{2\pi}\sigma}{e}^{-\frac{(x-\mu)^2 }{2\sigma^2} }μ为均值，σ为方差 1 当μ=0，σ=1时，为标准高斯分布 2 当μ改变，σ不变时，分布图像平移 3 当μ不变，σ改变时，分布图像随σ增大而变扁 μ决定对称轴，σ决定扩散程度 https://www.cnblogs.com/lvchaoshun/p/7115460.html ​ 1）最大似然估计 ​ 似然函数：关于统计模型参数的函数，给定模型参数的情况下观测值出现的概率。定义为条件概率： p(\{x_i\}|\mu,\sigma)​ 最大似然估计是利用已知的样本结果，在使用某个模型的基础上，反推有可能导致这样结果的模型参数值 \begin{align} & \Rightarrow 给定观测值\{x_i\}，求\mu和\sigma，是的似然函数最大\\ & \Rightarrow p({\{x_i\} }|\mu,\sigma)=\prod_1^Np({x_i}|\mu,\sigma)\\ & \Rightarrow \hat{\mu},\hat{\sigma}=arg\: max\prod_1^Np({x_i}|\mu,\sigma)\\ 求得：&\hat{\mu}=\frac{1}{N}\sum_{i=1}^Nx_i\\ &\hat{\sigma}=\frac{1}{N}\sum_{i=1}^N(x_i-\hat{\mu})^2 \end{align}​ 即求得一元高斯分布 ​ 2）多元高斯分布 ​ 标准的二元高斯分布： \begin{align}& D=2\\&x=\begin{bmatrix}x & y\end{bmatrix}^T\\&\mu=\begin{bmatrix}0 & 0\end{bmatrix}^T\\&\Sigma=\begin{bmatrix}1 & 0\\ 0 & 1\end{bmatrix}\end{align}​ 三元高斯分布： \begin{align} & D = 3 \\ & x = [x_R\;x_G\;x_B]\\ & \mu = [\mu_R\;\mu_G\;\mu_B]\\ &\Sigma=\begin{bmatrix} \sigma_{x_R}^2 & \sigma_{x_R}\sigma_{x_G} & \sigma_{x_R}\sigma_{x_B}\\ \sigma_{x_R}\sigma_{x_G} & \sigma_{x_G}^2 & \sigma_{x_G}\sigma_{x_B}\\ \sigma_{x_R}\sigma_{x_B} & \sigma_{x_G}\sigma_{x_B} & \sigma_{x_B}^2 \end{bmatrix} \end{align}[3] STL标准模板库[4][5] C++11关键字和新的for循环语法，新的STL容器，多线程，智能指针内存管理 [6][7] 在 Linux 或 Unix 操作系统中，所有的文件和目录都被组织成以一个根节点开始的倒置的树状结构。 ​ /bin命令，/boot启动时的核心文件，/etc系统配置文件，/home用户主目录，/usr应用程序和文件 类似于program files ​ 当前目录：. 上级目录：.. [8] 安装方式​ 1）deb包安装：下载deb格式的软件后，sudo dpkg -i [name].deb ​ 2） tar.gz软件编译安装：解压后，./configure，make，sudo make install ​ 3） apt-get 安装：sudo apt-get install [software-name] ​ 4）脚本安装：例如./clion.sh [9]]]></content>
      <categories>
        <category>SLAM</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令总结]]></title>
    <url>%2F2019%2F09%2F01%2FGit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Commit创建一个提交：1git commit Branch Git分支是指向某个提交记录，不会造成内存上的开销，按逻辑分解工作到不同的分支，星号（ * ）标识表示当前所在分支 创建分支： 1git branch newbranch 切换分支：（从master分支切换到newbranch分支） 1git checkout newbranch 简洁方式： 创建一个分支并且切换到新的分支上 1git checkout -b &lt;branch_name&gt; 1cpp git branch xx master^^2^ Merge 将两个或两个以上的开发历史合并到一起 1git pull = git fetch + git merge Merge模拟： 12345git checkout -b newbranchgit commit -m &quot;newbranch提交&quot;git checkout mastergit commit -m “master提交”git merge newbranch //将newbranch合并到master Rebase 1 合并多个commit为一个完整commit 2 将某一段commit粘贴到另一个分支上 将newbranch分支的工作移到master分支上，实现并行开发：123456git checkout -b newbranchgit commit -m &quot;newbranch更新&quot;git checkout mastergit commit -m &quot;master更新&quot;git checkout newbranchgit rebase newbranch HEAD HEAD 是一个对当前检出记录的符号引用 —— 也就是指向你正在其基础上进行工作的提交记录，常情况下指向分支名 C0 → C1（ master* ）：HEAD → master → C1 然后执行1git checkout C1，变成 HEAD → C1 分离出HEAD并使其指向一个提交记录1git checkout &lt;hash-value&gt; 相对引用（ ^/~ ） 使用 ^ 向上移动 1 个提交记录 使用 ~&lt;num&gt; 向上移动多个提交记录，如 ~3 1git checkout xxx^ 1cpp git checkout xxx~3 强制修改分支位置： 1git branch -f master HEAD^ 将master分支强制移动到HEAD的上一个分支 撤销变更 git reset git reset 向上移动分支，原来指向的提交记录就跟从来没有提交过一样 对共享远程分支无效 1git reset HEAD~1 git revert 撤销更改并支持分享给别人 1git revert HEAD 创建一个新的提交，该提交与HEAD的前一条提交相同 自由修改提交树 git Cherry-pick （知道提交的哈希值 git cherry-pick &lt;提交号&gt;… 将一些提交复制到当前所在的位置（HEAD）下面 12git cherry-pick C3 C4 C5 交互式rebase 参数 —interactive ，简写为 -i 12git rebase -i HEAD~3 调整提交记录的顺序 删除提交 合并提交 标签 可以永久将某个特定的提交命名为里程碑，不会随着新的提交而移动，它表示了某个特定位置 1git tag version1 C1 锚点 描述最近的标签，1git describe &lt;ref&gt;，得到例ref最近的标签、二者间相差多少个提交记录 远程仓库Clone 在本地创建一个远程仓库的拷贝 远程分支 反映了远程仓库的状态，在检出时自动进入分离 HEAD 状态。 远程分支命名规范： [remote name] / [branch name] 例如：origin/master，分支为 master ，远程仓库为 origin 在使用 git clone 时，git将远程仓库命名为 origin（默认命名） 1git checkout origin/master（head分离） Fetch 从远程仓库下载本地仓库缺失的提交记录 更新远程分支指针 （实际上将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态） （为下载操作，不改变本地仓库状态） Pull 从远程仓库获取更新并合并到本地的分支当中 Pushgit push将变更上传到远程仓库，并在其上合并提交记录 偏离的提交历史对于提交已更新的旧版本的更改，需要先合并新版本在提交更改 git commit//对于旧版本的更改 git pull --rebase//合并新版本并提交更改 git push//提交到远程分支]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[19-07-08]]></title>
    <url>%2F2019%2F07%2F10%2F19-07-08%2F</url>
    <content type="text"><![CDATA[Enter password to read. Incorrect Password! No content to display! U2FsdGVkX19r16p3TVMzL9yrzrEAliH1R5/mjl4Eb03HCOFwuEI8nXDkqanVIZMiEQ32h8aFBokdVrluUGWBqQ==]]></content>
  </entry>
  <entry>
    <title><![CDATA[测试]]></title>
    <url>%2F2019%2F06%2F23%2F%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[Hello WorldTestWelcome测试quote test … Testtest Every interaction is both precious and an opportunity to delight. Seth GodinWelcome 1alert('Hello World!');]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F06%2F22%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
